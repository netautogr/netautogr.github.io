<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Network Automation GR</title>
        <link>https://netautogr.github.io/posts/</link>
        <description>Recent content in Posts on Network Automation GR</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Fri, 24 Oct 2025 19:21:01 +0300</lastBuildDate>
        <atom:link href="https://netautogr.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Introduction to Network Simulation Tools for Labs</title>
            <link>https://netautogr.github.io/posts/2025/10/introduction-to-network-simulation-tools-for-labs/</link>
            <pubDate>Fri, 24 Oct 2025 19:21:01 +0300</pubDate>
            
            <guid>https://netautogr.github.io/posts/2025/10/introduction-to-network-simulation-tools-for-labs/</guid>
            <description>Εισαγωγή Το post αυτό κάνει μια διπλή προσπάθεια:
 Να περιγράψει το τοπίο γύρω από το Network Sumulation και τις ανάγκες που μπορεί να καλύψει για network labs και όχι μόνο Να επαναφέρει το ρυθμό της παραγωγής περιοχομένου της ομάδας για το Network Automation σε ένα κύκλο λίγο πιο συχνό από τέσσερα χρόνια (τελευταίο post ήταν το 2021)  Network Simulation Τί είναι; Είναι η προσπάθεια να παράγουμε με ψηφιακό τρόπο μια δικτυακή τοπολογία όπου ψηφιακοί κόμβοι αναπαράγουν τη συμπεριφορά πραγματικών δικτυακών κόμβων όπως routers και switches αλλά και system hosts αν χρειάζεται.</description>
            <content type="html"><![CDATA[<h1 id="εισαγωγή">Εισαγωγή</h1>
<p>Το post αυτό κάνει μια διπλή προσπάθεια:</p>
<ul>
<li>Να περιγράψει το τοπίο γύρω από το Network Sumulation και τις ανάγκες που μπορεί να καλύψει για network labs και όχι μόνο</li>
<li>Να επαναφέρει το ρυθμό της παραγωγής περιοχομένου της ομάδας για το Network Automation σε ένα κύκλο λίγο πιο συχνό από τέσσερα χρόνια (τελευταίο post ήταν το 2021)</li>
</ul>
<h1 id="network-simulation">Network Simulation</h1>
<h2 id="τί-είναι">Τί είναι;</h2>
<p>Είναι η προσπάθεια να παράγουμε με ψηφιακό τρόπο μια δικτυακή τοπολογία όπου ψηφιακοί κόμβοι αναπαράγουν τη συμπεριφορά πραγματικών δικτυακών κόμβων όπως routers και switches αλλά και system hosts αν χρειάζεται. Οι φηψιακοί κόμβοι συνδέονται μεταξύ τους με εικονικούς συνδέσμους και το σύνολο συμπεριφέρεται λίγο έως πολύ σαν ένα πραγματικό δίκτυο.</p>
<h2 id="λειτουργεί-το-ίδιο-ακριβώς-με-ένα-πραγματικό-δίκτυο">Λειτουργεί το ίδιο ακριβώς με ένα πραγματικό δίκτυο;</h2>
<p>Όχι ακριβώς. Οι φηφιακοί κόμβοι είναι άλλοτε απλά processes, άλλοτε virtual machines κι άλλοτε containers. Αντίστοιχα υλοποιούνται οι συνδέσεις ανάλογα με την περίπτωση ώστε να προκύψει η ψηφιακή τοπολογία.</p>
<h2 id="είναι-κάτι-καινούριο">Είναι κάτι καινούριο;</h2>
<p>Σαν ιδέα όχι. Όποιος μελετά για δίκτυα από παλιά (π.χ. γύρω στο 2000), ίσως θυμάται το NS (Network Simulator). Μπορείτε να πάρετε μια ιδέα στα παρακάτω links:</p>
<ul>
<li><a href="https://www.isi.edu/websites/nsnam/ns/">The Network Simulator - ns-2 @ www.isi.edu</a></li>
<li><a href="https://en.wikipedia.org/wiki/Ns_(simulator)">ns (simulator) @ wikipedia</a></li>
</ul>
<p>NS-2 @ Research Gate:
<img src="https://www.researchgate.net/publication/329757869/figure/fig1/AS:11431281318938170@1742574296593/Simulation-environment-of-Network-Simulator-2-NS2.tif" alt="NS-2 image @ Research Gate"></p>
<p>Φυσικά σε σχέση με τις σημερινές πλατφόρμες Network Simulations το NS φαντάζει προϊστορικό. Υλοποιούσε ωστόσο protocol stacks ώστε να μπορεί κάποιος να μελετήσει βασικές συμπεριφορές δικτύων σε λογικό επίπεδο.</p>
<h2 id="εξέλιξη-των-network-simulators---γνωστές-πλατφόρμες">Εξέλιξη των network simulators - Γνωστές Πλατφόρμες</h2>
<p>Με την εξέλιξη του virtual compute (virtual machines &amp; virtual networking), δόθηκε η ευκαιρία για να αποκτήσουν οι κόμβοι και οι τοπολογίες μεγαλύτερες δυνατότητες και να εξομοιώνουν περισσότερα χαρακτηριστικά από αυτά που έχουν οι πραγματικοί δικτυακοί κόμβοι.</p>
<h3 id="cisco-packet-tracer">Cisco Packet Tracer</h3>
<p>Κάποιες εταιρείες παρήγαγαν εργαλεία στοχευμένα στην εκπαίδευση συγκεκριμένων τεχνολογιών. Π.χ. η Cisco έφτιαξε το Cisco Packet Tracer για να μπορούν μαθητές στις ακαδημίες Cisco ανά τον κόσμο αλλά και άλλοι επίδοξοι εκπαιδευόμενοι μηχανικοί να εξοικειωθούν με κάποιες από τις βασικές τεχνολογίες δικτύων της εταιρείας. Το packet tracer χρησιμοποιείται ακόμα και είναι διαθέσιμο στην παρακάτω διεύθυνση:</p>
<p><a href="https://www.netacad.com/cisco-packet-tracer">https://www.netacad.com/cisco-packet-tracer</a></p>
<h3 id="hashicorp-vagrant">Hashicorp Vagrant</h3>
<p>Άλλες εταιρείες δημιούργησαν πιο γενικής φύσης εργαλεία όπου δικτυακοί κόμβοι μπορούσαν να λειτουργήσουν ως virtual machines. H Hashicorp δημιούργησε το Vagrant το οποίο βρήκε αρκετή χρήση ακόμα και από μηχανικούς της Cisco. Μπορεί να μάθει κανείς περισσότερα στην παρακάτω διεύθυνση:</p>
<p><a href="https://www.netacad.com/cisco-packet-tracer">https://www.netacad.com/cisco-packet-tracer</a></p>
<h3 id="gns-3">GNS-3</h3>
<p><a href="https://docs.gns3.com/docs/"><img src="https://docs.gns3.com/img/getting-started/what-is-gns3/1.jpg" alt="Network Topology in GNS-3"></a></p>
<p>Η πρώτη αξιόλογη προσπάθεια για εξομείωση δικτύων ήρθε με την πλατφόρμα GNS-3 (Graphical Network Simulator). Το λογισμικό είναι open source αλλά υπάρχει πίσω του εταιρεία που το υποστηρίζει (περισσότερο θα έλεγα το εμπορεύεται μέσω του Marketplace). Δημιουργήθηκε το 2008 (είχε αρχίσει ως project για διπλωματική από τον ) και επικεντρώθηκε σε δικτυακές συσκευές και το Dynamips simulation engine. Το γραφικό περιβάλλον που είχε έδωσε τη δυνατότητα να σχεδιάζουν οι χρήστες την τοπολογία με σχετικά εύκολο τρόπο και οι συσκευές εξομείωναν πραγματικά μοντέλα συσκευών Cisco, προφανώς με σημαντικούς συμβιβασμούς. Η ανάπτυξη του συνεχίστηκε, ενσωματώνοντας υποστήριξη για πλατφόρμες εικονικών συστημάτων όπως η Vmware και το VirtualBox και δίνοντας έτσι τη δυνατότητα να υποστηρίζει και άλλους εικονικούς κόμβους εκτός από συσκευές Cisco και έδωσε τη δυνατότητα σε μαθητές και μηχανικούς να δημιουργούν network labs χωρίς να χρειάζονται ακριβά, θορυβώδη και δύσκολα στην μετακίνηση και συντήρηση πραγματικά μηχανήματα. Η υποστήριξη και ανάπτυξη του GNS-3 συνεχίστηκε μέχρι σήμερα και ενσωματώνοντας και υποστήριξη για docker έδωσε τη δυνατότητα να προστίθεται και containers στις εικονικές τοπολογίες των εξομειώσεων.</p>
<p><a href="https://docs.gns3.com/docs/">GNS-3 Documentation</a></p>
<h3 id="eve-ng">EVE-NG</h3>
<p>Ένα πολύ πιο δουλεμένο περιβάλλον από το GNS-3, καλύτερα γραφικά, καλύτερο support, πρώτο σε integrations και νέα features, πρώτο σε δυνατότητες αυτοματισμού (με κάποιους περιορισμούς), αλλά για πρώτη φορά και δύο διαφορετικές εκδόσεις. Μία δωρεάν (community edition) και δυστυχώς μία επί πληρωμή (PRO) με διάφορα flavors ανάλογα το scale και το licensing. To EVE-NG υποστήριξε πρώτο αρκετά σημαντικά features (docker, bridge προς το πραγματικό δίκτυο, APIs, προχωρημάνα γραφικά περιβάλλοντα, user roles, κλπ) αλλά και διαφορετικές πλατφόρμες (dynamips, Virtual Machiones με qemu, containers κλπ) και γενικά καλύτερο performance.</p>
<p>EVE-NG Labs Library:</p>
<p><a href="https://www.eve-ng.net/index.php/lab-library/"><img src="https://www.eve-ng.net/wp-content/uploads/2019/11/34_sd-wan_viptela.png" alt="EVE-NG Labs - Cisco OSPFv2/v3"></a></p>
<p>Με τα χρόνια, αν και συνεχίζει να είνα αρκετά δημοφικές ειδικά και για την ενσωμάτωση κι άλλων vendor nodes όπως juniper, arista κλπ αλλά και για την παροχή οδηγών με λεπτομέρεια για την παρακσκευή node templates (πρωτότυπα για τη δημιουργία nodes) και αρκετά καλό documentation, πλέον και το GNS-3 έχει έρθει κοντά στην υποστήριξη features ενώ παραμένει δωρεάν, διαθέτει δε marketplace για nodes και topologies και academy για την εκμάθηση, ενώ το EVE-NG όχι. Παρόλα αυτά συνεχίζει να έχει φανατικούς χρήστες και υπάρχουν αρκετά κατατοπιστικά videos με δύο δημιουργούς να είναι κορυφαίοι μεταξύ των υπολοίπων, ο &ldquo;Data&rdquo; Knoxx, γνωστός trainer από την πλατφόρμα CBT-Nuggets και ο Christian Scholz, μηχανικός της AXIANS σε ανώτατο επίπεδο (Lead Architect).</p>
<p><a href="https://youtu.be/vqV5OgRixs0?si=C3-ZXaedDNR_n3CZ"><img src="https://img.youtube.com/vi/vqV5OgRixs0/maxresdefault.jpg" alt="Introduction to EVE-NG"></a></p>
<ul>
<li><a href="https://www.youtube.com/watch?v=vqV5OgRixs0&amp;list=PLIlpqyrKHrRPcRWKNSFo9qr2Oz307klT1">Data Knoxx youtube playlist on EVE-NG</a></li>
<li><a href="https://youtu.be/mmU5pTdbPRo?si=Rjn5jZYEx_NaeBgw">Building a Juniper EVE-NG Lab-Environment for daily usage - Part 1/3</a></li>
<li><a href="https://www.eve-ng.net/index.php/how-to-eve-ng-api/">EVE-NG REST API</a></li>
</ul>
<h3 id="pnetlab">PNETLab</h3>
<p>Το PNETLab είναι ένα EVE-NG clone που είναι δωρεάν. Έχει κάποια από τα features της EVE-NG PRO έκδοσης αλλά όχι όλα (δεν έχει ακόμα docker support νομίζω), είναι λίγο πίσω στις εκδόσεις, αλλά διαθέτει και το δικό του marketplace και license/user model. Είναι πολύ δημοφιλές σε network engineers που θέλουν να μελετήσουν μεγάλης κλίμακας τοπολογίας και μπορεί κανείς να κατεβάσει labs απευθείας από το marketplace (περίπου, υπάρχουν κάποιες προϋποθέσεις). Πιθανότατα θα το βρεις να χρησιμοποιείται από αρκετούς network trainers. Όπως υποννοεί πάντα το marketplace, δεν είναι πάντα όλα δωρεάν.. To software όμως είναι..</p>
<p><a href="https://user.pnetlab.com/store/labs/view">PNETLab Marketplace:</a>
<img src="https://uploader.pnetlab.com/api/uploader/public/read?file=https://uploader.pnetlab.com/Local/labs/lab_article/802/SDWANlab.png" alt="PNET Lab SD-WAN"></p>
<h3 id="cisco-modeling-labs-cml">Cisco Modeling Labs (CML)</h3>
<p>Παλιότερα γνωστό ως Virl, το <a href="https://www.cisco.com/site/us/en/learn/training-certifications/training/modeling-labs/index.html">CML</a> είναι στην έκδοση 2.9 πλέον και συνήθως αναφέρονται σε αυτό ως CML-2 ακριβώς για να δείξουν αυτή τη διαφορά. Είναι η πλατφόρμα φτιαγμένη από ομάδα μηχανικών της Cisco, μεταξύ των οποίων ο γνωστότερος και αυτός που παίρνει το περισσότερο credit για την ανάπτυξη του είναι ο Ralph Schmieder.
Το CML έρχεται τελευταίο στη γιορτή.. Είναι μια πλατφόρμα που υποστηρίζει κυρίως QEMU based virtual machines και μπορεί να τρέξει IOSv (τα παλιά cisco platforms για simulation), τα IoL (IOS on Linux) images, δίνοντας πρόσβαση σε εξομοιώσεις γνωστών network platforms της Cisco (NXOS, Catalyst, ISR/CSR, IOS-XRd, κλπ) αλλά και αρκετά άλλα nodes της Cisco που ξεφεύγουν από τον ορισμό του network node όπως Cisco Firepower FTD και FMC, Cisco ISE, Cisco SD-WAN manager, κλπ. Λόγω του ότι προέρχεται από τον κατασκευαστή Cisco έχει μοναδική πρόσβαση στα resources αυτά ως images, τα οποία ωστόσο &hellip; με μαγικούς τρόπους μεταφέρονται προς άλλες πλατφόρμες εξομοίωσης. Είναι αυτό νομότυπο κατά τη Cisco; Όχι προφανώς. Για να χρησιμοποιήσει κάποιος Cisco images πρέπει να έχει είτε το CML είτε κάποιο σχετικό συμβόλαιο με τη Cisco που να αφορά αυτές τις πλατφόρμες ώστε να μπορεί να κατεβάσει το software. Και πάλι υπάρχει μηχανισμός licensing για όλα αυτά. Ωστόσο οι μηχανικοί που θέλουν να τα χρησιμοποιήσουν σε άλλες πλατφόρμες, βρίσκουν συνήθως διάφορους τρόπους. Δεν θα περιγράψουμε τίποτε τέτοιο σε αυτό το post, δεν υποστηρίζουμε καμία τέτοια χρήση, το ίδιο αναφέρουν κι όλοι οι υπόλοιποι κατασκευαστές για network simulation platforms.</p>
<p><img src="https://pubhub.devnetcloud.com/media/cisco-modeling-labs-2-9/docs/img/iol-xe_feature_test_topology.png#developer.cisco.com" alt="CML Topology">
CML Topology</p>
<p>Το CML είναι γενικά χειρότερο στην διαχείριση resources, αργεί να υιοθετήσει features (μόλις ενσωμάτωσε υποστήριξη για docker) και είναι εξωφρενικά ακριβό αν αναλογιστεί κανείς ποιοι είναι αυτοί που το χρειάζονται για να μάθουν την τεχνολογία. Ένα ακόμα μειονέκτημα είναι πως για να ενσωματώσετε network device images από άλλους vendors στο ίδιο lab ενδεχομένως χρειάζεται να βρείτε και να εισάγετε τα images μόνοι σας, καθώς το CML έρχεται μόνο με Cisco created images. Από την άλλη αν θέλετε να το κάνετε αυτό, γιατί να χρησιμοποιήσετε CML;</p>
<p>Όπως προανέφερα, είναι ακριβό. Υπάρχουν 2 εκδόσεις Personal (για 20 και 40 nodes) ενώ η Enterprise έκδοση για χρήση σε εταιρικό περιβάλλον είναι απόλυτα απαγορευτική ως κόστος. Ωστόσο υπάρχουν πλέον και free tier για μέχρι 5 nodes (δεν μετράνε τα unmanaged switches, οπότε μπορείτε να φτιάξετε κάτι λίγο πιο μεγάλο με δρομολογητές, αλλά και πάλι..)</p>
<p>Και το CML υποστηρίζει REST API και μάλιστα υπάρχει και Terraform provider γι αυτό. Χρήσιμα links:</p>
<ul>
<li><a href="https://blogs.cisco.com/learning/get-started-with-terraform-and-cisco-modeling-labs">Παλιό post του Ralph στο Cisco Blog για Get Started With Terraform and Cisco Modeling Labs</a></li>
<li><a href="https://www.ciscolive.com/on-demand/on-demand-library.html?search=2722#/session/1750271907143001zYw6">Παρουσίαση από τον Ralph στο San Diego Cisco Live 2025</a></li>
<li><a href="https://registry.terraform.io/providers/CiscoDevNet/cml2/latest">CML Terraform Provider</a></li>
<li><a href="https://www.kwtrain.com/labs">Δωρεάν Lab Guides για CML από τον Kevin Wallace</a></li>
</ul>
<h3 id="containerlab">Containerlab</h3>
<p>Το <a href="https://containerlab.dev/">Containerlab</a> έχει φέρει επανάσταση στους Network Simulators, δίνοντας τη δυνατότητα για την κατασκευή network labs με χρήση containers. Η ιδέα ξεκίνησε από τον Wim Hendrickx (Nokia - Head of IP Architecture), αλλά ήταν ο Roman Dodin (Nokia - Product Line Manager) και μια ομάδα μηχανικών που το «πήγε στο επόμενο επίπεδο». Ξεκίνησε ως ένα open-source project και προέκυψε από την ανάγκη για έναν πιο απλό και γρήγορο τρόπο δημιουργίας lab topologies με network operating systems όπως το Nokia SR Linux. Η βασική φιλοσοφία ήταν η δημιουργία ενός εργαλείου όσο το δυνατόν πιο ελαφρύ, ικανού να τρέξει σε ένα απλό laptop αν χρειαστεί. Με τον καιρό εξελίχθηκε ώστε να περιλαμβάνει περισσότερα χαρακτηριστικά, ενσωματώνοντας κι άλλα δικτυακά λειτουργικα συστήματα που έχουν μετατρέψει οι αντίστοιχοι κατασκευαστές σε μορφή container.</p>
<p><a href="https://youtu.be/srnhoLpxgZ4?si=x3xbi1gyEc27wq9R"><img src="https://img.youtube.com/vi/srnhoLpxgZ4/maxresdefault.jpg" alt="The story of Containerlab at at Network Automation Nerds with Roman Dodin"></a>
The story of Containerlab at Network Automation Nerds with Roman Dodin</p>
<p>Ωστόσο, υπάρχει η δυνατότητα για ενσωμάτωση και δικτυακών λειτουργικών συστημάτων που βρίσκονται σε μορφή Virtual Machine βασισμένα σε quemu, &ldquo;πακετάροντας&rdquo; τα μέσα σε containers, όπως π.χ. Cisco IoL, CSR, Catalayst 9kv, Nexus9kv, κλπ, χρησιμοποιώντας το vrnetlab project και συγκεκριμένα ένα fork του (γνωατό ως hellt από το github username του Roman Dodin).</p>
<p><a href="https://github.com/srl-labs/vrnetlab/releases/tag/v0.21.0">https://github.com/srl-labs/vrnetlab/releases/tag/v0.21.0</a></p>
<p>Η δυνατότητα χρήσης container images δίνει ένα πολύ σημαντικό πλεονέκτημα στο Containerlab καθώς μπορεί να λειτουργήσει απόλυτα σε συνθήκες IaC (Infrastructure as Code), δημιουργώντας ένα network lab σε πλήρη μορφή και configuration state σε λίγα λεπτά, από το τίποτε, ενώ σε πλατφόρμες με χρήση VMs templates δεν υπάρχει η ίδια ευελιξία, καθώς τα VMs βασίζονται πολύ σε σταθερό storage και τα βήματα για να βρεθούν σε ένα τελικό state από τη δημιουργία ενός lab είναι πολύ περισσότερα, ενώ πρέπει η κάθε πλατφόρμα να υποστηρίζει κατάλληλα APIs και οι χρήστες της πλατφόρμας να δημιουργήσουν συγκεκριμένα automated flows για να φτάσουν το lab στην επιθυμητή κατάσταση.</p>
<p>Το Containerlab δημιουργήθηκε με αυτή τη φιλοσοφία κι γι αυτό αποδίδει σε αυτές τις συνθήκες εξαιρετικά, ελαχιστοποιώντας το footprint των εργαστηρίων και δίνοντας τη δυνατότητα να δημιουργείται και να καταστρέφεται το εργαστήριο όσες φορές θέλουμε, διατηρώντας τα αρχεία ρυθμίσεων αν θέλουμε σε εξωτερικά αρχεία κειμένου στο folder structure του lab.
Το άλλο πλεονέκτημα του είναι πως είναι εξαιρετικά εύκολος ο διαμοιρασμός εργαστηρίων και η δημιουργία και συντήρηση από κοινού χρησιμοποιώντας το git για version control, ενώ το ίδιο το Containerlab μπορεί να &ldquo;κατεβάσει&rdquo; και να τρέξει ένα lab από ένα remote git repository, όπως περιγράφει η Claudia De Luna στο παρακάτω post:</p>
<p><a href="https://gratuitous-arp.net/containerlab-the-anti-pattern/">https://gratuitous-arp.net/containerlab-the-anti-pattern/</a> - Claudia De Luna, Containerlab the anti-pattern.</p>
<p>Τέλος, η ομάδα της Nokia που υποστηρίζει το Containerlab έχει δημιουργήσει και μια <a href="https://containerlab.dev/manual/vsc-extension/">επέκταση για το vs-code</a>, δίνοντας τη δυνατότητα για γραφικο τρόπο σχεδιασμού και λειτουργίας της πλατφόρμας με εξαιρετικά απλό τρόπο.</p>
<p><img src="https://containerlab.dev/images/vscode-extension/02-topo_viewer_editor.png" alt="VS-Code Containerlab Extension"></p>
<p>Σήμερα το Containerlab αποτελεί ένα δημοφιλές, δωρεάν και open-source εργαλείο που απλοποιεί τη δημιουργία και διαχείριση network labs, καθιστώντας το κατάλληλο για testing, demos, αλλά και για CI/CD pipelines. Ακολουθεί άλλο ένα post από το Nico Vilbert της Isovalent, αν και λίγο παλιό:</p>
<p><a href="https://nicovibert.com/2022/06/09/first-look-into-containerlab/">https://nicovibert.com/2022/06/09/first-look-into-containerlab/</a></p>
<h3 id="netlab">Netlab</h3>
<p>Όπως λέει κι ο φίλος Μανώλης, &ldquo;αν το Containerlab το ερωτεύεσαι, το <a href="https://netlab.tools/">Netlab</a> το παντρεύεσαι&rdquo;. To Netlab έχει δημιουργηθεί από τον Ivan Pepelnjak και έχει τη δυνατότητα βασισμένο σε yaml configuration files να δημιουργεί και να τρέχει δικτυακές τοπολογίες σε vagrant ή containerlab και να δημιουργεί Ansible invetories για αυτές. Μπορεί να χρησιμοποιεί διάφορους virtualization providers (KVM/libvirt, Docker containers) ή και φυσικά συστήματα.
Το netlab, με βάση το configuration file σε Yaml που θα φτιάξετε, θα ρυθμίσει IP addressing, routing protocols, VLANs, VRFs, και άλλες δικτυακές τεχνολογίες, δημιουργώντας όλα τα απαραίτητα configs για κάθε μέρος τους, και θα σηκώσει απλά το lab λειτουργικό και έτοιμο προς χρήση.</p>
<p>Μπορείτε να δείτε ακριβώς τις προϋποθέσεις χρήσης του containerlab (είναι λίγο πιο πίσω σε συμβατότητα όσο αφορά τις εκδόσεις) με το netlab στο παραλάτω link, όπως και ποια vendor images υποστηρίζονται για αυτό το integration:</p>
<p><a href="https://netlab.tools/labs/clab/">https://netlab.tools/labs/clab/</a></p>
<p>Ακολουθεί ένα εξαιρετικό post που περιγράφει ένα τέτοιο lab setup, by <a href="https://mycv.bytewise.me/">Manolis Kalliotis</a>.</p>
<p><a href="https://net4fungr.github.io/posts/iou-love/">https://net4fungr.github.io/posts/iou-love/</a></p>
<h2 id="vendor-images">Vendor Images</h2>
<p>Πολλά από τα vendor images είναι πρακτικά QEMU images κατάλληληλα είτε για το CML είτε για το EVE-NG (άρα και το PNETLab) ή το GNS-3 (θα πρέπει να ψάξετε τη διαδικασία ενσωμάτωσης στο αντίστοιχο documentation κάθε πλατφόρμας). Για το Containerlab χρειάζεται να χρησιμοποιήσετε το vrnetlab για να πακετάρετε τέτοια images ως containers.
Και αναφέρουμε ωστόσο τα containers, κάποιοι vendors διαθέτουν τέτοια images έτοιμα.</p>
<h3 id="cisco">Cisco</h3>
<p>Προσοχή σε ότι αφορά εξομείωση SD-WAN, η Cisco έχει δημιουργήσει ξεχωριστά images γι αυτό.</p>
<h4 id="iol">IoL</h4>
<p><a href="https://developer.cisco.com/docs/modeling-labs/iol/#iol">IOS on Linux</a>, QEMU based, δουλεύουν πολύ καλά για μεγάλες τοπολογίες γιατί δεν θέλουν πολλά resources σε αντίθετα με γνωστά άλλα virtual platforms της Cisco.
Αναφορά σε χρήση IoL στο documentation του Containerlab: <a href="https://containerlab.dev/manual/kinds/cisco_iol/">https://containerlab.dev/manual/kinds/cisco_iol/</a></p>
<h4 id="nxos">NXOS</h4>
<p>Η γνωστή πλατφόρμα datacenter networking της Cisco είχε μια πιο άδοξη έκδοση για Cisco Nexus 7000 αλλά οι πιο αξιόπιστες είναι οι πιο πρόσφατες εκδόσεις Nexus 9kv. Χρειάζονται πάρα πολλά resources για να λειτουργήσουν σωστά σε οποιαδήποτε πλατφόρμα εξομείωσης.</p>
<h4 id="cat8k">Cat8k</h4>
<p>Τα γνωστά nodes που αντικατέστησαν τις ISR και CSR πλατφόρμες. Τα Catalyst 8kv είναι τα αντίστοιχα νέα virtual nodes που είναι διαθέσιμα τόσο στο CML όσο και στο γνωστό Denvet Sanbdox για δοκιμαστική χρήση. Και αυτά θέλουν αρκετά resources.</p>
<h4 id="cat9k">Cat9k</h4>
<p>Αντίστοιχα έκδοση της γνωστής πλατφόρμας Catalyst 9k σε virtual edition με λίγες θύρες. Έχει βγει σε 2 εκδόσεις, με λίγο καλύτερη υποστήριξη features σε μία από τις δύο και ακόμα μεγαλύτερη ανάγκη από resources. Μην περιμένετε όλα τα features και μάλιστα σε ότι αφορά το switching (ούτε λόγος για SD-Access). Για περιπτώσεις χρήσης iox (ενσωματωμένους containers) διάβασα πρόσφατο σχόλιο του Joe Clark ότι υποστηρίζεται προς το παρόν μόνο στο Cat8k, εντός CML. Και πάλι, καλή τύχη&hellip;</p>
<h4 id="ios-xr">ios-xr</h4>
<p>Η γνωστή πλατφόρμα για Service Providers σε έκδοση virtual. Δεν έχω ιδέα πόσο καλά λειτουργεί.. Γνωρίζω φήμες για προβλήματα αλλά αν πιστέψουμε τη Cisco το έχουν χρησιμοποιήσει ως Route Reflector.. Μερικά links:</p>
<ul>
<li><a href="https://developer.cisco.com/docs/modeling-labs/ios-xrv/">https://developer.cisco.com/docs/modeling-labs/ios-xrv/</a></li>
<li><a href="https://www.cisco.com/en/US/docs/ios_xr_sw/ios_xrv/install_config/b_xrvr_432_chapter_01.html">https://www.cisco.com/en/US/docs/ios_xr_sw/ios_xrv/install_config/b_xrvr_432_chapter_01.html</a></li>
<li><a href="https://xrdocs.io/virtual-routing/">https://xrdocs.io/virtual-routing/</a></li>
</ul>
<h3 id="arista">Arista</h3>
<p>Η Arista έχει βγάλει εκδόσεις του δικτυακού λειτουργικού της τόσο ως Virtual Machine όσο και ως Container και είναι η μοναδική εταιρεία που δεν κρύβει εντελώς τα images πίσω από Regwall ή Paywall. Για αυτό και τα Arista images είναι πολύ δημοφιλή για δημιουργία labs. Δημιουργείτε απλά χρήστη στο site της Arista και στη συνέχεια κατεβάζετε το αντίστοιχο image.</p>
<ul>
<li><a href="https://www.arista.com/en/support/software-download">https://www.arista.com/en/support/software-download</a></li>
<li><a href="https://www.arista.com/en/products/eos">https://www.arista.com/en/products/eos</a></li>
<li><a href="https://arista.my.site.com/AristaCommunity/s/article/Getting-Started-with-cEOS-lab-in-Containerlab#Comm_Kna_ka0Uw00000082z7IAA_81">https://arista.my.site.com/AristaCommunity/s/article/Getting-Started-with-cEOS-lab-in-Containerlab#Comm_Kna_ka0Uw00000082z7IAA_81</a></li>
</ul>
<h3 id="juniper">Juniper</h3>
<p>Η Juniper διαθέτει αρκετά virtual images για labs, vJunos-switch, vJunosEvolved, vJunos-router, cJunosEvolved. Η διαδικασία για να πάρετε πρόσβαση στα images περιγράφεται στο παρακάτω link:</p>
<p><a href="https://www.juniper.net/us/en/dm/vjunos-labs.html">https://www.juniper.net/us/en/dm/vjunos-labs.html</a></p>
<p>Μην ξεχνάμε εδώ την πολύ καλή δουλειά που έχει κάνει ο Christian Scholtz με labs για Juniper όπως ανέφερα παραπάνω:
<a href="https://youtu.be/mmU5pTdbPRo?si=Rjn5jZYEx_NaeBgw"><img src="https://img.youtube.com/vi/mmU5pTdbPRo/maxresdefault.jpg" alt="Building a Juniper EVE-NG Lab-Environment for daily usage - Part 1/3"></a></p>
<p>Υπάρχει όμως και ο Suresh Vinasiththamby, ο οποίος δημοσιεύει αρκετές φορές υλικό για labs με Juniper nodes. Μόλις σήμερα (τρομερός συγχρονισμός!!) δημοσίευσε και ένα άρθρο για virtual labs που μπορείτε να βρείτε εδώ:</p>
<p><a href="https://www.packetswitch.co.uk/network-labs-on-a-budget/">https://www.packetswitch.co.uk/network-labs-on-a-budget/</a></p>
<p>Άλλα links από το blog του Suresh που ίσως βρείτε ενδιαφέροντα:</p>
<ul>
<li><a href="https://www.packetswitch.co.uk/netlab-the-fastest-way-to-build-network-labs/">https://www.packetswitch.co.uk/netlab-the-fastest-way-to-build-network-labs/</a></li>
<li><a href="https://www.packetswitch.co.uk/tag/juniper/">https://www.packetswitch.co.uk/tag/juniper/</a></li>
<li><a href="https://www.packetswitch.co.uk/running-eve-ng-in-proxmox/">https://www.packetswitch.co.uk/running-eve-ng-in-proxmox/</a></li>
</ul>
<h3 id="nokia-sr-linux">Nokia SR-Linux</h3>
<p>H Nokia διαθέτει τα SR-Linux images ως containers εντελώς δημόσια (ούτε restistration δεν χρειάζεται). Είναι πολύ εύκολο να αφήσετε το containeral να κατεβάσει τοπικά τα αντίστοιχα images από τα συνήθη container registries ή να τρέξετε απλά την εντολή:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">docker pull ghcr.io/nokia/srlinux
</code></pre></div><p>Ορισμένα links για το SR-Linux:</p>
<ul>
<li><a href="https://www.nokia.com/ip-networks/service-router-linux-NOS/">https://www.nokia.com/ip-networks/service-router-linux-NOS/</a></li>
<li><a href="https://containerlab.dev/manual/kinds/srl/">https://containerlab.dev/manual/kinds/srl/</a></li>
<li><a href="https://documentation.nokia.com/srlinux/24-7/books/product-overview/about-sr-linux.html#what-sr-linux-product-overview">https://documentation.nokia.com/srlinux/24-7/books/product-overview/about-sr-linux.html#what-sr-linux-product-overview</a></li>
<li><a href="https://learn.srlinux.dev/">https://learn.srlinux.dev/</a></li>
</ul>
<h3 id="linux-hosts">Linux Hosts</h3>
<p>Τα linux hosts μπορούν να χρησιμοποιηθούν σε τέτοιες πλατφόρμες κυρίως ως virtual machines αλλά και ως containers. Μέχρι τώρα δεν έχω βρει άλλο τρόπο να τρέξω μια ομάδα services με docker-compose εκτός κι αν στήσω ένα virtual machine με linux (π.χ. Ubuntu Server) και μετά μέσα εκεί τρέξω docker και docker-compose. Ωστόσο μπορεί κανείς να δημιουργήσει το σύνολο από τα services εντός μια τέτοιας πλατφόρμας ως containers, αρκεί να ρυθμίσει σωστά ότι είναι απαραίτητο π.χ. τα volume mounts κλπ.
Θα βρείτε αναφορές και σε ειδικά διαμορφωμένα images για network labs και testing στο documentation του Containerlab, δείτε π.χ. εδώ:</p>
<p><a href="https://github.com/srl-labs/srl-telemetry-lab/blob/main/st.clab.yml#L55">https://github.com/srl-labs/srl-telemetry-lab/blob/main/st.clab.yml#L55</a></p>
<p>Εκτός από ένα πλήρες topology με prometheus &amp; grafana περιέχει και αναφορές σε ορισμό client nodes με το image για το network-multitool, ένα image βασισμένο σε Alpine Linux με ειδική διαμόρφωση για network testing. Στην τοπολογία που υπάρχει στο link, τα nodes ρυθμίζονται με συγκεκριμένες ip addresses και τρέχουν iperf εντολές για τη δημιουργία network traffic εντός του lab.</p>
<p>Στην περίπτωση που θέλει κανείς να στήσει κάτι πιο γενικό και με την έκδοση linux που θέλει εντός EVE-NG, υπάρχει οδηγός στο documentation του EVE-NG που εξηγεί πως να φτιάξετε template με όποιο λειτουργικό θέλετε αρκεί να διαθέτετε το ISO της εγκατάστασης:</p>
<p><a href="https://www.eve-ng.net/index.php/documentation/howtos/howto-create-own-linux-host-image/">https://www.eve-ng.net/index.php/documentation/howtos/howto-create-own-linux-host-image/</a></p>
<h3 id="docker-images">Docker images</h3>
<p>Θεωρητικά οποιοδήποτε docker image μπορεί να τρέξει εντός των διαφόρων πλατφορμών (εκτός φυσικά του PNETLab όπως είπαμε, τουλάχιστον προς το παρόν) αρκεί να είναι linux based image. Οι απαραίτητες ρυθμίσεις είναι σαν να ορίζετε τις παραμέτρους για docker run. Θα βρείτε ωστόσο πως εκτός κι αν το κάνετε στο containerlab, κάποια πράγματα όπως τα εξωτερικά volume mounts είναι λίγο πιο δύσκολα..</p>
<p>Για να εντάξετε docker images σε EVE-NG labs, δεν θα βρείτε αναφορές στο documentation εκτός από το παρακάτω video:</p>
<p><a href="https://youtu.be/49f3JX6vFrk?si=FwWX2qZMpRYj04zL"><img src="https://img.youtube.com/vi/49f3JX6vFrk/maxresdefault.jpg" alt="Embeded docker eve-ng"></a></p>
<h2 id="hosting-platforms">Hosting Platforms</h2>
<p>Για να χρησιμοποιήσετε ένα λογισμικό για Network Simulation χρειάζεστε μια πλατφόρμα που θα το φιλοξενήσει. Υπάρχουν διάφορες επιλογές ανάλογα με το τί έχετε διαθέσιμο ως φυσικούς πόρους αλλά και από οικονομικής πλευράς.. Το σίγουρο είναι πως όπου και να το τρέξετε θα χρειαστείτε μνήμη, πολύ μνήμη&hellip;</p>
<h3 id="vmware-workstation--esxi--vcenter">Vmware Workstation / ESXi / VCenter</h3>
<p>Τόσο το Vmware Workstation που τρέχει σε περιβάλλοντα desktop όσο το Vsphere ESXi που είναι η απλή έκδοση του Vmware Hypervisor και τρέχει σε φυσικά συστήματα, διατίθενται δωρεάν (παρά τις προσωρινές παρενέργειες από την εξαγορά της Vmware από τη Broadcom) και παραμένουν μια από τις καλύτερες επιλογές για να τρέξει το λογισμικό εξομείωσης σε ένα home lab.
Σε εταιρικά περιβάλλοντα η χρήση των πλατφόρμων της Vmware απαιτεί εμπορικές άδειες και ειδικά για esxi hypervisors απαιτείται και η χρήση της πλατφόρμας διαχείρισης VCenter. Αν έχετε τέτοια δυνατότητα, φροντίστε σε κάθε περίτπωση τα φυσικά συστήματα να υποστηρίζουν nested virtualization και να το έχετε ενεργοποιήσει τόσο στο BIOS όσο και στους hypervisors, στα ίδια τα virtual machines τα οποία θα φιλοξενήσουν π.χ. το EVE-NG, το PNETLab ή το Containerlab.
H vmware ζητά να εκδώσετε μια δωρεάν άδεια για προσωπική χρήση του Workstation ή του ESXi αλλά πρόκειται για εξαιρετικά απλή διαδικασία.
<a href="https://www.vmware.com/products/desktop-hypervisor/workstation-and-fusion">https://www.vmware.com/products/desktop-hypervisor/workstation-and-fusion</a> - Vmware Page on Workstation</p>
<h3 id="proxmox">Proxmox</h3>
<p>Δωρεάν εναλλακτική για hypervisor η οποία έγινε πολύ δημοφιλής την εποχή που η Broadcom αποφάσισε προσωρινά να σταματήσει τη δωρεάν διάθεση του Vmware ESXi. Υπάρχουν αρκετά blogs και Youtube videos που περιγράφουν την εγκατάσταση και τη χρήση του και μπορείτε να στήσετε και διαδικασίες backup αλλά και να χρησιμοποιήσετε διαδικασίες IaC μέσω Terraform για το provisioning συστημάτων. Χρήσιμα links:</p>
<ul>
<li><a href="https://pve.proxmox.com/wiki/Main_Page">https://pve.proxmox.com/wiki/Main_Page</a> - Proxmox main wiki</li>
<li><a href="https://app.pluralsight.com/library/courses/proxmox-ve-fundamentals/table-of-contents">https://app.pluralsight.com/library/courses/proxmox-ve-fundamentals/table-of-contents</a> - Proxmox training (απαιτείται συνδρομή Pluralsight)</li>
<li><a href="https://www.packetswitch.co.uk/running-eve-ng-in-proxmox/">https://www.packetswitch.co.uk/running-eve-ng-in-proxmox/</a> - post από Suresh Vina για eve-ng on proxmox</li>
<li><a href="https://www.proxmox.com/en/products/proxmox-backup-server/overview">https://www.proxmox.com/en/products/proxmox-backup-server/overview</a> - proxmox backup server</li>
<li><a href="https://www.xda-developers.com/i-set-up-disposable-proxmox-vms/">https://www.xda-developers.com/i-set-up-disposable-proxmox-vms/</a> - proxmox automation no1</li>
<li><a href="https://spacelift.io/blog/terraform-proxmox-provider">https://spacelift.io/blog/terraform-proxmox-provider</a> - proxmox automation no2</li>
<li><a href="https://registry.terraform.io/providers/Terraform-for-Proxmox/proxmox/latest/docs">https://registry.terraform.io/providers/Terraform-for-Proxmox/proxmox/latest/docs</a> - terraform provider</li>
<li><a href="https://youtu.be/5j0Zb6x_hOk?si=i2iiym8Pj7vUt8JH">https://youtu.be/5j0Zb6x_hOk?si=i2iiym8Pj7vUt8JH</a> - Intro Guide</li>
<li><a href="https://youtu.be/lFzWDJcRsqo?si=YCUafIZYBThZVPdD">https://youtu.be/lFzWDJcRsqo?si=YCUafIZYBThZVPdD</a> - Course</li>
</ul>
<h3 id="kubernetes">Kubernetes</h3>
<p>Ακούγεται τραβηγμένο.. Ωστόσο υπάρχει to clabernetes ή απλά, c9s! Δηλαδή το λογισμικό που επιτρέπει να τρέξετε το Containerlab με τα resources μοιρασμένα σε kubernetes clusters!! Αν χρειάεζεστε παραπάνω resources και έχετε πρόσσβαση σε τέτοια υποδομή, καλή τύχη!!
Το Clabernetes δημιουργήθηκε από τον Carl Montanari. Χρήσιμα links:</p>
<ul>
<li><a href="https://containerlab.dev/manual/clabernetes/">https://containerlab.dev/manual/clabernetes/</a> - Clabernetes manual page at Containerlab documentation</li>
<li><a href="https://github.com/srl-labs/clabernetes">https://github.com/srl-labs/clabernetes</a> - Clabernetes Github repo</li>
<li><a href="https://www.youtube.com/watch?v=K7ms3Hl928w">https://www.youtube.com/watch?v=K7ms3Hl928w</a> - Expand Your Network Labs With Containerlab and Clabernetes, Packet Pushers</li>
<li><a href="https://ripe88.ripe.net/presentations/31-clabernetes-ripe88.pdf">https://ripe88.ripe.net/presentations/31-clabernetes-ripe88.pdf</a> - Simulating networks at scale with Clabernetes and OVHcloud</li>
</ul>
<h3 id="cloud-rentals">Cloud Rentals</h3>
<p>Υπάρχουν πλατφόρμες σε γνωστούς cloud providers που δίνουν τη δυνατότητα να νοικιάσετε μια υποδομή εξομείωσης. Μία από αυτές αναφέρεται στο ίδιο το site του EVE-NG (CloudmyLab), αλλά υπάρχουν κι άλλες.
<a href="https://cloudmylab.com/services/hosted-emulators/eve-ng">https://cloudmylab.com/services/hosted-emulators/eve-ng</a>
<a href="https://www.cloudlabbox.com/">https://www.cloudlabbox.com/</a>.</p>
<p>Το Cloudmylab κάνει host και άλλα λογισμικά εξομείωσης όπως GNS-3 και CML 2.0. Ο πλήρης κατάλογος των υπηρεσιών είναι στο παρακάτω link:</p>
<p><a href="https://cloudmylab.com/services">https://cloudmylab.com/services</a></p>
<h3 id="github-codespaces">Github Codespaces</h3>
<p>Τα github codespaces είναι περιβάλλοντα ανάπτυξης και δοκιμών στο Github που στήνονται γύρω από github repositories. Πρόκειται πρακτικά για ένα linux container που σηκώνεται στο cloud με έτοιμο κώδικα (από το repository) για να μπορέσει κανείς να δοκιμάσει πράγματα χωρίς να έχει ανάγκη ένα περιβάλλον σε δική του υποδομή και όλο το editing και management γίνεται μέσω του browser, όπου η microsoft πρακτικά τρέχει το vs-code στο browser. Υπάρχει βέβαια δυνατότητα να κάνετε πράγματα μέσα από το τοπικό σας vs-code μέσω του αντίστοιχου extension. Μερικά links:</p>
<ul>
<li><a href="https://docs.github.com/en/codespaces/about-codespaces/what-are-codespaces">https://docs.github.com/en/codespaces/about-codespaces/what-are-codespaces</a> - documentation</li>
<li><a href="https://github.com/features/codespaces">https://github.com/features/codespaces</a> - features &amp; getting started</li>
<li><a href="https://docs.github.com/en/codespaces/developing-in-a-codespace/using-github-codespaces-in-visual-studio-code">https://docs.github.com/en/codespaces/developing-in-a-codespace/using-github-codespaces-in-visual-studio-code</a> - Πως να τρέξετε codespaces στο vs-code (μέσω του extension)</li>
</ul>
<p>Τα περισσότερα περιβάλλοντα είναι αδύνατο να τρέξουν σε containers στο cloud. Όχι όμως το containerlab, και αυτή την εξαίρετη ιδέα χρησιμοποίησε ο Eric Chou όταν δημιούργησε το 100 Days of Nautobot Challenge. Μπορείτε εντός του challenge στις πρώτες 20 μέρες να δείτε το containerlab σε δράση, στο cloud, στο browser σας, χωρίς να χρειάζετε να αφιερώσετε resources σε δικό σας σύστημα:</p>
<ul>
<li><a href="https://networktocode.com/blog/2025-01-16-100-days-of-nautobot/">https://networktocode.com/blog/2025-01-16-100-days-of-nautobot/</a></li>
<li><a href="https://github.com/nautobot/100-days-of-nautobot">https://github.com/nautobot/100-days-of-nautobot</a></li>
<li><a href="https://medium.com/@florian.loehden/100-days-of-nautobot-175915146de5">https://medium.com/@florian.loehden/100-days-of-nautobot-175915146de5</a></li>
</ul>
<p>Λίγο προσοχή πρέπει να δώσει κανείς στο ότι όταν ξεκινά ένα codespace, αυτό καταρχήν καταναλώνει storage. Έχετε συγκεκριμένο quota στο github με το χρήστη σας μέχρι να φτάσετε στο σημείο που η δωρεάν συνδρομή δεν θα είναι πλέον αρκετή. Πρακτικά όσο αφήνετε το codespace να υπάρχει, τρώτε από το quota σας.
Αν σβήσετε το codespace και το ξαναδημιουργήσετε (παίρνει λίγα λεπτά η δημιουργία ανάλογα την περίπτωση) τότε έχετε προφανώς κάνει &ldquo;reset&rdquo; αφού ότι αρχεία δημιουργήσατε/προσθέσατε στον container κι όλο σας το history έχουν διαγραφεί.
Τέλος τα resources που μπορείτε να αφιερώσετε στο codespace που θα τρέξετε, είναι συγκεκριμένα. Υπάρχουν διάφορα tires. Από όσο μπορώ να καταλάβω, στα ευρωπαϊκά datacenters της Microsoft όπου τρέχει το Github (πιθανότατα azure sites), είναι πιο περιορισμένες οι επιλογές από ότι στα US based. Και μην ξεχνάτε, στο network emulation, χρειάζονται resources (πρακτικά μόνο με images με μικρό footprint μπορείτε να παίξετε στο δωρεάν tier). Και επίσης, μην ξεχνάτε το copyright..
Κατά τα άλλα, θεωρώ πως είναι εξαιρετική ιδέα και δίνει σε όλους τη δυνατότητα να δουν κάποια πράγματα σε δράση χωρίς να αφιερώσουν ιδιαίτερα resources πέρα από το χρόνο τους φυσικά.
ή.. Απλά νοικιάζετε ένα cloud server με περισσότερα resources και στήνετε ένα containerlab instance από την αρχή..</p>
<h1 id="aπομόνωση-ή-σύνδεση">Aπομόνωση ή σύνδεση;</h1>
<p>Ανάλογα τί θέλετε να δοκιμάσετε και πως βλέπετε το θέμα της ασφάλειας για τα δεδομένα του lab σας αλλά και την πιθανότητα να προκαλέσετε προβλήματα σε πραγματικό δίκτυο, έχετε διαφορετικές επιλογές στο πως να συνδέσετε το lab σας στο δίκτυο και πως να ορίσετε την πρόσβαση σε αυτό.
Πρακτικά έχουμε να κάνουμε είτε με virtual switches (virtual machine based) είτε με linux bridges (container based). Αν έχετε να κάνετε με simulation πάνω σε vm προσέξτε σε ποιο virtual switch θα συνδέσετε το simlation host (τυπικα οι επιλογές είναι: jost-only/nat/bridged).</p>
<h2 id="ασφάλεια---airtight">Ασφάλεια - Airtight</h2>
<p>Μπορεί να θέλετε ένα πλήρως απομονωμένο περιβάλλον. Στο containerlab μπορείτε να πετύχετε εύκολα κάτι τέτοιο ορίζοντας απλά το management network ή αφήνοντας τα defaults. Είναι μετά όμως σε σας το αν θα αναθέσετε στις συσκευές σας το management interface να είναι σε απομονωμένο δίκτυο (π.χ. ξεχωριστό VRF) ή θα το βάλετε να συμμετέχει στην τοπολογία. Είναι δηλαδή θέμα configuration.
Καλό θα είναι εδώ να θυμηθείτε ότι ενδεχομένως να χρειάζεστε κάποια επαφή με το δίκτυο ή το internet για compute nodes στο lab σας, π.χ. server / desktop nodes, για software updates ή installations.
Στην περίπτωση άλλων simulation platforms όπως το EVE-NG, το isolation είναι το default. Η πλατφόρμα ορίζει με κάποιο τρόπο το port forwarding και έχετε την επιλογή να ορίσετε εξωτερικές εφαρμογές για το management (π.χ. virtual terminal sorftware όπως το putty, original ή solarwinds version) ή να έχετε html based περιβάλλον όπου τα terminals γίνονται launch εσωτερικά στο browser ως guacaomole (από το Apache foundation) instances.
Αν ανησυχείτε είτε για την ασφάλεια είτε για το impact του να συνδεθεί το δίκτυο αλλού ή απλά θέλετε να δοκιμάσετε addressing που έχει conflicts με το πραγματικό δίκτυο (π.χ. μπορεί να είναι lab version ενός πραγματικού δικτύου) χωρίς να θέλετε να στήσετε NAT, αυτή η επιλογή ίσως σας ταιριάζει.</p>
<h2 id="πρόσβαση---mixed-environments">Πρόσβαση - mixed environments</h2>
<p>Μπορούμε σε πολλές περιπτώσεις simulators να έχουμε full bridged envioronments στο πραγματικό δίκτυο. Στο containerlab είναι θέμα configuration, σε άλλες πλατφόρμες όπως το EVE-NG είναι τόσο απλό όσο το να δώσετε links προς ένα cloud network type το οποίο είναι bridged στο πραγματικό δίκτυο μέσω της σύνδεσης του EVE-NG host. Προσοχή όταν συνδέετε network devices σε αυτό όπως Cisco routers όπου το CDP είναι ενεργοποιημένο εξαρχής. Θα αρχίσετε να βλέπετε τις συσκευές σας από τις υπόλοιπες με CDP επειδή θα &ldquo;βλέπουν&rdquo; η μία την άλλη μέσω του bridged network (και ίσως και καμιά πραγματική συσκευή, π.χ. το gateway στο εταιρικό σας δίκτυο).
Καλό θα είναι σε τέτοιες περιπτωσεις να απενεργοποιείτε κάποια features σε τέτοια interfaces όπως και μάλλον θα χρειαστεί να κάνετε κι άλλα πράγματα σχετικά με τα boot processes κλπ (ας μην μπούμε σε λεπτομέρειες, θα το καταλάβετε αφού δημιουργήσετε ορισμένα nodes και τα ξεκινήσετε).
Στο σχήμα αυτό μπορεί κανείς να κάνει μίξη simulated nodes με physical nodes ή ακόμα και simulated nodes που βρίσκονται σε διαφορετικά hosts (χωρίς να πάμε στην ακραία περίπτωση του clabernetes όπου μιλάμε για ένα overlay δίκτυο across hosts).
Αν στην περίτπωση σας χρησιμοποιείτε Vmware Workstation και το &ldquo;physical node&rdquo; είναι το λειτουργικό σύστημα στο laptop σας (π.χ. θέλετε να μιλήσετε από τo vs-code στο laptop σας σε node μέσα στο lab ή και να αντιγράψετε αρχεία), και αντιμετωπίζετε προβλήματα στη σύνδεση, φροντίστε να συνδέσετε το laptop στο σταθερό δίκτυο με καλώδιο. Θα λύσει το πρόβλημα.</p>
<h2 id="hybrid---management-on-bridged">Hybrid - Management on bridged</h2>
<p>Μπορείτε να έχετε μόνο το management δίκτυο στο bridged network και τα υπόλοιπα να είναι απομονωμένα. Πρακτικά αυτό είναι θέμα design σε όλες τις περιπτώσεις. Είναι σαν ένα Out of Band Management Network για physical devices αλλά αντί για physical devices έχετε ένα simulator host και simulated network nodes. Είναι ίσως best of both worlds σε σχέση με τα παραπάνω αλλά και πάλι εξαρτάται από την εφαρμογή/use case.</p>
<h1 id="χρήσεις">Χρήσεις</h1>
<h2 id="εκμάθηση-περιβάλλοντος-cli">Εκμάθηση περιβάλλοντος (CLI)</h2>
<h2 id="network-design-and-configuration">Network design and configuration</h2>
<h2 id="simple-network-test-scenarios">Simple Network Test Scenarios</h2>
<h2 id="network-automation-testing">Network Automation Testing</h2>
<h2 id="digital-twin-testing">Digital Twin Testing</h2>
<h1 id="χρήσιμοι-σύνδεσμοι">Χρήσιμοι σύνδεσμοι</h1>
]]></content>
        </item>
        
        <item>
            <title>Introduction to PyATS</title>
            <link>https://netautogr.github.io/posts/2021/12/introduction-to-pyats/</link>
            <pubDate>Sat, 18 Dec 2021 00:55:02 +0200</pubDate>
            
            <guid>https://netautogr.github.io/posts/2021/12/introduction-to-pyats/</guid>
            <description>Εισαγωγή Το PyATS είναι ένα software framework για την κατασκευή αυτόματων διαδικασιών ελέγχου για δικτυακές συσκευές, ή όπως λέει η Cisco, ένα ολοκληρωμένο οικοσύστημα αυτοματισμού και δοκιμών, προσφέροντας όλα τα εργαλεία για τις καθημερινές DevOps εργασίες των μηχανικών δικτύων, δίνοντας εργαλεία είτε για τη γραμμή εντολών, είτε με τη χρήση libraries, είτε μέσω ενός σύγχρονου GUI Dashboard.
Είναι εσωτερικό εργαλείο της Cisco εδώ και 10 χρόνια (2012) για την δοκιμή των προϊόντων και συστημάτων τους, το οποίο αποφάσισαν να διαθέσουν στο ευρύ κοινό από το 2017.</description>
            <content type="html"><![CDATA[<h1 id="εισαγωγή">Εισαγωγή</h1>
<p>Το PyATS είναι ένα software framework για την κατασκευή αυτόματων διαδικασιών ελέγχου για δικτυακές συσκευές, ή όπως λέει η Cisco, ένα ολοκληρωμένο οικοσύστημα αυτοματισμού και δοκιμών, προσφέροντας όλα τα εργαλεία για τις καθημερινές DevOps εργασίες των μηχανικών δικτύων, δίνοντας εργαλεία είτε για τη γραμμή εντολών, είτε με τη χρήση libraries, είτε μέσω ενός σύγχρονου GUI Dashboard.</p>
<p>Είναι εσωτερικό εργαλείο της Cisco εδώ και 10 χρόνια (2012) για την δοκιμή των προϊόντων και συστημάτων τους, το οποίο αποφάσισαν να διαθέσουν στο ευρύ κοινό από το 2017. Είναι φτιαγμένο σε Python και αποτελείται από διάφορα layers, τα οποία μπορούν να λειτουργούν είτε σε συνδυασμό είτε ανεξάρτητα.</p>
<p>Στο παρόν post θα εξηγήσουμε σύντομα τί είναι το PyATS και από τί αποτελείται, ποιοι είναι οι βασικοί τρόποι χρήσης του και θα σας δώσουμε κατευθύνσεις για το που μπορείτε να μάθετε περισσότερα.
Το πρώτο που πρέπει να αναφέρουμε, είναι: προσοχή πως θα το προφέρετε:
<img src="https://storage.googleapis.com/blogs-images/ciscoblogs/1/2021/04/Vanilla-ISE-blog-3-pic1.jpg" alt="PyATS Pronounciation"></p>
<p>Δεν μπορώ όμως να σκεφτώ καλύτερη εισαγωγή από την παρουσίαση του μέχρι πρότινος PyATS team leader, Siming Yuan:
<a href="https://youtu.be/aMoXuXWohTA"><img src="https://img.youtube.com/vi/aMoXuXWohTA/maxresdefault.jpg" alt="Network Assurance: pyATS / Genie for Network Engineers"></a></p>
<p>Εδώ σχετικό post του στο Cisco Developer Blog - <a href="https://blogs.cisco.com/developer/pyats-genie-transform">https://blogs.cisco.com/developer/pyats-genie-transform</a></p>
<p>Κι εδώ το Getting Started από το Devnet Documentation - <a href="https://developer.cisco.com/docs/pyats-getting-started/">https://developer.cisco.com/docs/pyats-getting-started/</a></p>
<p>Η ομάδα του Cisco PyATS αποτελείται από εξαιρετικούς μηχανικούς οι οποίοι είναι πάντα πρόθυμοι να προσφέρουν βοήθεια αρκεί να τους στείλετε ένα email στο <a href="mailto:pyats-support-ext@cisco.com">pyats-support-ext@cisco.com</a>
Επίσης, μπορείτε να κάνετε join στο σχετικό webex channel εδώ: <a href="https://eurl.io/#r18UzrQVr">https://eurl.io/#r18UzrQVr</a> ή να το βρείτε από τη λίστα εδώ: <a href="https://eurl.io/">https://eurl.io/</a></p>
<h1 id="framework-layers">Framework Layers</h1>
<p>Όπως αναφέραμε το PyATS αποτελείται από πολλά κομμάτια τα οποία μπορείτε να θεωρήσετε πως λειτουργούν σε ανεξάρτητα στρώματα, όπως παρακάτω:
<img src="https://pubhub.devnetcloud.com/media/pyats-genie-docs/docs/imgs/layers.png#developer.cisco.com" alt="PyATS Layers"></p>
<p>Τα βασικά layers λοιπόν είναι:</p>
<ul>
<li>PyATS Core Toolbox</li>
<li>PyATS SDK (π.χ. <a href="https://developer.cisco.com/docs/genie-docs/">Genie</a>)</li>
<li>Business Logic Tools</li>
</ul>
<p>Μπορείτε να χρησιμοποιήσετε μόνο το core toolbox, ή τα libraries ή όλα μαζί με το business logic, είτε από τη γραμμή εντολής (Genie CLI), είτε μέσω CI/CD pipelines είτε φτιάχνοντας τη δική σας business logic ενσωματώνοντας όλα σε python scripts.</p>
<p>Πως να το εγκαταστήσετε:</p>
<ul>
<li><a href="https://pubhub.devnetcloud.com/media/pyats-getting-started/docs/install/installpyATS.html">https://pubhub.devnetcloud.com/media/pyats-getting-started/docs/install/installpyATS.html</a></li>
</ul>
<p>To PyATS είναι διαθέσιμο:</p>
<ul>
<li>Ως python package - <a href="https://pypi.org/project/pyats/">https://pypi.org/project/pyats/</a></li>
<li>Σε διάφορα flavors από docker containers - <a href="https://hub.docker.com/r/ciscotestautomation/pyats/">https://hub.docker.com/r/ciscotestautomation/pyats/</a></li>
<li>Ως ολοκληρωμένο πακέτο με GUI - Xpresso</li>
</ul>
<p>Μπορείτε να τρέξετε το python package σε Linux &amp; Mac αλλά όχι σε Windows. Αν θέλετε να τρέξετε το PyATS σε Windows, θα πρέπει να χρησιμοποιήσετε το WSL (Windows Subsystem for Linux) ή να το τρέξετε μέσω Docker (τότε όμως στην ουσία δεν το τρέχετε σε Windows).</p>
<h1 id="pyats-features">PyATS Features</h1>
<h2 id="γενικά">Γενικά</h2>
<p>Τα features του PyATS είναι πραγματικά ατελείωτα. Αξίζει να επενδύσει κανείς χρόνο για να τα εντάξει ως &ldquo;βέλη&rdquo; στη &ldquo;φαρέτρα&rdquo; του.</p>
<h2 id="platform-agnostic-models">Platform Agnostic Models</h2>
<p>Οι μηχανικοί του PyATS έχουν κατασκευάσει μοντέλα δεδομένων για τις δικτυακές συσκευές που δεν είναι δεμένα με συγκεκριμενους κατασκευαστές και μοντέλα και μόνο. Π.χ. το ospf routing model δεν είναι ειδικά για Cisco ή Juniper κλπ.
Έτσι μπορείτε να χρησιμοποιήσετε το PyATS με εξοπλισμό που δεν είναι cisco, ακόμα και linux hosts.</p>
<p>Ωστόσο για να μπορέσετε να κάνετε interface με τις συσκευές και να αλληλεπιδράσετε μαζί τους και με τα μοντέλα, χρειάζεται να υπάρχει και το ενδιάμεσο layer που μιλάει με τις συσκευές. Αυτό πρέπει είτε να είναι ήδη διαθέσιμο (parse, learn, config) ή μπορείτε να το κατασκευάσετε!</p>
<h2 id="device-connection">Device connection</h2>
<p>To PyATS χρησιμοποιεί το Unicon library (<a href="https://developer.cisco.com/docs/unicon/">https://developer.cisco.com/docs/unicon/</a>) για να &ldquo;μιλήσει&rdquo; με τις συσκευές μέσω SSH &amp; Telnet. Μπορείτε να καθορίσετε τις παραμέτρους σύνδεσης ανάλογα με το τί υποστηρίζεται από τις συσκευές.</p>
<p>Η σύνδεση προς τις συσκευές γίνεται σειριακά, αλλά μπορεί να γίνει και παράλληλα υπό προϋποθέσεις (pyats pcall - <a href="https://pubhub.devnetcloud.com/media/pyats/docs/async/pcall.html">https://pubhub.devnetcloud.com/media/pyats/docs/async/pcall.html</a>) για γρηγορότερη εκτέλεση και λήψη αποτελεσμάτων.</p>
<h2 id="device-inventory---testbed">Device Inventory - Testbed</h2>
<p>Το PyATS χρησιμοποιεί μια δομή που ονομάζει testbed για την καταχώρηση των συσκευών, η οποία εφόσον φορτωθεί από αρχείο, πρέπει να είναι YAML αρχείο (.yml) με συγκεκριμένη δομή <a href="https://pubhub.devnetcloud.com/media/pyats/docs/topology/creation.html">https://pubhub.devnetcloud.com/media/pyats/docs/topology/creation.html</a></p>
<p><img src="https://storage.googleapis.com/blogs-images/ciscoblogs/1/5ced7e47b3b53.png" alt="PyATS Testbed Yaml"></p>
<p>Εναλλακτικά μπορείτε είτε να παράγετε το testbed μόνο απαντώντας με ερωτήσεις στο cli ή από ένα αρχείο excel ή ακόμα και δυναμικά στη μνήμη μέσω python. Υπάρχουν κι άλλες δυνατότητες εισάγοντας δεδομένα από άλλα εργαλεία ή frameworks.</p>
<p>Δείτε ένα παράδειγμα κατασκευής pyats testbed σε αρχείο διαβάζοντας δεδομένα από το Cisco Prime Infrastructure εδώ:
<a href="https://github.com/itheodoridis/itheodoridis-createtestbedsfromPI">https://github.com/itheodoridis/itheodoridis-createtestbedsfromPI</a></p>
<p>Φυσικά ένα testbed είναι κάτι περισσότερο από ένα κατάλογο συσκευών. Μπορεί να ορίζει ένα πλήρες network topology:</p>
<ul>
<li><a href="https://pubhub.devnetcloud.com/media/pyats/docs/topology/index.html">https://pubhub.devnetcloud.com/media/pyats/docs/topology/index.html</a></li>
</ul>
<h2 id="genie-cli-vs-python-library">Genie CLI vs Python Library</h2>
<p>Μπορείτε να εκτελέσετε τις λειτουργίες που υποστηρίζει το PyATS είτε μέσω CLI (περιορισμένες λειτουργίες, π.χ. genie parse, genie learn, genie diff) είτε μέσω python, όπου μπορείτε να σχηματίσετε τη δική σας λογική και να ελέγξετε απόλυτα την εισαγωγή και εξαγωγή δεδομένων.</p>
<p>Στην περίπτωση χρήσης του Genie CLI, τα αποτελέσματα αποθηκεύονται ως αρχεία κειμένου στο δίσκο σε ξεχωριστά directories (ορίζονται κατά την εκτέλεση).</p>
<p>Μπορείτε να χρησιμοποιήσετε το ίδιο directory εκτελώντας πολλαπλές λειτουργίες για όλα τα devices, όπου θα αποθηκεύονται δύο αρχεία ανά συσκευή και λειτουργία, ένα δομημένο και ένα με την raw μορφή που θα τα παίρνατε από τη γραμμή εντολής αν είχατε συνδεθεί οι ίδιοι στη συσκευή και είχατε εκτελέσει τις συγκεκριμένες λειτουργίες.</p>
<ul>
<li>Για να δείτε συνολικά τις επιλογές που έχετε για το Genie CLI δείτε εδώ: <a href="https://pubhub.devnetcloud.com/media/genie-docs/docs/cli/index.html">https://pubhub.devnetcloud.com/media/genie-docs/docs/cli/index.html</a></li>
<li>Αν θέλετε να δείτε τις δυνατότητες που έχετε για να χρησιμοποιήσετε το PyATS γενικότερα μέσω CLI δείτε εδώ: <a href="https://pubhub.devnetcloud.com/media/pyats/docs/cli/index.html">https://pubhub.devnetcloud.com/media/pyats/docs/cli/index.html</a></li>
</ul>
<h2 id="genie-parse--parsers">Genie Parse &amp; Parsers</h2>
<p>Με το Genie μπορείτε να εκτελέσετε εντολές συλλογής δεδομένων στις δικτυακές συσκευές (π.χ. Cisco show commands) και να επεξεργαστείτε τα δεδεμένα που επιστρέφονται, ώστε να προκύψουν συγκεκριμένες δομές που μπορείτε να αξιοποιήσετε για να παράγετε αυτοματοποιημένη λογική ή να τα επεξεργαστείτε περαιτέρω.</p>
<p>Οι Genie parsers ερμηνεύουν αυτά τα δεδομένα και απομονώνουν τα πεδία δεδομένων σε αυτά, ενώ τα επιστρέφουν πίσω σε δομημένη μορφή (multi-level dictionaries, αν χρησιμοποιείτε python).</p>
<ul>
<li><a href="https://developer.cisco.com/docs/pyats/#!parsing-device-output">https://developer.cisco.com/docs/pyats/#!parsing-device-output</a></li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># using Python</span>
bash<span style="color:#960050;background-color:#1e0010">$</span> pyats shell <span style="color:#f92672">--</span>testbed<span style="color:#f92672">-</span>file testbed<span style="color:#f92672">.</span>yaml
<span style="color:#f92672">&gt;&gt;&gt;</span> testbed<span style="color:#f92672">.</span>devices[<span style="color:#e6db74">&#39;nx-osv-1&#39;</span>]<span style="color:#f92672">.</span>connect()
<span style="color:#f92672">&gt;&gt;&gt;</span> output <span style="color:#f92672">=</span> testbed<span style="color:#f92672">.</span>devices[<span style="color:#e6db74">&#39;nx-osv-1&#39;</span>]<span style="color:#f92672">.</span>parse(<span style="color:#e6db74">&#39;show interfaces&#39;</span>)
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># using CLI</span> 
bash$ pyats parse <span style="color:#e6db74">&#34;show interfaces&#34;</span> --testbed-file testbed.yaml
</code></pre></div><p><a href="https://youtu.be/zjzqJEeEX60"><img src="https://img.youtube.com/vi/zjzqJEeEX60/maxresdefault.jpg" alt="Python Parsing with pyATS | Genie - Cisco Automation Made Easy"></a></p>
<p>Μπορείτε να δείτε ποιοι είναι διαθέσιμοι parsers μέχρι στιγμής στο παρακάτω link:
<a href="https://pubhub.devnetcloud.com/media/genie-feature-browser/docs/#/parsers">https://pubhub.devnetcloud.com/media/genie-feature-browser/docs/#/parsers</a></p>
<p>Μπορείτε επίσης να κατασκευάσετε τους δικούς σας, δείτε τα παρακάτω δύο videos:</p>
<ul>
<li>How to write a Genie parser for Cisco! by Juhi Mahajan - <a href="https://www.youtube.com/watch?v=ibLNilSfdTc">https://www.youtube.com/watch?v=ibLNilSfdTc</a></li>
</ul>
<p><a href="https://youtu.be/ibLNilSfdTc"><img src="https://img.youtube.com/vi/ibLNilSfdTc/maxresdefault.jpg" alt="How to write a Genie parser"></a></p>
<ul>
<li>Creating a pyATS | Genie Parser from SCRATCH by Knoxx Hutchinson - <a href="https://www.youtube.com/watch?v=knxkbWTamBY">https://www.youtube.com/watch?v=knxkbWTamBY</a></li>
</ul>
<p><a href="https://youtu.be/knxkbWTamBY"><img src="https://img.youtube.com/vi/knxkbWTamBY/maxresdefault.jpg" alt="Creating a pyATS Genie Parser from SCRATCH"></a></p>
<p>Μπορείτε βέβαια να ακολουθήσετε και το επίσημο documentation που περιέχει αρκετά στοιχεία σε γραπτή μορφή για το πως να μάθετε να το κάνετε:
<a href="https://pubhub.devnetcloud.com/media/pyats-development-guide/docs/writeparser/writeparser.html">https://pubhub.devnetcloud.com/media/pyats-development-guide/docs/writeparser/writeparser.html</a></p>
<h2 id="genie-learn--models">Genie Learn &amp; Models</h2>
<p>Eίτε εκτελείτε το genie learn μέσω cli, είτε μαζεύετε τα στοιχεία μέσω python, στην ουσία συλλέγετε δεδομένα αντίστοιχα με τα μοντέλα που έχει κατασκευάσει η ομάδα του PyATS. Πρακτικά είναι σαν να τρέχετε πολλές εντολές μαζί, οι οποίες συμπληρώνουν την εικόνα.</p>
<p>Μπορείτε να δείτε τα διαθέσιμα μοντέλα στο link <a href="https://pubhub.devnetcloud.com/media/genie-feature-browser/docs/#/models">https://pubhub.devnetcloud.com/media/genie-feature-browser/docs/#/models</a></p>
<h2 id="genie-conf">Genie Conf</h2>
<p>Μπορείτε να δώσετε εντολές ρυθμίσεων προς συσκευές με το PyATS (αντίστοιχα με τα Cisco configuration commands). Αυτό έχει μεγαλύτερο νόημα μέσω Python. Μπορείτε αυτό να το κάνετε είτε αυτόνομα για να περάσετε configuration στις συσκευές με δομημένο τρόπο ή ακόμα και να κάνετε μικρές αλλαγές στο δίκτυο ώστε να προκαλέσετε μικρά failures και να ελέγξετε πως ανταποκρίνεται στα πλαίσια PyATS triggers/test cases.</p>
<p><a href="https://pubhub.devnetcloud.com/media/genie-docs/docs/cookbooks/conf.html">Genie Conf Documentation</a></p>
<h2 id="genie-diff">Genie Diff</h2>
<p>Είτε έχετε εκτελέσει εντολές Genie Parse/Learn μέσω CLI είτε μέσω Python, μπορείτε να χρησιμοποιήσετε το PyATS για να εντοπίσετε διαφορές μεταξύ δύο διαφορετικών καταστάσεων του δικτύου. Π.χ. πριν και μετά από μια μεγάλη αλλαγή. Στην περίπτωση αυτή το PyATS επεξεργάζεται τα δεδομένα με αστραπιαία ταχύτητα και παράγει τα αποτελέσματα εντοπίζοντας και την παραμικρή διαφορά, είτε είναι κάτι που αναμένατε είτε όχι. Προφανώς αυτό εξαρτάται από τις εντολές που επιλέξατε να τρέξετε (parse) ή τα μοντέλα που επιλέξατε να μάθετε (learn).</p>
<p><img src="https://storage.googleapis.com/blogs-images/ciscoblogs/1/5ced7f6ca9253-768x163.png" alt="Genie Diff"></p>
<p>Το εξαιρετικό genie diff βρίσκει όλες τις διαφορές μεταξύ των αντίστοιχων outputs στα δύο directories που αντιστοιχούν στις δύο καταστάσεις για το πριν και το μετά και δέχεται ότι εξαιρέσεις θέλει κανείς, π.χ. αν δεν ενδιαφέρουν interface counters για packets, bytes, κλπ.</p>
<p><img src="https://storage.googleapis.com/blogs-images/ciscoblogs/1/5ced80294050e-768x192.png" alt="Genie Diff Output"></p>
<p>Αν θέλετε να δείτε το σχετικό documentation για CLI δείτε εδώ: <a href="https://pubhub.devnetcloud.com/media/genie-docs/docs/cli/genie_diff.html">https://pubhub.devnetcloud.com/media/genie-docs/docs/cli/genie_diff.html</a></p>
<p>Αν θέλετε να διαβάσετε για μια περίπτωση χρήσης αυτού και μόνο του feature (CLI/Python) μπορείτε να διαβάσετε το παρακάτω άρθρο ή να ρίξετε μια ματιά στο παρακάτω git repo.</p>
<ul>
<li><a href="https://blogs.cisco.com/developer/datacenter-core-migration">https://blogs.cisco.com/developer/datacenter-core-migration</a></li>
<li><a href="https://github.com/itheodoridis/check-config-changes">https://github.com/itheodoridis/check-config-changes</a></li>
</ul>
<h2 id="testing-cases">Testing (Cases)</h2>
<p>Αυτό είναι ίσως το πιο ουσιαστικό κομμάτι της χρήσης του PyATS, παρότι κανείς δεν μπορεί να σας πει τί μπορεί να είναι χρήσιμο για σας από ένα εργαλείο.</p>
<p>Μπορείτε να ορίσετε σετ από δοκιμές που που πρέπει να γίνουν ορίζοντας ένα σενάριο, είτε για μεμονωμένες συσκευές είτε για ολόκληρο το δίκτυο (testbed), ώστε να δώσετε αναφορές για το αν ανταποκρίνεται σε αλλαγές σύμφωνα με το αναμενόμενο ή όχι, ορίζοντας οι ίδιοι τί αντιστοιχεί σε επιτυχία (pass) ή αποτυχία (failure).</p>
<p><img src="https://pubhub.devnetcloud.com/media/pyats/docs/_images/script_structure.png" alt="Script Structure"></p>
<p>Μπορεί κάποιος να κάνει script απίθανα πράγματα για να κάνει δοκιμές. Π.χ. έστησα το δίκτυο μου ρίχνω ένα λινκ, πως συμπεριφέρεται το routing; Πόσοι neighbors υπάρχουν; Υπάρχει το τάδε route; Φτιάχνεις τα test σου, τρέχεις το script και βλέπεις που έχεις pass ή fail σε ωραία reports.</p>
<p>Μπορείτε να χρησιμοποιήσετε έτοιμα ήδη δημιουργημένα tests, γνωστά ως triggers.</p>
<ul>
<li>Εδώ μπορείτε να βρείτε τη λίστα με τα ήδη διαθέσιμα triggers - <a href="https://pubhub.devnetcloud.com/media/genie-feature-browser/docs/#/triggers">https://pubhub.devnetcloud.com/media/genie-feature-browser/docs/#/triggers</a></li>
<li>Εδώ μπορείτε να βρείτε πως να φτιάξετε δικά σας - <a href="https://pubhub.devnetcloud.com/media/pyats-development-guide/docs/writetrigger/writetrigger.html">https://pubhub.devnetcloud.com/media/pyats-development-guide/docs/writetrigger/writetrigger.html</a></li>
<li>Εδώ μπορείτε να δείτε πως να τα εκτελέσετε -  <a href="https://pubhub.devnetcloud.com/media/pyats-getting-started/docs/quickstart/runtestcase.html#run-a-test-case">https://pubhub.devnetcloud.com/media/pyats-getting-started/docs/quickstart/runtestcase.html#run-a-test-case</a></li>
<li>Τα triggers ελέγχονται με verifications.
<ul>
<li>Εδώ είναι μια λίστα με τα έτοιμα verifications - <a href="https://pubhub.devnetcloud.com/media/genie-feature-browser/docs/#/verifications">https://pubhub.devnetcloud.com/media/genie-feature-browser/docs/#/verifications</a></li>
<li>Εδώ είναι ένα παράδειγμα για triggers &amp; verifications - <a href="https://pubhub.devnetcloud.com/media/pyats-development-guide/docs/writetrigger/writetrigger.html#example-of-a-trigger-with-verifications">https://pubhub.devnetcloud.com/media/pyats-development-guide/docs/writetrigger/writetrigger.html#example-of-a-trigger-with-verifications</a></li>
</ul>
</li>
</ul>
<p>Μπορείτε όμως να ορίσετε τα test σας και ως test cases, δηλαδή συλλογές από μικρότερα tests:</p>
<ul>
<li>Δείτε εδώ σχετικό documentation - <a href="https://pubhub.devnetcloud.com/media/pyats/docs/aetest/structure.html#testcases">https://pubhub.devnetcloud.com/media/pyats/docs/aetest/structure.html#testcases</a></li>
<li>Video από το PyCon 2020 με τον Hank Preston - <a href="https://www.conferencecast.tv/talk-33233-introduction-to-writing-network-tests-with-pyats#.talkPage-header">https://www.conferencecast.tv/talk-33233-introduction-to-writing-network-tests-with-pyats#.talkPage-header</a></li>
<li>Slide Deck από Cisco Live 2018 Barcelona - <a href="https://www.ciscolive.com/c/dam/r/ciscolive/emea/docs/2018/pdf/DEVNET-1480.pdf">https://www.ciscolive.com/c/dam/r/ciscolive/emea/docs/2018/pdf/DEVNET-1480.pdf</a></li>
</ul>
<p>Μην ξεχνάτε ότι μπορείτε να πάρετε τα αποτελέσματα</p>
<ul>
<li>είτε ως αντικείμενα (python, <a href="https://pubhub.devnetcloud.com/media/pyats/docs/results/objects.html),">https://pubhub.devnetcloud.com/media/pyats/docs/results/objects.html),</a></li>
<li>είτε μέσω του logging (<a href="https://pubhub.devnetcloud.com/media/pyats/docs/cli/pyats_logs.html#pyats-logs),">https://pubhub.devnetcloud.com/media/pyats/docs/cli/pyats_logs.html#pyats-logs),</a></li>
<li>είτε ως αρχεία yaml (<a href="https://pubhub.devnetcloud.com/media/pyats/docs/reporter/overview.html),">https://pubhub.devnetcloud.com/media/pyats/docs/reporter/overview.html),</a></li>
<li>είτε ως html reports στο Xpresso.</li>
</ul>
<p>Αν θέλετε όμως μπορείτε να ακολουθήσετε και τη δομή που περιέγραψε ο Julio Gomez (Cisco Developer Lead EMEAR) σε πέντε post από την καταπληκτική σειρά του για το DevOps:</p>
<ul>
<li><a href="https://blogs.cisco.com/developer/pyats-demo-netdevops-12">PyATS Introduction and Setup</a></li>
<li><a href="https://blogs.cisco.com/developer/pyats-demos-get-started-netdevops-13">Getting Started</a></li>
<li><a href="https://blogs.cisco.com/developer/pyats-demo-interactive-tests-netdevops-14">Interactive Tests</a></li>
<li><a href="https://blogs.cisco.com/developer/pyats-network-profiling-15">Network Profiling</a></li>
<li><a href="https://blogs.cisco.com/developer/pyats-test-cases-16">Test Cases</a></li>
</ul>
<h2 id="pyats-logger">PyATS Logger</h2>
<p>Μπορείτε να οδηγήσετε το logging στα pyats tests/cases μέσω python, αλλά υπάρχει η δυνατότητα να το κάνετε και μέσω CLI, μέσω του PyATS log viewer <a href="https://pubhub.devnetcloud.com/media/pyats/docs/cli/pyats_logs.html">https://pubhub.devnetcloud.com/media/pyats/docs/cli/pyats_logs.html</a></p>
<p>Αν τρέχετε το pyats σε Linux Desktop που διαθέτει GUI μπορείτε να προβάλλετε το log σε μορφή HTML σε browser.
Όμως είναι πλέον δυνατό το PyATS να σηκώσει ένα webserver όπου μπορείτε να δείτε το Log.
Φυσικά αν τρέχετε Xpresso, όλα αυτά είναι πιο εύκολα.</p>
<p><img src="https://pubhub.devnetcloud.com/media/pyats/docs/_images/logs_webpage_example.png" alt="PyATS LogView"></p>
<p>Δείτε γενικότερα για το logging στο PyATS εδώ: <a href="https://pubhub.devnetcloud.com/media/pyats/docs/log/index.html">https://pubhub.devnetcloud.com/media/pyats/docs/log/index.html</a></p>
<h2 id="xpresso">Xpresso</h2>
<p>To Xpresso είναι ένα ολοκληρωμένο γραφικό περιβάλλον βασισμένο σε web για τη χρήση του PyATS και τη δημιουργία HTML reports. Έχει πάρα πολλά χαρακτηριστικά και δυνατότητες, ξεφεύγει κατά πολύ από ένα απλό πακέτο λογισμικού.</p>
<p>Δείτε εδώ για ένα overview <a href="https://developer.cisco.com/docs/xpresso/#!overview">https://developer.cisco.com/docs/xpresso/#!overview</a>
Μπορείτε να το εγκαταστήσετε είτε ως συλλογή πακέτων λογισμικού είτε μέσω docker</p>
<ul>
<li><a href="https://developer.cisco.com/docs/xpresso/#!setting-up-your-test-environment-overview/setting-up-your-test-environment">https://developer.cisco.com/docs/xpresso/#!setting-up-your-test-environment-overview/setting-up-your-test-environment</a></li>
<li><a href="https://github.com/CiscoTestAutomation/xpresso">https://github.com/CiscoTestAutomation/xpresso</a></li>
<li><a href="https://developer.cisco.com/docs/xpresso/#docker-images">https://developer.cisco.com/docs/xpresso/#docker-images</a></li>
</ul>
<p>Έχει σημαντικές απαιτήσεις σε πόρους (σε αντίθεση με το απλό pyats), οπότε φροντίστε να έχετε αρκετούς αν σκοπεύετε να το τρέξετε:</p>
<p><a href="https://developer.cisco.com/docs/xpresso/#!operational-requirements-constraints/operational-requirements-and-constraints">Operational Requirements and Constraints</a></p>
<h2 id="mock-devices">Mock devices</h2>
<p>Τα Mock Devices δεν είναι πραγματικά devices αλλά pre-recorded sets από commands &amp; responses. Βασίζονται στο playback feature του Unicon library και δίνουν τη δυνατότητα να κάνει κάποιος practice με το PyATS χωρίς να έχει κανονικές συσκευές στη διάθεση του, άλλωστε το PyATS tutorial χρησιμοποιεί mock device:</p>
<ul>
<li>Tutorial : <a href="https://pubhub.devnetcloud.com/media/pyats-getting-started/docs/quickstart/manageconnections.html?highlight=mocking#connect-to-devices">https://pubhub.devnetcloud.com/media/pyats-getting-started/docs/quickstart/manageconnections.html?highlight=mocking#connect-to-devices</a></li>
</ul>
<p>To documentation για το πως δουλεύει το playback στο Unicon μπορείτε να το δείτε εδώ:</p>
<ul>
<li>Create a mock device - <a href="https://pubhub.devnetcloud.com/media/unicon/docs/developer_guide/unittests.html#mock">https://pubhub.devnetcloud.com/media/unicon/docs/developer_guide/unittests.html#mock</a></li>
<li>Playback - <a href="https://pubhub.devnetcloud.com/media/unicon/docs/playback/index.html#">https://pubhub.devnetcloud.com/media/unicon/docs/playback/index.html#</a></li>
</ul>
<p>Αν θέλετε μπορείτε να δείτε κι αυτό το άρθρο από τον Gary Woodward:</p>
<ul>
<li><a href="https://bitesizeautomation429301704.wordpress.com/2020/09/18/mocking-your-devices/amp/?__twitter_impression=true">Mocking your devices</a></li>
</ul>
<h2 id="parsing-for-other-python-libraries-netmiko-scrapli-ansible">Parsing for other python libraries (Netmiko, Scrapli, Ansible)</h2>
<h3 id="netmiko">Netmiko</h3>
<p>To γνωστό Python library του Kirk Byers προβλέπει τη χρήση network parsers για να παίρνει κανείς δεδομένα από τα sessions με τα network devices με δομημένο τρόπο. Όπως υποστηρίζεται το <a href="https://pynet.twb-tech.com/blog/automation/netmiko-textfsm.html">Text-FSM</a> (<em>NTC-Templates</em>), υποστηρίζονται οι genie parsers με το option <em><strong>use_genie = True</strong></em>.
Μπορείτε να διαβάσετε περισσότερα εδώ:</p>
<ul>
<li>Παράδειγμα - <a href="https://github.com/ktbyers/netmiko/blob/develop/EXAMPLES.md#using-genie">https://github.com/ktbyers/netmiko/blob/develop/EXAMPLES.md#using-genie</a></li>
<li>Documentation - <a href="https://ktbyers.github.io/netmiko/docs/netmiko/index.html#netmiko.BaseConnection.send_command">https://ktbyers.github.io/netmiko/docs/netmiko/index.html#netmiko.BaseConnection.send_command</a></li>
<li>Post - <a href="https://networkautomationlane.in/how-to-install-and-parse-data-with-netmiko-genie-plugin/">https://networkautomationlane.in/how-to-install-and-parse-data-with-netmiko-genie-plugin/</a></li>
</ul>
<h3 id="scrapli">Scrapli</h3>
<p>Με το Scrapli τo parsing των device responses γίνεται σε δεύτερο χρόνο. Η διαφορά είναι μικρή στην ουσία. Μπορείτε να διαβάσετε περισσότερα εδώ:</p>
<ul>
<li><a href="https://carlmontanari.github.io/scrapli/user_guide/basic_usage/#cisco-genie-integration">https://carlmontanari.github.io/scrapli/user_guide/basic_usage/#cisco-genie-integration</a></li>
<li><a href="https://0x2142.com/automating-the-cli-using-scrapli/">https://0x2142.com/automating-the-cli-using-scrapli/</a></li>
</ul>
<h3 id="ansible">Ansible</h3>
<p>To Ansible extension για να μπορεί κανείς να χρησιμοποιήσει το PyATS με το Ansible το έχει δημιουργήσει ο Clay Curtis. Περισσότερα μπορείτε να διαβάσετε εδώ:</p>
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#parsing-with-pyats">https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#parsing-with-pyats</a></li>
</ul>
<h2 id="pyats-libraries-dq-clean">PyATS Libraries (Dq, Clean)</h2>
<p>Δεν σταματάνε όμως εδώ τα features του PyATS. Παρακάτω αναφέρονται δύο εξαιρετικά χρήσιμα από αυτά, τα οποία μπορούν να χρησιμοποιηθούν μαζί με το PyATS ή ξεχωριστά.
Γενικά για τα χρήσιμα libraries του PyATS/Genie: <a href="https://pubhub.devnetcloud.com/media/genie-docs/docs/userguide/utils/index.html">https://pubhub.devnetcloud.com/media/genie-docs/docs/userguide/utils/index.html</a></p>
<h3 id="dq">Dq</h3>
<p>To Dq είναι βιβλιοθήκη που βοηθάει στον εντοπισμό δεδομένων σε μια εμφωλευμένη δομή χωρίς κάποιος να χρειάζεται να ξέρει ακριβώς όλη τη δομή που πρέπει να &ldquo;διασχίσει&rdquo; μέχρι να φτάσει στο dictionary που τον ενδιαφέρει.</p>
<ul>
<li>Documentation: <a href="https://pubhub.devnetcloud.com/media/genie-docs/docs/userguide/utils/index.html#dq">https://pubhub.devnetcloud.com/media/genie-docs/docs/userguide/utils/index.html#dq</a></li>
<li>Παράδειγμα: <a href="https://twitter.com/jeaubin5/status/1232668555658874881?s=09">https://twitter.com/jeaubin5/status/1232668555658874881?s=09</a></li>
<li>Παράδειγμα: <a href="https://twitter.com/tahigash3/status/1233382956359507969?s=09">https://twitter.com/tahigash3/status/1233382956359507969?s=09</a></li>
<li>Παράδειγμα: <a href="https://twitter.com/tahigash3/status/1233384445173850113?s=09">https://twitter.com/tahigash3/status/1233384445173850113?s=09</a></li>
<li>Post: <a href="https://www.packetcoders.io/simplify-parsing-with-ciscos-genie-dq/">https://www.packetcoders.io/simplify-parsing-with-ciscos-genie-dq/</a></li>
<li>Video: <a href="https://youtu.be/XNdlvlbHMUI">https://youtu.be/XNdlvlbHMUI</a></li>
</ul>
<p><img src="https://pbs.twimg.com/media/ER3bLfsUEAAhE_n?format=jpg&amp;name=large" alt="Up Ports with PyATS Dq"></p>
<p><img src="https://pbs.twimg.com/media/ER3cfHqUYAMdgK3?format=jpg&amp;name=large" alt="Up Ports Key-Value pairs with PyATS Dq"></p>
<h3 id="pyats-clean">PyATS Clean</h3>
<p>To PyATS clean επιτρέπει να επαναφέρουμε τη συσκευή σε μια συγκεκριμένη κατάσταση με συγκεκριμένο λογισμικό, ανεξάρτητα από το λογισμικό και την κατάσταση που είχε πριν την επαναφορά.</p>
<ul>
<li>Documentation - <a href="https://pubhub.devnetcloud.com/media/genie-docs/docs/clean/index.html">https://pubhub.devnetcloud.com/media/genie-docs/docs/clean/index.html</a></li>
<li>Παράδειγμα - <a href="https://github.com/CiscoTestAutomation/examples/tree/master/clean">https://github.com/CiscoTestAutomation/examples/tree/master/clean</a></li>
</ul>
<h1 id="use-cases">Use Cases</h1>
<p>Τα Use Cases του PyATS περιορίζονται μόνο από τη φαντασία αλλά τα βασικότερα περιγράφονται παρακάτω:</p>
<ul>
<li><strong>Data Collection</strong> - Συλλογή στοιχείων από τις συσκευές του δικτύου για να πάρουμε ακριβή εικόνα του Network State. Μπορεί να έχει απλή μορφή, όπως output στο CLI, ή ακόμα και σε εργαλεία reporting, p.x. pyats -&gt; prometheus pushgateway -&gt; prometheus -&gt; grafana. Σε αυτό το concept πρέπει κανείς να δει τί έχει φτιάξει ο John Cappobianco με το Merlin project.</li>
<li><strong>Configuration</strong> - Αυτοματοποιημένο Configuration των συσκευών σειριακά ή παράλληλα, μόνο με το PyATS ή σε συνδυασμό με άλλα εργαλεία και βιβλιοθήκες.</li>
<li><strong>Capturing changes</strong> χωρίς να μας ξέρουμε εκ των προτέρων ακριβώς το τί άλλαξε.</li>
<li><strong>Testing</strong> (Chaos Monkey/Validation) - Μπορούμε να ελέγξουμε αν οι συσκευές μας ή το δίκτυο μας ανταποκρίνεται όπως πρέπει σε αλλαγές ή βλάβες. Σε αυτό το concept το PyATS μπορεί να χρησιμοποιηθεί και σε CI/CD pipelines για εφαρμογή Network Configuration As Code.</li>
</ul>
<h1 id="learn-about-pyats">Learn about PyATS</h1>
<p><a href="https://youtu.be/bWLNBXdFZYI"><img src="https://img.youtube.com/vi/bWLNBXdFZYI/maxresdefault.jpg" alt="pyATS for your Test Automation"></a></p>
<ul>
<li>Devnet Getting started - <a href="https://developer.cisco.com/pyats/">https://developer.cisco.com/pyats/</a></li>
<li>Learning Labs
<ul>
<li><a href="https://developer.cisco.com/learning/lab/intro-to-pyats/step/1">https://developer.cisco.com/learning/lab/intro-to-pyats/step/1</a></li>
<li><a href="https://developer.cisco.com/learning/lab/pts-with-genie/step/1">https://developer.cisco.com/learning/lab/pts-with-genie/step/1</a></li>
<li>All Learning Labs - <a href="https://developer.cisco.com/learning/modules/pyats-genie">https://developer.cisco.com/learning/modules/pyats-genie</a></li>
</ul>
</li>
<li>Cisco Live Workshops
<ul>
<li>Cisco Live! DEVWKS-2595: Stateful Network Validation using pyATS/Genie - <a href="https://github.com/CiscoTestAutomation/CL-DevNet-2595">https://github.com/CiscoTestAutomation/CL-DevNet-2595</a></li>
<li>CL-DevNet-2595 Workshop - <a href="https://github.com/CiscoTestAutomation/CL-DevNet-2595/blob/master/workshop.md">https://github.com/CiscoTestAutomation/CL-DevNet-2595/blob/master/workshop.md</a></li>
<li>Cisco Live! DEVWKS-2808 - <a href="https://github.com/CiscoTestAutomation/CL-DEVWKS-2808/blob/master/workshop.md">https://github.com/CiscoTestAutomation/CL-DEVWKS-2808/blob/master/workshop.md</a></li>
</ul>
</li>
<li>Training
<ul>
<li>CBT Nuggets, John McGovern - <a href="https://www.cbtnuggets.com/learn/it-training/automate-network-testing-with-pyats">https://www.cbtnuggets.com/learn/it-training/automate-network-testing-with-pyats</a></li>
<li>Packet Coders, Rick Donato - <a href="https://www.packetcoders.io/network-testing-with-cisco-pyats/">https://www.packetcoders.io/network-testing-with-cisco-pyats/</a></li>
</ul>
</li>
<li>Devnet Expert
<ul>
<li>Devnet Expert Presentation - <a href="https://blogs.cisco.com/learning/cisco-devnet-expert-your-career-changing-certification">https://blogs.cisco.com/learning/cisco-devnet-expert-your-career-changing-certification</a></li>
<li>Denvet Expert Summary - <a href="https://www.cisco.com/c/en/us/training-events/training-certifications/certifications/expert/devnet-expert.html?ccid=devnetexpert&amp;dtid=blog&amp;oid=blog-cisco-par">https://www.cisco.com/c/en/us/training-events/training-certifications/certifications/expert/devnet-expert.html?ccid=devnetexpert&amp;dtid=blog&amp;oid=blog-cisco-par</a></li>
<li>Lab Topics - <a href="https://learningnetwork.cisco.com/s/devnet-expert-exam-topics-lab">https://learningnetwork.cisco.com/s/devnet-expert-exam-topics-lab</a></li>
</ul>
</li>
</ul>
<h1 id="projects--posts">Projects &amp; Posts</h1>
<p>Πολλά projects θα βρείτε σχετικά με το PyATS. Εδώ θα αναφέρουμε μόνο ένα, το Merlin, από τον John Cappobianco, ο οποίος έβαλε σκοπό να συνδυάσει το PyATS με ένα σωρό διαφορετικές τεχνολογίες (Jinja Templates, Django, Celery, Docker, Kubernetes, κλπ) και δυνατότητες:</p>
<ul>
<li>Search as Code</li>
<li>3D representation of network state</li>
<li>ChatOps</li>
<li>TextToSpeech</li>
<li>Automated Calling</li>
<li>Mind Maps</li>
<li>Scheduled Tasks</li>
<li>κλπ</li>
</ul>
<p><img src="https://raw.githubusercontent.com/automateyournetwork/merlin/main//images/Merlin_logo.png" alt="Merlin Logo"></p>
<p>Σχετικά links:</p>
<ul>
<li>To site του John - <a href="https://www.automateyournetwork.ca/">https://www.automateyournetwork.ca/</a></li>
<li>To κανάλι του στο Youtube - <a href="https://www.youtube.com/channel/UCYE2gcN4wWewmriAP2QlT2A">https://www.youtube.com/channel/UCYE2gcN4wWewmriAP2QlT2A</a></li>
<li>To profil του στο Github όπου θα βρείτε τα διάφορα flavors του Merlin - <a href="https://github.com/automateyournetwork">https://github.com/automateyournetwork</a></li>
<li>O John στους packet pushers - <a href="https://www.youtube.com/watch?v=NA4B_MqzVIM">https://www.youtube.com/watch?v=NA4B_MqzVIM</a></li>
<li>O John στο Art of Network Engineering - <a href="https://artofnetworkengineering.com/2021/12/01/ep-71-merlin-the-auto-magician/">https://artofnetworkengineering.com/2021/12/01/ep-71-merlin-the-auto-magician/</a></li>
<li>Κάντε εγγραφή στo webex channel του Merlin - <a href="https://eurl.io/#Yc-8-BgSD">https://eurl.io/#Yc-8-BgSD</a></li>
</ul>
<p>Περισσότερα για άλλα projects &amp; integrations στα Links &amp; Sources</p>
<h1 id="links---sources">Links - Sources</h1>
<ul>
<li>Cisco Developer Blog posts - <a href="https://blogs.cisco.com/tag/pyats">https://blogs.cisco.com/tag/pyats</a></li>
<li>Use PyATS on your Laptop - <a href="https://developer.cisco.com/docs/pyats/#!hands-on-learning/diy-on-your-laptop">https://developer.cisco.com/docs/pyats/#!hands-on-learning/diy-on-your-laptop</a></li>
<li>Podcasts &amp; Videos - <a href="https://developer.cisco.com/docs/pyats/#!hands-on-learning/podcasts--videos">https://developer.cisco.com/docs/pyats/#!hands-on-learning/podcasts--videos</a></li>
<li>Integrations
<ul>
<li>DNAC - <a href="https://developer.cisco.com/codeexchange/github/repo/CiscoTestAutomation/DNAC-pyATS-Genie/">https://developer.cisco.com/codeexchange/github/repo/CiscoTestAutomation/DNAC-pyATS-Genie/</a></li>
<li>Netconf &amp; Yang:
<ul>
<li><a href="https://developer.cisco.com/codeexchange/github/repo/CiscoTestAutomation/yang">https://developer.cisco.com/codeexchange/github/repo/CiscoTestAutomation/yang</a></li>
<li><a href="https://github.com/CiscoTestAutomation/yang/blob/master//connector/docs/README.rst">https://github.com/CiscoTestAutomation/yang/blob/master//connector/docs/README.rst</a></li>
</ul>
</li>
<li>Ansible - <a href="https://developer.cisco.com/codeexchange/github/repo/clay584/parse_genie">https://developer.cisco.com/codeexchange/github/repo/clay584/parse_genie</a></li>
</ul>
</li>
<li>Documentation - <a href="https://developer.cisco.com/docs/genie-docs/">https://developer.cisco.com/docs/genie-docs/</a></li>
<li>Configuration -  <a href="https://pubhub.devnetcloud.com/media/genie-docs/docs/userguide/Conf/index.html">https://pubhub.devnetcloud.com/media/genie-docs/docs/userguide/Conf/index.html</a></li>
<li>NetDevOps validation using Cisco pyATS | Genie for network engineers: no coding necessary - <a href="https://developer.cisco.com/network-automation/detail/1355627332691844/">https://developer.cisco.com/network-automation/detail/1355627332691844/</a></li>
<li>Automating OS migration pre-checks and post-checks with pyATS - <a href="https://developer.cisco.com/network-automation/detail/5a7288c9-411b-11eb-b9d4-ae71b9e1fe30/">https://developer.cisco.com/network-automation/detail/5a7288c9-411b-11eb-b9d4-ae71b9e1fe30/</a></li>
<li>Development Guide - <a href="https://developer.cisco.com/docs/pyats-development-guide/">https://developer.cisco.com/docs/pyats-development-guide/</a></li>
<li>LAB by Stuart Traynor - <a href="https://github.com/sttrayno/pyATS-Lab-Guide">https://github.com/sttrayno/pyATS-Lab-Guide</a></li>
<li><a href="https://pubhub.devnetcloud.com/media/pyats-getting-started/docs/bestpractices/intro.html">https://pubhub.devnetcloud.com/media/pyats-getting-started/docs/bestpractices/intro.html</a></li>
<li>Creating pyATS | Genie Parsers and Unicon Connection Plugins - <a href="https://youtu.be/0WvizVReKLs">https://youtu.be/0WvizVReKLs</a></li>
<li>Genie Feature Browser - <a href="https://pubhub.devnetcloud.com/media/genie-feature-browser/docs/#/">https://pubhub.devnetcloud.com/media/genie-feature-browser/docs/#/</a></li>
<li>Use TextFSM with PyATS - <a href="https://twitter.com/tahigash3/status/1281247080913072129?s=09">https://twitter.com/tahigash3/status/1281247080913072129?s=09</a></li>
<li>Network Automation with pyATS, Genie and Cisco DNA Center - <a href="https://www.brighttalk.com/webcast/17628/367044">https://www.brighttalk.com/webcast/17628/367044</a></li>
<li>The Unicon Connection Library - <a href="https://developer.cisco.com/docs/unicon/">https://developer.cisco.com/docs/unicon/</a></li>
<li>Connection User Guide - <a href="https://pubhub.devnetcloud.com/media/unicon/docs/user_guide/connection.html">https://pubhub.devnetcloud.com/media/unicon/docs/user_guide/connection.html</a></li>
<li>Exploring Genie Conf for Pythonic Device Configuration - <a href="https://youtu.be/2C-Y-DJhIdk">https://youtu.be/2C-Y-DJhIdk</a></li>
<li>Cisco Live! DEVWKS-2595: Stateful Network Validation using pyATS/Genie - <a href="https://github.com/CiscoTestAutomation/CL-DevNet-2595">https://github.com/CiscoTestAutomation/CL-DevNet-2595</a></li>
<li>CL-DevNet-2595 Workshop - <a href="https://github.com/CiscoTestAutomation/CL-DevNet-2595/blob/master/workshop.md">https://github.com/CiscoTestAutomation/CL-DevNet-2595/blob/master/workshop.md</a></li>
<li>Εισαγωγικό video από τον μακαρίτη Kevin Corbin - <a href="https://www.youtube.com/watch?v=LxiBHPMves8&amp;t=611s">https://www.youtube.com/watch?v=LxiBHPMves8&amp;t=611s</a></li>
<li>pyATS CLI Demonstration by Hank Preston - <a href="https://github.com/hpreston/netdevops_demos/blob/master/genie-cli-1/README.md">https://github.com/hpreston/netdevops_demos/blob/master/genie-cli-1/README.md</a></li>
<li>pyATS series by Antoine Orsoni - Install and use pyATS - <a href="https://xrdocs.io/programmability/tutorials/pyats-series-install-and-use-pyats/">https://xrdocs.io/programmability/tutorials/pyats-series-install-and-use-pyats/</a></li>
<li>Unit Testing Network Infrastructure w/ pyATS - <a href="https://routedefault.wordpress.com/2021/12/20/unit-testing-network-infrastructure-w-pyats/">https://routedefault.wordpress.com/2021/12/20/unit-testing-network-infrastructure-w-pyats/</a></li>
<li>PyATS Dockerfile and Scripts - <a href="https://github.com/CiscoTestAutomation/pyats-docker">https://github.com/CiscoTestAutomation/pyats-docker</a></li>
<li>PyATS Devnet SE hour (Antoine Orsoni Github) - <a href="https://github.com/AntoineOrsoni/pyats-devnet-se-hour">https://github.com/AntoineOrsoni/pyats-devnet-se-hour</a></li>
<li>Genie Development in a container with VS Code - <a href="https://twitter.com/simingy/status/1146844441816305665">https://twitter.com/simingy/status/1146844441816305665</a></li>
<li>AETest Infrastructure - <a href="https://pubhub.devnetcloud.com/media/pyats/docs/aetest/index.html">https://pubhub.devnetcloud.com/media/pyats/docs/aetest/index.html</a></li>
<li>Use the q function - <a href="https://twitter.com/host_bits/status/1316052483089854464?s=09">https://twitter.com/host_bits/status/1316052483089854464?s=09</a></li>
<li>PyATS Pcall - <a href="https://pubhub.devnetcloud.com/media/pyats/docs/async/pcall.html">https://pubhub.devnetcloud.com/media/pyats/docs/async/pcall.html</a></li>
<li>Use PyATS with Jinja templates - <a href="https://twitter.com/jeaubin5/status/1313183366087311366">https://twitter.com/jeaubin5/status/1313183366087311366</a></li>
<li>PyATS example with Rich - <a href="https://github.com/sclayton1006/pyATS/blob/main/IP_Int_Brief_Emoji.py">https://github.com/sclayton1006/pyATS/blob/main/IP_Int_Brief_Emoji.py</a></li>
<li>Intro to PyATS with Claudia De Luna - <a href="https://github.com/cldeluna/interop2020_pyats_intro">https://github.com/cldeluna/interop2020_pyats_intro</a></li>
<li>PyATS Secret Strings - <a href="https://pubhub.devnetcloud.com/media/pyats/docs/utilities/secret_strings.html">https://pubhub.devnetcloud.com/media/pyats/docs/utilities/secret_strings.html</a></li>
<li>PyATS and Genie Intro by Mike Guy - <a href="https://thetwistedpair.co.uk/2020/03/pyats_and_genie_intro/">https://thetwistedpair.co.uk/2020/03/pyats_and_genie_intro/</a></li>
<li>PyATS as Nornir Task example - <a href="https://twitter.com/gp_ifconfig/status/1233782963478855680?s=09">https://twitter.com/gp_ifconfig/status/1233782963478855680?s=09</a></li>
<li>Offline Parser - <a href="https://twitter.com/jeaubin5/status/1233133522451410947?s=09">https://twitter.com/jeaubin5/status/1233133522451410947?s=09</a></li>
<li>PyATS Examples - <a href="https://pypi.org/project/pyats.examples/">https://pypi.org/project/pyats.examples/</a></li>
<li>PyATS Coding 101 by Siming Yuan - <a href="https://github.com/CiscoDevNet/pyats-coding-101/tree/master/coding-101-python">https://github.com/CiscoDevNet/pyats-coding-101/tree/master/coding-101-python</a></li>
<li>Send emails at the end of PyATS test report - <a href="https://twitter.com/simingy/status/1184203882060304384?s=09">https://twitter.com/simingy/status/1184203882060304384?s=09</a></li>
<li>PyATS to Netbox by Hank Preston (beware it&rsquo;s not new, not sure it works with newer versions) - <a href="https://github.com/hpreston/netdevops_demos/tree/master/pyats-to-netbox">https://github.com/hpreston/netdevops_demos/tree/master/pyats-to-netbox</a></li>
<li>Learn why pyATS is used by thousands of network engineers and developers world-wide. DevNet Snack Minute Episode 36 - <a href="https://video.cisco.com/video/6271298878001?ccid=pyats-page&amp;dtid=twitter&amp;oid=videosnackminute-fy22-q1-0000-grazianosnackminuteep36-ww">https://video.cisco.com/video/6271298878001?ccid=pyats-page&amp;dtid=twitter&amp;oid=videosnackminute-fy22-q1-0000-grazianosnackminuteep36-ww</a></li>
</ul>
<p><a href="https://youtu.be/2C-Y-DJhIdk"><img src="https://img.youtube.com/vi/2C-Y-DJhIdk/maxresdefault.jpg" alt="Exploring Genie Conf for Pythonic Device Configuration"></a></p>
]]></content>
        </item>
        
        <item>
            <title>Jumpstart your Python Learning</title>
            <link>https://netautogr.github.io/posts/2021/12/jumpstart-your-python-learning/</link>
            <pubDate>Fri, 10 Dec 2021 08:20:22 +0200</pubDate>
            
            <guid>https://netautogr.github.io/posts/2021/12/jumpstart-your-python-learning/</guid>
            <description>Γενικά Το βασικό θέμα του παρόντος post είναι πως να ξεκινήσει κανείς να μαθαίνει Python (με οποιοδήποτε τρόπο). Τα παρακάτω προέκυψαν από συζητήσεις μελών μας στο LinkedIn, εσωτερικές συζητήσεις μέσα στην κοινότητα και συλλογή από online resources. Αφορμή υπήρξαν μια ερώτηση προερχόμενη εκτός της κοινότητας για εκμάθηση Python για συγκεκριμένο πακέτο Business Intelligence και ερώτηση μέλους ποιο είναι το καταλληλότερο σημείο εκκίνησης για εκμάθηση Python, πιθανώς ξεκινώντας από το μηδέν.</description>
            <content type="html"><![CDATA[<h1 id="γενικά">Γενικά</h1>
<p>Το βασικό θέμα του παρόντος post είναι πως να ξεκινήσει κανείς να μαθαίνει Python (με οποιοδήποτε τρόπο).
Τα παρακάτω προέκυψαν από συζητήσεις μελών μας στο LinkedIn, εσωτερικές συζητήσεις μέσα στην κοινότητα και συλλογή από online resources. Αφορμή υπήρξαν μια ερώτηση προερχόμενη εκτός της κοινότητας για εκμάθηση Python για συγκεκριμένο πακέτο Business Intelligence και ερώτηση μέλους ποιο είναι το καταλληλότερο σημείο εκκίνησης για εκμάθηση Python, πιθανώς ξεκινώντας από το μηδέν.</p>
<h1 id="disclaimer">Disclaimer</h1>
<p>Η κοινότητα μας δεν αποτελεί επίσημη οντότητα, δεν έχει καμία εμπορική σχέση ή ωφέλεια και δεν κάνει διαφημίσεις. Μοναδικός σκοπός είναι η βοήθεια στο χώρο των μηχανικών για την πιο ομαλή εκκίνηση της ενασχόλησης τους με το Network Automation &amp; Programmability.</p>
<p>Δεν θεωρώ τον εαυτό μου ειδικό στην python. Ωστόσο για διάφορους λόγους έχω περάσει πλέον 5 χρόνια εξερευνώντας τις δυνατότητες της γλώσσας για αυτοματισμό κυρίως γύρω από δίκτυα και σχετικό λογισμικό, προσπαθώντας ταυτόχρονα να τη χρησιμοποιήσω και ως &ldquo;κόλλα&rdquo; για διάφορα integrations.
Συνεπώς πάρτε ότι συμβουλή ακολουθήσει &ldquo;with a grain of salt&rdquo; όπως λένε..</p>
<h1 id="ξεκίνημα-για-αρχάριους">Ξεκίνημα για αρχάριους</h1>
<p>Για γενικές γνώσεις πάνω στην Python ο κόσμος συνήθως λαμβάνει κατευθύνσεις για αντίστοιχα βιβλία και courses. Τέτοια είναι για παράδειγμα :</p>
<ul>
<li>Angela Yu&rsquo;s &ldquo;100 Days of Code&rdquo; - <a href="https://www.udemy.com/course/100-days-of-code/">https://www.udemy.com/course/100-days-of-code/</a></li>
<li>Learn Python3 the hard way - <a href="https://learnpythonthehardway.org/python3/preface.html">https://learnpythonthehardway.org/python3/preface.html</a></li>
<li>The Python Workshop από την PACT - <a href="https://www.packtpub.com/free-ebook/the-python-workshop/9781839218859">https://www.packtpub.com/free-ebook/the-python-workshop/9781839218859</a> , έχει και facebook group: <a href="https://www.facebook.com/watch/?v=400826784264169">https://www.facebook.com/watch/?v=400826784264169</a></li>
</ul>
<h1 id="python-and-apis">Python and APIs</h1>
<p>Πολλά software πακέτα, μεταξύ αυτών και κάποια για BI διαθέτουν API που είναι βασισμένο σε REST.
Η python έχει libraries για να μιλήσετε με REST APIs, η πιο δημοφιλής (αλλά όχι η μοναδική) είναι η requests. Κάποιοι μιλούν πολύ θετικά για την httpx αλλά για αρχή μπορείτε να την αγνοήσετε.
Ειδικά για REST APIs, πήρα τις πρώτες μου γνώσεις μέσω Cisco Devnet γιατί με ενδιέφεραν τα APIs που έχουν οι σχετικές πλατφόρμες λογισμικού. Το Cisco Devnet διαθέτει δωρεάν πρόσβαση (κατόπιν εγγραφής με το email σας) σε μια μεγάλη συλλογή από self paced labs και trainings (μικρά σε έκταση) όπου μπορεί κανείς να μάθει τις σχετικές τεχνολογίες.
Δεν είναι όμως υποχρεωτικό να ακολουθήσετε αυτή την οδό.</p>
<h2 id="start-with-postman-rest-client">Start with Postman (REST Client)</h2>
<p>Για να μιλήσετε με REST APIs μπορείτε να πειραματιστείτε κατευθείαν με εργαλεία που δεν απαιτούν γνώσεις προγραμματισμού, όπως το Postman. <a href="https://www.postman.com/">https://www.postman.com/</a></p>
<p>Στο site του postman μπορείτε να βρείτε collections για δημοφιλή λογισμικά που υποστηρίζουν REST, π.χ. <a href="https://www.postman.com/power-bi?tab=collections">https://www.postman.com/power-bi?tab=collections</a></p>
<h2 id="use-an-ide-visual-studio-code">Use an IDE (Visual Studio Code)</h2>
<p>Αν ήδη γνωρίζετε προγραμματισμό και χρησιμοποιείτε κάποιο IDE όπως το visual studio code (<a href="https://code.visualstudio.com/),">https://code.visualstudio.com/),</a> κάποια από αυτά έχουν extensions/plugins που ενσωματώνουν rest clients χωρίς να χρειάζεστε εξωτερικά εργαλεία (<a href="https://www.producthunt.com/posts/thunder-client">https://www.producthunt.com/posts/thunder-client</a>)</p>
<p>Υπάρχουν resources για να πειραματιστείτε με REST APIs στο internet. Π.χ. <a href="https://deckofcardsapi.com/">https://deckofcardsapi.com/</a></p>
<h1 id="use-python-with-excel-and-csvs-maybe-for-data-analysis">Use Python with Excel and CSVs (maybe) for Data Analysis</h1>
<p>Επειδή αναφέρατε το excel, θα πρέπει να έχετε υπόψη σας δύο βιβλιοθήκες. Openpyxl &amp; Pandas.</p>
<ul>
<li><a href="https://openpyxl.readthedocs.io/en/stable/">https://openpyxl.readthedocs.io/en/stable/</a></li>
<li><a href="https://pandas.pydata.org/docs/">https://pandas.pydata.org/docs/</a></li>
</ul>
<p>Η πρώτη είναι πιο lightweight και προσφέρεται για να μάθετε το excel manipulation μέσω Python.</p>
<p>Η δεύτερη δουλεύει με dataframes, διαθέτει μεγαλύτερο βάθος και είναι must για data analysts καθώς διαθέτει τεράστιες δυνατότητες για επεξεργασία δεδομένων.</p>
<h1 id="online-learning-platforms--resources">Online Learning Platforms &amp; Resources</h1>
<p>Υπάρχουν πολλές πλατφόρμες που δίνουν δωρεάν γνώση για python και άλλες όπου υπάρχει συνδρομή.</p>
<h2 id="δωρεάν">Δωρεάν</h2>
<ul>
<li><a href="https://www.codecademy.com/">https://www.codecademy.com/</a></li>
<li><a href="https://www.freecodecamp.org/">https://www.freecodecamp.org/</a></li>
</ul>
<p>Αυτό το post αναφέρει κι άλλα sources, εκτός αυτών και η NSA είχε δημοσιεύσει το internal course της για Python, δωρεάν.
<a href="https://www.makeuseof.com/how-to-learn-python-for-free/amp/">https://www.makeuseof.com/how-to-learn-python-for-free/amp/</a></p>
<p>Εδώ αναφέρονται αρκετά free courses. Κάποια είναι σε Πανεπιστήμια και ακολουθούν πρόγραμμα - <a href="https://www.makeuseof.com/python-online-course-free/">https://www.makeuseof.com/python-online-course-free/</a></p>
<h2 id="δωρεάν---learning-at-cisco">Δωρεάν - Learning at Cisco</h2>
<p><a href="https://learningnetwork.cisco.com/s/learning-plan-detail-standard?ltui__urlRecordId=a1c6e0000096sAfAAI&amp;ltui__urlRedirect=learning-plan-detail-standard">https://learningnetwork.cisco.com/s/learning-plan-detail-standard?ltui__urlRecordId=a1c6e0000096sAfAAI&amp;ltui__urlRedirect=learning-plan-detail-standard</a> - Course για Python, δωρεάν πρόσβαση.</p>
<h2 id="network-oriented">Network Oriented</h2>
<p>Εγώ προσωπικά, λόγω ενδιαφερόντων ξεκίνησα από εδω:</p>
<ul>
<li><a href="https://pynet.twb-tech.com/free-python-course.html">https://pynet.twb-tech.com/free-python-course.html</a> - To Free Email Course του Kirk Byers (υπάρχει και Paid Version που περιλαμβάνει και προχωρημένα αντικείμενα, έχει λάβει καλές κριτικές. Για το Free course οι απόψεις διίστανται)</li>
<li><a href="https://developer.cisco.com/video/net-prog-basics/">https://developer.cisco.com/video/net-prog-basics/</a></li>
<li><a href="https://www.slideshare.net/JeremySchulman/python-for-network-engineers-a-practical-guide-for-getting-started">https://www.slideshare.net/JeremySchulman/python-for-network-engineers-a-practical-guide-for-getting-started</a> - Slides από Jeremy Schulman (πρώην Juniper Networks, νυν NBL)</li>
</ul>
<p>Πέραν του Video στο Cisco Devnet θα βρείτε αρκετά labs και για καθαρό Python, όπως:</p>
<ul>
<li><a href="https://developer.cisco.com/learning/modules/programming-fundamentals/intro-python-part1/step/1">https://developer.cisco.com/learning/modules/programming-fundamentals/intro-python-part1/step/1</a></li>
<li><a href="https://developer.cisco.com/learning/modules/programming-fundamentals/intro-python-part2/step/1">https://developer.cisco.com/learning/modules/programming-fundamentals/intro-python-part2/step/1</a></li>
<li><a href="https://developer.cisco.com/learning/modules/programming-fundamentals/parsing-json-python/step/1">https://developer.cisco.com/learning/modules/programming-fundamentals/parsing-json-python/step/1</a></li>
</ul>
<p>Το βιβλίο του Eric Chou (από την PACT, διαθέσιμο μέσω Amazon) είναι εξαιρετικό κατά γενική ομολογία.
<a href="https://www.amazon.com/Mastering-Python-Networking-automation-programmability/dp/1839214678/">https://www.amazon.com/Mastering-Python-Networking-automation-programmability/dp/1839214678/</a></p>
<h2 id="γενικά-για-automation">Γενικά για automation</h2>
<p><a href="https://automatetheboringstuff.com/">https://automatetheboringstuff.com/</a> - Το βιβλίο Al Sweigart το Automate the boring stuff with Python (2nd edition)</p>
<h2 id="for-non-programmers">For non-programmers</h2>
<ul>
<li><a href="https://store.lerner.co.il/python-for-non-programmers-live">https://store.lerner.co.il/python-for-non-programmers-live</a></li>
<li><a href="https://thenewstack.io/an-introduction-to-python-for-non-programmers/">https://thenewstack.io/an-introduction-to-python-for-non-programmers/</a></li>
</ul>
<h2 id="δωρεάν-ως-ένα-βαθμό">Δωρεάν ως ένα βαθμό</h2>
<ul>
<li><a href="https://realpython.com/start-here/">https://realpython.com/start-here/</a> Εδώ θα βρείτε και αρκετά posts για excel &amp; csv, must για να πάρετε μια γρήγορη ιδέα.</li>
<li><a href="https://realpython.com/openpyxl-excel-spreadsheets-python/">https://realpython.com/openpyxl-excel-spreadsheets-python/</a></li>
<li><a href="https://realpython.com/lessons/excel-python-openpyxl-overview/">https://realpython.com/lessons/excel-python-openpyxl-overview/</a></li>
<li><a href="https://realpython.com/pandas-read-write-files/">https://realpython.com/pandas-read-write-files/</a></li>
<li><a href="https://realpython.com/python-csv/">https://realpython.com/python-csv/</a></li>
<li><a href="https://realpython.com/python-interview-problem-parsing-csv-files/">https://realpython.com/python-interview-problem-parsing-csv-files/</a></li>
<li><a href="https://store.lerner.co.il/python-for-non-programmers-live">https://store.lerner.co.il/python-for-non-programmers-live</a></li>
</ul>
<h2 id="άλλα-σημαντικά-site">Άλλα σημαντικά site</h2>
<ul>
<li><a href="https://www.w3schools.com/python/default.asp">https://www.w3schools.com/python/default.asp</a> - Προτείνεται και από Πανεπιστήμια</li>
<li><a href="https://dev.to/">https://dev.to/</a></li>
<li><a href="https://stackoverflow.com/">https://stackoverflow.com/</a></li>
</ul>
<p>Επίσης μην ξεχνάτε τη δύναμη του google &amp; youtube.</p>
<h2 id="online-platforms-με-κόστος">Online Platforms με κόστος</h2>
<ul>
<li>
<p><a href="https://www.udemy.com/">https://www.udemy.com/</a> - κόστος ανά course</p>
</li>
<li>
<p><a href="https://www.pluralsight.com/">https://www.pluralsight.com/</a> - Συνδρομή (μεγάλη έκπτωση στην Blackfriday)</p>
</li>
<li>
<p><a href="https://www.cbtnuggets.com/features">https://www.cbtnuggets.com/features</a> - Συνδρομή (αρκετά ακριβότεροι, πάνε σε μεγαλύτερο βάθος σε ορισμένες περιπτώσεις).</p>
</li>
</ul>
<p>Ειδικά σε αυτό:</p>
<ul>
<li>
<p><a href="https://www.cbtnuggets.com/it-training/python/network-engineers-intro">https://www.cbtnuggets.com/it-training/python/network-engineers-intro</a></p>
</li>
<li>
<p><a href="https://www.cbtnuggets.com/it-training/python/beginner-python-3">https://www.cbtnuggets.com/it-training/python/beginner-python-3</a></p>
</li>
<li>
<p><a href="https://www.oreilly.com/online-learning/">https://www.oreilly.com/online-learning/</a> - Συνδρομή (αρκετά ακριβότεροι, πρόσβαση σε online ζωντανά σεμινάρια, recorded video trainings και βιβλία από αρκετούς εκδοτικούς οίκους.</p>
</li>
</ul>
<h2 id="ελληνικά-academies">Ελληνικά Academies</h2>
<p>Το μόνο που γνωρίζω που προσφέρει αυτή τη στιγμή σχετικό training είναι το HAEC (Εκπαιδευτικό Κέντρο της ΕλληνοΑμερικανικής Ένωσης)</p>
<ul>
<li><a href="https://www.haec.gr/en/devnet-associate">https://www.haec.gr/en/devnet-associate</a> - Devnet Associate Training (περιλαμβάνει και Python αλλά έχει focus σε automation &amp; Devops training για το Cisco Devnet Associate Certification)</li>
<li><a href="https://www.haec.gr/el/programmatismos-me-python">https://www.haec.gr/el/programmatismos-me-python</a> - Python Training</li>
</ul>
<h1 id="set-up-your-ide">Set up your IDE</h1>
<p><a href="https://www.youtube.com/watch?v=7FltByLPnrg">https://www.youtube.com/watch?v=7FltByLPnrg</a> - Setting up VS Code for Python Beginners</p>
<h1 id="άρθρα-με-συμβουλές-και-walkthroughs">Άρθρα με συμβουλές και walkthroughs</h1>
<p>Το internet γεμάτο. Κάποια sites είναι πιο αξιόπιστα, να είστε λίγο προσεκτικοί, μπορεί να σας βοηθήσουν στην εύκολη κατανόηση αλλά είναι εύκολο να περιέχουν μισή γνώση ή λάθη.
Ένα παράδειγμα:</p>
<p><a href="https://towardsdatascience.com/python-go-from-rookie-to-rockstar-d03fa07a32e8">https://towardsdatascience.com/python-go-from-rookie-to-rockstar-d03fa07a32e8</a></p>
<h1 id="πρόταση-προσέγγισης">Πρόταση προσέγγισης</h1>
<p>Θα πρότεινα να πάρετε γρήγορα γενικές γνώσεις (variables, input &amp; output, δομές ελέγχου, functions, classes - optional, virtual environments) και μετά να εστιάσετε στα excel libraries &amp; REST APIs. Επίσης θα χρειαστεί κάποια στιγμή να ασχοληθείτε με το debugging είτε μέσω κάποιου IDE (π.χ. visual studio code) είτε με αντίστοιχα libraries όπως ipdb.</p>
<p>Καλή επιτυχία!</p>
]]></content>
        </item>
        
        <item>
            <title>Python_Vs_Ansible skirmish</title>
            <link>https://netautogr.github.io/posts/2021/12/python_vs_ansible-skirmish/</link>
            <pubDate>Fri, 10 Dec 2021 00:29:41 +0200</pubDate>
            
            <guid>https://netautogr.github.io/posts/2021/12/python_vs_ansible-skirmish/</guid>
            <description>Συζήτηση Η παρακάτω συζήτηση έγινε ένα απόγευμα στην κοινότητα μας μεταξύ του Πέτρου και του Νίκου (οποιαδήποτε ομοιότητα ή συσχετισμός με υπαρκτά πρόσωπα ενδεχομένως και να είναι συμπτωματική).
Πέτρος:
Εχω ξεκινήσει το ταξίδι μου και εγώ για DevNet &amp;amp; Automation. Παντού βλέπω ότι συγκρίνουν την python vs Ansible. Αφού δεν ειναι τα ιδια, γιατι αυτη η σύγκριση; Καταλαβαινω να συγκρινουν:
 Python vs Java Python vs C or C++  Μπορειτε να με βοηθήσετε ωστε να καταλαβω και εγω;</description>
            <content type="html"><![CDATA[<h1 id="συζήτηση">Συζήτηση</h1>
<p>Η παρακάτω συζήτηση έγινε ένα απόγευμα στην κοινότητα μας μεταξύ του Πέτρου και του Νίκου (οποιαδήποτε ομοιότητα ή συσχετισμός με υπαρκτά πρόσωπα ενδεχομένως και να είναι συμπτωματική).</p>
<p>Πέτρος:</p>
<p>Εχω ξεκινήσει το ταξίδι μου και εγώ για DevNet &amp; Automation. Παντού βλέπω ότι συγκρίνουν την python vs Ansible. Αφού δεν ειναι τα ιδια, γιατι αυτη η σύγκριση;
Καταλαβαινω να συγκρινουν:</p>
<ul>
<li>Python vs Java</li>
<li>Python vs C or C++</li>
</ul>
<p>Μπορειτε να με βοηθήσετε ωστε να καταλαβω και εγω;</p>
<h1 id="πλαίσιο">Πλαίσιο</h1>
<p>Νίκος:</p>
<p>Ο λόγος που ενίοτε γίνεται αυτή η σύγκριση είναι ότι python και Ansible είναι δύο βασικά εργαλεία για network automation. Προφανώς έχεις δίκιο ότι συγκρίνονται μήλα με πορτοκάλια οπότε θα προσπαθήσω να εξηγήσω γιατί έχει νόημα η σύγκριση..</p>
<p>Σε αυτό το context λοιπόν, η σύγκριση στην πράξη είναι μεταξύ Ansible και του &ldquo;συμπλέγματος&rdquo; python+nornir+napalm+netmiko (ή κάποιας light παραλλαγής αυτού). Αυτά τα δύο είναι σε κάποιο βαθμό &ldquo;ισοδύναμα&rdquo; ως προς τις δυνατότητές τους.</p>
<h1 id="python-libraries">Python Libraries</h1>
<p>Αν δεν είσαι εξοικιωμένος με τα libraries που αναφέρω, έχουμε και λέμε:</p>
<ul>
<li>Νornir: python library που αναλαμβάνει τα κομμάτια του inventory και του παραλληλισμού tasks. Και τα δύο είναι ενσωματωμένα στην Ansible (<em>Επίσης το Nornir είναι framework, όχι απλά ένα connection library και δεν διαθέτει το ίδιο connection provider αλλά χρησιμοποιεί plugins γι αυτό το σκοπό</em>)</li>
<li>NAPALM: άλλο library που αναλαμβάνει την επικοινωνία με τα διάφορα devices. Επιπλέον, έχει την δυνατότητα να επιστρέψει structured data (JSON, dict) όπως λχ τα network resource modules της Ansible.</li>
<li>Netmiko: τρίτο library που &ldquo;ξέρει&rdquo; πώς να συνδέεται με SSH σε legacy devices και να τραβάει data. Με λίγο φαντασία, μοιάζει με το &ldquo;network_cli&rdquo; connection της Ansible.</li>
</ul>
<h1 id="τομείς-σύγκρισης">Τομείς Σύγκρισης</h1>
<p>Τέλος, η σύγκριση που αναφέρεις γίνεται στο 99% των περιπτώσεων για έναν από τους τέσσερις παρακάτω λόγους:</p>
<ul>
<li>Speed: η Ansible για έναν πολύ μεγάλο αριθμό περιπτώσεων είναι αργή όσο optimization και να κάνεις. Αντίθετα, με τον συνδυασμό Python/Nornir μπορείς να πετύχεις μέχρι και 10x ταχύτητα. [Python-Ansible 1-0]</li>
<li>Learning curve: για κάποιον που προέρχεται από παραδοσιακό networking background, είθισται να προτείνεται η Ansible καθώς είναι πολύ πιο απλή για κάποιον που δεν έχει εμπειρία στον προγραμματισμό. [Python-Ansible 1-1]</li>
<li>Readability: για projects σχετικά μικρής πολυπλοκότητας, η ευκολία της Ansible της δίνει σημαντικό προβάδισμα. Όσο όμως ανεβαίνει η πολυπλοκότητα, τόσο η ζυγαριά δείχνει προς την πλευρά της Python. [Python-Ansible 2-2]</li>
<li>Extensibility: από ένα επίπεδο εμπειρίας και πέρα, όταν η πολυπλοκότητα των tasks που καλούμαστε να επιλύσουμε ανεβαίνει, η domain-specific language (DSL) που χρησιμοποιεί η Ansible καταλήγει να είναι εμπόδιο. Αντίθετα, η πληθώρα μηχανισμών που διαθέτει μια proper language όπως η Python μπορεί να σου λύσει τα χέρια.</li>
</ul>
<h1 id="τελικό-αποτέλεσμα">Τελικό αποτέλεσμα</h1>
<p><em><strong>[Python-Ansible 3-2 με γκολ στο 90&rsquo;]</strong></em></p>
]]></content>
        </item>
        
        <item>
            <title>Introduction to jinja2</title>
            <link>https://netautogr.github.io/posts/2021/12/introduction-to-jinja2/</link>
            <pubDate>Wed, 08 Dec 2021 17:28:27 +0200</pubDate>
            
            <guid>https://netautogr.github.io/posts/2021/12/introduction-to-jinja2/</guid>
            <description>Γενικά Ο σκοπός του παρόντος άρθρου είναι να φέρει τον αναγνώστη σε μια πρώτη επαφή με τη Jinja2 και τις εφαρμογές της.
Τι είναι η Jinja2 Η Jinja2 είναι γλώσσα για μια γρήγορη, εκφραστική και επεκτάσιμη μηχανή προτύπων (templating engine) γραμμένη σε καθαρό python. Τα ειδικά σύμβολα θέσης στο πρότυπο επιτρέπουν την σύνταξη κώδικα παρόμοιου με την σύνταξη της Python και χρησιμοποιείται για την δημιουργία HTML,XML και άλλων γλωσσών σήμανσης (markup language).</description>
            <content type="html"><![CDATA[<h1 id="γενικά">Γενικά</h1>
<p>Ο σκοπός του παρόντος άρθρου είναι να φέρει τον αναγνώστη σε μια πρώτη επαφή με τη Jinja2 και τις εφαρμογές της.</p>
<h1 id="τι-είναι-η-jinja2">Τι είναι η Jinja2</h1>
<p>Η Jinja2 είναι γλώσσα για μια γρήγορη, εκφραστική και επεκτάσιμη μηχανή προτύπων (templating engine) γραμμένη σε καθαρό python.
Τα ειδικά σύμβολα θέσης στο πρότυπο επιτρέπουν την σύνταξη κώδικα παρόμοιου με την σύνταξη της Python και χρησιμοποιείται για την δημιουργία HTML,XML και άλλων γλωσσών σήμανσης (markup language).</p>
<p>Η πρώτη δημόσια έκδοση της Jinja έγινε το 2008, και από τότε έχουν γίνει αρκετές ενημερώσεις.
Η δημιουργία της Jinja2 έχει εμπνευστεί από την built-in μηχανή προτύπων της Django , και έχει δανειστεί έννοιες και από άλλες μηχανές προτύπων (όπως JSPs).
Είναι ευρέως διαδεδομένη και χρησιμοποιείται πολύ από το community της Python αλλά και στους αυτοματισμούς μέσω Ansible.</p>
<h1 id="γιατί-να-τη-χρησιμοποιήσω--γιατί-πρέπει-να-με-ενδιαφέρει">Γιατί να τη χρησιμοποιήσω / Γιατί πρέπει να με ενδιαφέρει;</h1>
<p>Πολλά Web Frameworks (<em>όπως Flask &amp; Django</em>) αλλά και Automation Frameworks (<em>όπως Ansible &amp; Salt</em>) υποστηρίζουν εγγενώς τη Jinja2.
Επίσης αν γνωρίζετε τη Jinja2 τότε θα είναι αρκετά εύκολο να καταλάβετε και άλλες templating languages όπως τη VTL (υποστηρίζεται σε εργαλεία διαχείρισης όπως τα Cisco Prime Infrastructure &amp; DNA Center) με πολύ σημαντικές εφαρμογές!</p>
<p>Κάποιες από τις δυνατότητες της Jinja είναι :</p>
<ul>
<li>Κληρονομικότητα και συμπερίληψη προτύπων.</li>
<li>Ορισμό και εισαγωγή μακροεντολών σε πρότυπα.</li>
<li>Τα πρότυπα HTML μπορούν να χρησιμοποιήσουν autoescaping για να αποτρέψουν την χρήση XSS (<em>Cross Site Scripting</em>) από αναξιόπιστες εισαγωγές από χρήστες.</li>
<li>Περιβάλλον sandbox, ώστε να γίνει η απόδοση των προτύπων τα οποία θεωρούνται αναξιόπιστα με ασφαλή τρόπο.</li>
<li>Υποστήριξη async για την δημιουργία προτύπων που χειρίζονται αυτόματές λειτουργείες sync/async χωρίς επιπλέον σύνταξη.</li>
<li>Τα πρότυπα μεταγλωττίζονται σε βελτιστοποιημένο κώδικα έγκαιρα και αποθηκεύονται προσωρινά(cached),ή μπορούν να μεταγλωττιστούν εκ των προτέρων.</li>
<li>Εφαρμογή εξαιρέσεων οι οποίες υποδεικνύουν την σωστή γραμμή στα πρότυπα για να διευκολύνουν τον εντοπισμό σφαλμάτων.</li>
<li>Επεκτάσιμα φίλτρα, δοκιμές, συναρτήσεις αλλά και σύνταξη.</li>
<li>Υποστήριξη δομών ελέγχου (<em>loops &amp; conditionals</em>).</li>
<li>Εισαγωγή δεδομένων από εξωτερικές πηγές.</li>
</ul>
<h1 id="jinja2-και-automation">Jinja2 και Automation</h1>
<p>Στον τομέα του αυτοματισμού όπου ένα περιβάλλον περιλαμβάνει πολλούς server/δικτυακές συσκευές όπου οι ρυθμίσεις είναι διαφορετικές, η δημιουργία στατικών αρχείων ρυθμίσεων για κάθε ένα από αυτά τα στοιχεία, μπορεί να αποδειχθεί ανιαρή και επαναλαμβανόμενη, με αποτέλεσμα την «σπατάλη» πολύτιμου χρόνου και ενέργειας.
Επίσης η προτυποποίηση των ενεργειών και των σχετικών ρυθμίσεων είναι επιθυμητή ώστε να αποφεύγονται ενδεχόμενα σφάλματα που προκαλούνται από ανθρώπινα λάθη κατά την επανάληψη.</p>
<p>Το αποτέλεσμα της κλήσης της jinja2 engine με βάση το template και τα data μπορεί να είναι HTML, JSON, XML, ή οτιδήποτε χρησιμοποιεί καθαρό κείμενο για κωδικοποίηση, συνεπώς ακόμη και κείμενο network configuration (π.χ. <em>Cisco IOS</em> ή οτιδήποτε παρόμοιο).</p>
<p>Σημαντικό είναι να αναφέρουμε ότι ειδικά σε συνδυασμό με WEB Frameworks, η Jinja2 μπορεί να παίξει πολύ επιτυχημένα το ρόλο του Template Engine στο archicture MTV - Model/Template/View (επίσης γνωστό ως MVC - Model, View, Controller), το οποίο είναι πολύ σημαντικό να κατανοήσει όποιος θέλει να ασχοληθεί με NetDevOps &amp; Network Programmability, καθώς χρησιμοποιείται ευρέως.
Ο συσχετισμός είναι αυτονότητος αν δει κανείς τη χρήση της Jinja2 με το Flask framework, το οποίο δεν επιβάλει βαριά δομή στον προγραμματιστή.</p>
<h1 id="απλές-χρήσεις">Απλές χρήσεις</h1>
<h2 id="αντικατάσταση-μεταβλητών">Αντικατάσταση μεταβλητών</h2>
<p>Τα πρότυπα Jinja2 είναι απλά αρχεία προτύπων (<em>templates</em>) που αποθηκεύουν μεταβλητές που μπορούν να αλλάζουν από καιρό σε καιρό.
Τα πρότυπα αυτά γίνονται <em>rendered</em> με τη χρήση των μεταβλητών και παράγουν τελικές μορφές κειμένου οι οποίες χρησιμοποιούνται στις ρυθμίσεις.
Οι μεταβλητές μπορεί να είναι απλές ή σύνθετες π.χ. dictionaries, ή ακόμα και να προέρχονται από εξωτερικές πηγές, με ή χωρίς χρήση φίλτρων.</p>
<h2 id="αντικατάσταση-υπό-συνθήκη-και-επαναλήψεις">Αντικατάσταση υπό συνθήκη και Επαναλήψεις</h2>
<p>Πέραν της αντικατάστασης των τιμών των μεταβλητών, η Jinja2 υποστηρίζει δομές ελέγχου για την υπό συνθήκη χρήση συγκεκριμένων κομματιών των προτύπων ανάλογα με την τιμή μεταβλητών ή ακόμα και επανάληψης για αντικατάσταση ομάδων μεταβλητών και επανάληψης των σχετικών τμημάτων κειμένου στις ρυθμίσεις με τις τιμές των μεταβλητών, χωρίς να χρειαστεί να γίνει αυτή η επανάληψη στο &ldquo;εργαλείο&rdquo; που καλεί την Jinja (π.χ. μια γλώσσα προγραμματισμού όπως η Python)
Οι δομές ελέγχου κλείνονται μέσα σε blocks των χαρακτήρων <code>{%</code> και <code>%}</code></p>
<h2 id="συνδυασμός-με-python">Συνδυασμός με Python</h2>
<p>H Jinja2 engine είναι διαθέσιμη ως πακέτο Python μέσω του Pypi: <a href="https://pypi.org/project/Jinja2/">https://pypi.org/project/Jinja2/</a>
Στο σύνδεσμο <a href="https://palletsprojects.com/p/jinja/">https://palletsprojects.com/p/jinja/</a> βρίσκει κανείς το σχετικό homesite και σύνδεσμο για την τεκμηρίωση <a href="https://jinja.palletsprojects.com/en/3.0.x/">https://jinja.palletsprojects.com/en/3.0.x/</a>.
Ίσως το πιο συχνό στοιχείο χρήσης της βιβλιοθήκης jinja2 είναι το template (ορισμός προτύπου) και η render function (παραγωγή αποτελέσματος).
Μέσω της χρήσης της Jinja2 εντός Python προκύπτουν πολύ ενδιαφέροντες συνδυασμοί λόγω της ευρείας χρήσης της Python, ειδικά όταν γίνεται συνδυασμός βιβλιοθηκών και APIs, δομών ελέγχου και δομών δεδομένων, που είναι από τα μεγάλα πλεονεκτήματα της συγκεκριμένης γλώσσας. Η χρήση των προτύπων της jinja2 και του jinja2 engine σε αυτές τις περιπτώσεις ολοκληρώνουν μια παλέτα από εξαιρετικά εργαλεία για παραγωγή καθαρού και ευέλικτου κώδικα σε μεγάλο πεδίο εφαρμογών.</p>
<p>Υπάρχουν ακόμη όμως και πολύ ειδικές περιπτώσεις συνδυασμών, όπως η χρήση Ansible jinja2 filters στην python:
<a href="https://gist.github.com/ktbyers/bdba984447636d5ac4e3d93011a861ad">https://gist.github.com/ktbyers/bdba984447636d5ac4e3d93011a861ad</a>
Περισσότερα στα παραδείγματα για Python πιο κάτω.</p>
<h2 id="συνδυασμός-με-ansible">Συνδυασμός με Ansible</h2>
<p>To Ansible χρησιμοποιεί τη Jinja2 για να δώσει τη δυνατότητα για δυναμικές εκφράσεις και πρόσβαση στις μεταβλητές του (<em>variables</em>) και τα δεδομένα που παράγονται (<em>facts</em>).
Μπορούμε να χρησιμοποιήσουμε το template module για να εφαρμόσουμε πρότυπα στο Ansible Configuration, να χρησιμοποιήσουμε απευθείας templating σε playbooks για task names κλπ, μπορούμε να χρησιμοποιήσουμε standard filters και tests της Jinja2. Μπορούμε τέλος να χρησιμοποιήσουμε lookup plugins για να ανακτήσουμε δεδομένα από εξωτερικές πηγές όπως αρχεία, APIs, βάσεις δεδομένων κλπ για χρήση στα templates <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_templating.html">https://docs.ansible.com/ansible/latest/user_guide/playbooks_templating.html</a> .</p>
<p>H πιο απλή χρήση είναι η αντικατάσταση μεταβλητών. Όταν εκτελούνται τα Playbooks, αυτές οι μεταβλητές αντικαθίστανται από πραγματικές τιμές, οι πηγές των οποίων ορίζονται δυναμικά. Με αυτόν τον τρόπο, το πρότυπο προσφέρει μια αποτελεσματική και ευέλικτη λύση για τη δημιουργία ή την προσαρμογή του αρχείου διαμόρφωσης σε διαφορετικά δεδομένα εισόδου με ευκολία.</p>
<p>Προφανώς η υποστήριξη και μόνο της Jinja2 εγγενώς στο Ansible, δίνει ήδη μεγάλες δυνατότητες. Ειδικά για το Network Automation, έχει ιδιαίτερο ενδιαφέρον ο συνδυασμός των εξειδικευμένων Ansible modules για network operations &amp; configuration με τη Jinja2, τόσο για τις αντικαταστάσεις τιμών δεδομένων, όσο και για την εισαγωγή από άλλες πηγές, όσο και τα jinja2 filters.
Ωστόσο όσο αυξάνεται η πολυπλοκότητα των συνδυασμών, γίνεται προφανές ότι ίσως άλλες λύσεις (π.χ. Jinja2 with Python Vs Ansible) είναι προτιμότερες για network automation, όταν χρειάζεται εφαρμογή πολύπλοκης λογικής και εξειδικευμένους τρόπους χειρισμού δεδομένων από και προς το &ldquo;δίκτυο&rdquo;.
Περισσότερα παρακάτω στο ξεχωριστό τμήμα του κειμένου για τα παραδείγματα.</p>
<h2 id="συνδυασμός-με-htmlcss--web-frameworks">Συνδυασμός με HTML/CSS &amp; Web Frameworks</h2>
<p>Η χρήση της Jinja2, όσο αφορά τον <em>κώδικα</em> που εμπλέκεται σε Web Sites, έχει προφανώς να κάνει αρχικά με την αντικατάσταση κειμένου και προεκτείνεται με την ενσωμάτωση λογικών δομών στο πρότυπο. Τα οφέλη δεν περιορίζονται σε απλές δυναμικές σελίδες HTML αλλά ακόμα και στη δυναμική διαμόρφωση και τροφοδοσία REST APIs.
Το παρακάτω παράδειγμα δείχνει πως η Jinja2 μπορεί να διαμορφώσει τον τελικό HTML κώδικα μιας σελίδας
(<em>Τα επόμενα παραδείγματα αποτελούν αναδημοσίευση από <a href="https://www.codecademy.com/learn/learn-flask/">https://www.codecademy.com/learn/learn-flask/</a></em>)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html"><span style="color:#75715e">&lt;!DOCTYPE html&gt;</span>
&lt;<span style="color:#f92672">html</span> <span style="color:#a6e22e">lang</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;en&#34;</span>&gt;
&lt;<span style="color:#f92672">head</span>&gt;
    &lt;<span style="color:#f92672">title</span>&gt;My Webpage&lt;/<span style="color:#f92672">title</span>&gt;
&lt;/<span style="color:#f92672">head</span>&gt;
&lt;<span style="color:#f92672">body</span>&gt;
    &lt;<span style="color:#f92672">ul</span> <span style="color:#a6e22e">id</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;navigation&#34;</span>&gt;
    {% for item in navigation %}
        &lt;<span style="color:#f92672">li</span>&gt;&lt;<span style="color:#f92672">a</span> <span style="color:#a6e22e">href</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;{{ item.href }}&#34;</span>&gt;{{ item.caption }}&lt;/<span style="color:#f92672">a</span>&gt;&lt;/<span style="color:#f92672">li</span>&gt;
    {% endfor %}
    &lt;/<span style="color:#f92672">ul</span>&gt;

    &lt;<span style="color:#f92672">h1</span>&gt;My Webpage&lt;/<span style="color:#f92672">h1</span>&gt;
    {{ a_variable }}

    {# a comment #}
&lt;/<span style="color:#f92672">body</span>&gt;
&lt;/<span style="color:#f92672">html</span>&gt;
</code></pre></div><p>Στην περίπτωση των web frameworks που ενσωματώνουν υποστήριξη για τη Jinja2, τα templates αναδεικνύονται σε μέρος του tool ecosystem και μεγιστοποιούν το κέρδος από τη χρήση τους.
Ειδικά στην περίπτωση του Flask, η Jinja2 είναι η εξ ορισμού templating engine για αυτό.
Η χρήση της μπορεί να είναι εξαιρετικά απλή, π.χ.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#a6e22e">@app.route</span>(<span style="color:#e6db74">&#39;/&#39;</span>)
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">index</span>():
    <span style="color:#66d9ef">return</span> render_template(<span style="color:#e6db74">&#34;index.html&#34;</span>)
</code></pre></div><p>ή με παραμέτρους (<em>realpython.com/primer-on-jinja-templating/</em>):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#a6e22e">@app.route</span>(<span style="color:#e6db74">&#34;/&#34;</span>)
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">templ1</span>():
    <span style="color:#66d9ef">return</span> render_template(<span style="color:#e6db74">&#39;template.html&#39;</span>, my_string<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;This is my list:&#34;</span>, my_list<span style="color:#f92672">=</span>[<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">5</span>])
</code></pre></div><p>Το πρότυπο μπορεί να χρησιμοποιεί φίλτρα, π.χ.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html"><span style="color:#75715e">&lt;!-- Capitalize the string --&gt;</span>
&lt;<span style="color:#f92672">h1</span>&gt;{{ heading_var | upper  }}&lt;/<span style="color:#f92672">h1</span>&gt;
 
<span style="color:#75715e">&lt;!-- Default string when 
</span><span style="color:#75715e">no_var not declared --&gt;</span>
&lt;<span style="color:#f92672">h1</span>&gt;{{ no_var | default(&#34;My Website&#34;) }}&lt;/<span style="color:#f92672">h1</span>&gt;
</code></pre></div><p>ή δομές ελέγχου όπως if-then-else για να επιλεχθούν οι τιμές που θα αντικαταστήσουν τα πρότυπα στον κώδικα HTML, π.χ.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">&lt;<span style="color:#f92672">html</span>&gt;
  &lt;<span style="color:#f92672">body</span>&gt;
    &lt;<span style="color:#f92672">h1</span>&gt;
      {% if template_feel == &#39;happy&#39; %}
        This Page Is Happy
      {% elif template_feel == &#39;sad&#39; %}
        This Page Is Sad
      {% else %}
        This Page Is Not Sure How It Feels
      {% endfor %}
    &lt;/<span style="color:#f92672">h1</span>&gt;
  &lt;/<span style="color:#f92672">body</span>&gt;
&lt;/<span style="color:#f92672">html</span>&gt;
</code></pre></div><p>ή επαναληπτικές δομές for, όπως για την δημιουργία λιστών, π.χ.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">&lt;<span style="color:#f92672">ul</span>&gt;
  {% for content_item in content_list %}
    &lt;<span style="color:#f92672">li</span>&gt;content_item&lt;/<span style="color:#f92672">li</span>&gt;
  {% endfor %}
&lt;/<span style="color:#f92672">ul</span>&gt;
</code></pre></div><p>Μπορεί ακόμα να ενσωματώνονται εντελώς στον κώδικα Flask και να υποστηρίζουν εξειδικευμένα αντικείμενα, όπως το <em>url_for</em>, το οποίο επιτρέπει την αποφυγή των hardcoded links και άρα την διατήρηση της ανεξαρτησίας μεταξύ των στοιχείων της αρχιτεκτονικής MTV, π.χ.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">&lt;<span style="color:#f92672">a</span> <span style="color:#a6e22e">href</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;{{ url_for(&#39;index&#39;) }}&#34;</span>&gt;Link To Index&lt;/<span style="color:#f92672">a</span>&gt;
 
&lt;<span style="color:#f92672">a</span> <span style="color:#a6e22e">href</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;{{ url_for(&#39;another_route&#39;, route_var=some_template_var) }}&#34;</span>&gt;Another Route With Variable&lt;/<span style="color:#f92672">a</span>&gt;
</code></pre></div><h2 id="συνδυασμός-με-python-για-network-configuration">Συνδυασμός με Python για Network Configuration</h2>
<p>Πρόκειται για ειδικό συνδυασμό, καθώς το αποτέλεσμα είναι το επιθυμητό network configuration, η παραγωγή του οποίου μπορεί απλά να γίνει πιο εύκολη με τη χρήση της Jinja, ή ακόμα και να δώσει τη δυνατότητα για τη χρήση custom models ανεξάρτητων από τον κώδικα, χωρίς τη χρήση YANG Data Models.
Φυσικά, η βασική λογική της χρήσης της Jinja2 στο Python δεν αλλάζει απλά επειδή αλλάζει ο σκοπός ή η εφαρμογή, αλλά και πάλι οι δυνατότητες συνδυασμών είναι τέτοιες που οδηγούν σε ενδιαφέροντα αποτελέσματα.
Περισσότερα παρακάτω στο ξεχωριστό τμήμα του κειμένου για τα παραδείγματα.</p>
<h1 id="εγκατάσταση-jinja2">Εγκατάσταση Jinja2</h1>
<p>Η εγκατάσταση/ενημέρωση της Jinja2 μέσω python package είναι πολύ απλή και μπορεί να γίνει με την χρήση του pip:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ pip install -U jinja2
</code></pre></div><p>Όπως αναφέρουν συχνά άρθρα που παρουσιάζουν την Jinja2, η κατανόηση γίνεται πιο εύκολη παρατηρώντας παραδείγματα.</p>
<h1 id="παραδείγματα">Παραδείγματα</h1>
<p>(<em>Τα επόμενα παραδείγματα αναδημοσιεύονται από το <a href="https://realpython.com/primer-on-jinja-templating/">https://realpython.com/primer-on-jinja-templating/</a></em>)</p>
<h2 id="παράδειγμα-με-python-1">Παράδειγμα με Python (1)</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">&gt;&gt;&gt;</span> <span style="color:#f92672">from</span> jinja2 <span style="color:#f92672">import</span> Template
<span style="color:#f92672">&gt;&gt;&gt;</span> t <span style="color:#f92672">=</span> Template(<span style="color:#e6db74">&#34;Hello {{ something }}!&#34;</span>)
<span style="color:#f92672">&gt;&gt;&gt;</span> t<span style="color:#f92672">.</span>render(something<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;World&#34;</span>)
<span style="color:#e6db74">&#39;Hello World!&#39;</span>
</code></pre></div><h2 id="παράδειγμα-με-python-2">Παράδειγμα με Python (2)</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">&gt;&gt;&gt;</span> t <span style="color:#f92672">=</span> Template(<span style="color:#e6db74">&#34;My favorite numbers: {</span><span style="color:#e6db74">% f</span><span style="color:#e6db74">or n in range(1,10) %}{{n}} &#34;</span> <span style="color:#e6db74">&#34;{</span><span style="color:#e6db74">% e</span><span style="color:#e6db74">ndfor %}&#34;</span>)
<span style="color:#f92672">&gt;&gt;&gt;</span> t<span style="color:#f92672">.</span>render()
<span style="color:#e6db74">&#39;My favorite numbers: 1 2 3 4 5 6 7 8 9 &#39;</span>
</code></pre></div><h2 id="παράδειγμα-network-automation-με-ansible">Παράδειγμα Network Automation με Ansible</h2>
<p>(<em>Τα επόμενα παραδείγματα αναδημοσιεύονται από το ansible.github.io</em>)
Στο επόμενο παράδειγμα θα χρησιμοποιήσουμε Ansible Variables για να αποθηκεύσουμε τις IP διευθύνσεις δύο router. Θα χρησιμοποιήσουμε επίσης το Jinja2 lookup plugin , το οποίο θα μας μας επιτρέψει να δημιουργήσουμε ένα πρότυπο διαμόρφωσης συσκευής. Δεν αναφέρονται πλήρη playbook και κώδικας, τα οποία είναι διαθέσιμα στις πηγές του άρθρου αλλά παρουσιάζεται και επεξηγείται η λογική.</p>
<p>Θα χρησιμοποιήσουμε το παρακάτω IP schema για να δηλώσουμε IP διευθύνσεις στην Loopback1 στο rtr1 και rtr2 :</p>
<table>
<thead>
<tr>
<th>Device</th>
<th>Lo1 IP address</th>
</tr>
</thead>
<tbody>
<tr>
<td>r1</td>
<td>192.168.1.1/32</td>
</tr>
<tr>
<td>r2</td>
<td>192.168.1.2/32</td>
</tr>
</tbody>
</table>
<p>Οι μεταβλητές μπορούν δηλωθούν στον φάκελο host_vars η στο group_vars.
Tα interfaces αλλά και οι IP πρέπει να αποθηκευτούν ως μεταβλητές. Tο περιεχόμενου του YAML αρχείου θα δημιουργηθεί ώς εξής:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#66d9ef">nodes</span>:
    <span style="color:#66d9ef">r1</span>:
        <span style="color:#66d9ef">Loopback1</span>: <span style="color:#e6db74">&#34;192.168.1.1&#34;</span>
    <span style="color:#66d9ef">r2</span>:
        <span style="color:#66d9ef">Loopback1</span>: <span style="color:#e6db74">&#34;192.168.1.2&#34;</span>
</code></pre></div><p>Το παραπάνω είναι στην ουσία μια δομή nested dictionary με εσωτερικά keys τα ονόματα των interfaces και values τις ip addresses που θέλουμε να ορίσουμε.</p>
<p>To αρχείου template.j2 έχει τα παρακάτω περιεχόμενα:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-jinja" data-lang="jinja"><span style="color:#75715e">{%</span> <span style="color:#66d9ef">for</span> interface<span style="color:#f92672">,</span>ip <span style="color:#66d9ef">in</span> nodes<span style="color:#f92672">[</span>inventory_hostname<span style="color:#f92672">]</span>.items<span style="color:#f92672">()</span> <span style="color:#75715e">%}</span>
interface <span style="color:#75715e">{{</span>interface<span style="color:#75715e">}}</span>
  ip address <span style="color:#75715e">{{</span>ip<span style="color:#75715e">}}</span> 255.255.255.255
<span style="color:#75715e">{%</span> <span style="color:#66d9ef">endfor</span> <span style="color:#75715e">%}</span>
</code></pre></div><p>Ο παραπάνω κώδικας εξηγείται ως εξής.</p>
<ul>
<li>Ο κώδικας για να ορίσουμε τη δομή ελέγχου για το Jinja πρότυπο αρχίζει με <code>{%</code> και τελειώνει με  <code>%}</code>.  Γίνεται reference του  dictionary με όνομα nodes και χρησιμοποιούνται ως key,value pairs τα inventory_hostnames σαν keys και τα σχετικά values. Ορίζεται στο loop ότι το ρόλο του key θα παίζει η μεταβλητή <code>interface</code> και το ρόλο του value η μεταβλητή <code>ip</code>.</li>
<li>Το nodes[inventory_hostname] προκαλεί την αναζήτηση του dictionary στο αρχείο group_vars/all.yml (default). Το όνομα inventory_hostname είναι το όνομα του hostname όπως αυτό έχει οριστεί στο host file της Ansible. Όταν το playbook εκτελεστεί για τον host r1 το inventory_hostname θα πάρει την τιμή r1, και αντιστοίχως για το r2.</li>
<li>Το στοιχείο items() επιστρέφει μια λίστα με λεξικά(dictionaries). Στην περίπτωση του παραδείγματος μας επιστρέφει τα κλειδιά(keys) του interface name (πχ Loopback1) και την τιμή(value) της IP address (πχ 192.168.1.1)</li>
<li>Οι μεταβλητές αποδίδονται μέσα σε άγκιστρα <code>{ }</code> . Αυτές οι δύο μεταβλητές ορίζονται και «υπάρχουν» μόνο μέσα στην for loop. Κάθε επανάληψη της for loop θα κάνει εκ νέου ανάθεση των τιμών των μεταβλητών.</li>
<li>To loop τελειώνει με το <code>{% endfor %}</code></li>
</ul>
<p>Θα δημιουργήσουμε το Ansible playbook με όνομα config.yml με το παρακάτω περιεχόμενο:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">---
- <span style="color:#66d9ef">name</span>: configure network devices
  <span style="color:#66d9ef">hosts</span>: r1,r2
  <span style="color:#66d9ef">gather_facts</span>: <span style="color:#66d9ef">false</span>
  <span style="color:#66d9ef">tasks</span>:
    - <span style="color:#66d9ef">name</span>: configure device with config
      <span style="color:#66d9ef">cli_config</span>:
        <span style="color:#66d9ef">config</span>: <span style="color:#e6db74">&#34;{{ lookup(&#39;template&#39;, &#39;template.j2&#39;) }}&#34;</span>
</code></pre></div><p>Το κομμάτι που αφορά το Jinja2 είναι το τελευταίο στο οποίο ορίζονται δύο παράμετροι. Το plugin type με όνομα template και το template name το οποίο είναι το αρχείο template που δημιουργήσαμε προηγουμένως template.j2.</p>
<p>Αν εκτελέσουμε το Ansible Playbook</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ansible-playbook config.yml
</code></pre></div><p>το αποτέλεσμα φαίνεται παρακάτω :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">PLAY <span style="color:#f92672">[</span>rtr1,rtr2<span style="color:#f92672">]</span> ********************************************************************************
	 
TASK <span style="color:#f92672">[</span>configure device with config<span style="color:#f92672">]</span> ********************************************************************************
changed: <span style="color:#f92672">[</span>rtr1<span style="color:#f92672">]</span>
changed: <span style="color:#f92672">[</span>rtr2<span style="color:#f92672">]</span>
	 
PLAY RECAP ********************************************************************************
rtr1                       : ok<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>    changed<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>    unreachable<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>    failed<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>    skipped<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>    rescued<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>    ignored<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>
rtr2                       : ok<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>    changed<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>    unreachable<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>    failed<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>    skipped<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>    rescued<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>    ignored<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span> 
</code></pre></div><h2 id="παράδειγμα-για-network-automation-με-python">Παράδειγμα για Network Automation με Python</h2>
<h3 id="αντικατάσταση-μεταβλητών-1">Αντικατάσταση μεταβλητών</h3>
<p>(<em>Τα επόμενα παραδείγματα αναδημοσιεύονται από το blog του Przemek Rogala <a href="https://ttl255.com/">https://ttl255.com/</a></em>)
Ας πούμε ότι θέλουμε να παράγουμε ένα κομμάτι configuration για ένα device που είναι διαχειρίσιμο μέσω CLI, και καθαρού text. Στην περίπτωση των παραδειγμάτων παρακάτω, τα devices είναι Cisco Network Devices και ο τρόπος μεταφοράς του configuration υποθετικά είναι το netmiko, ωστόσο θα μπορούσε καθένα από αυτά τα συστατικά (vendor, CLI provider) να διαφέρει, χωρίς να αλλάζει το βασικό νόημα.
Έστω ότι ο στόχος για το configuration text είναι το παρακάτω, με το ζητούμενο να είναι να μπορούμε να αλλάξουμε τις παραμέτρους (ntp server ip addresses) χωρίς να αλλάξουμε το υπόλοιπο πρότυπο.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">ntp server <span style="color:#ae81ff">10.1.1.20</span> prefer
ntp server <span style="color:#ae81ff">10.1.1.21</span>
</code></pre></div><p>To template θα μπορούσε να είναι απλά κάπως έτσι:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-jinja" data-lang="jinja">ntp server <span style="color:#75715e">{{</span> ntp_server_pri <span style="color:#75715e">}}</span> prefer
ntp server <span style="color:#75715e">{{</span> ntp_server_sec <span style="color:#75715e">}}</span>
</code></pre></div><p>Ένα python script που θα χρησιμοποιήσει το template θα μπορούσε να είναι το παρακάτω:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> jinja2 <span style="color:#f92672">import</span> Template

template <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">ntp server {{ ntp_server_pri }} prefer
</span><span style="color:#e6db74">ntp server {{ ntp_server_sec }}
</span><span style="color:#e6db74">&#34;&#34;&#34;</span>

data <span style="color:#f92672">=</span> {
    <span style="color:#e6db74">&#34;ntp_server_pri&#34;</span>: <span style="color:#e6db74">&#34;10.1.1.20&#34;</span>,
    <span style="color:#e6db74">&#34;ntp_server_sec&#34;</span>: <span style="color:#e6db74">&#34;10.1.1.21&#34;</span>,
}

j2_template <span style="color:#f92672">=</span> Template(template)
<span style="color:#66d9ef">print</span>(j2_template<span style="color:#f92672">.</span>render(data))
</code></pre></div><h3 id="χρήση-μεταβλητών-από-dictionaries">Χρήση μεταβλητών από dictionaries</h3>
<p>Έστω ότι παρόμοια με την προηγούμενη περίπτωση θέλουμε να χρησιμοποιήσουμε dictionaries για τα δεδομένα όπως παρακάτω για τη διαμόρφωση interfaces:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#f92672">&#34;interface&#34;</span>: {
    <span style="color:#f92672">&#34;name&#34;</span>: <span style="color:#e6db74">&#34;GigabitEthernet3/15&#34;</span>,
    <span style="color:#f92672">&#34;ip_address&#34;</span>: <span style="color:#e6db74">&#34;10.200.10.1/24&#34;</span>,
    <span style="color:#f92672">&#34;description&#34;</span>: <span style="color:#e6db74">&#34;Server1&#34;</span>,
    <span style="color:#f92672">&#34;speed&#34;</span>: <span style="color:#e6db74">&#34;1000&#34;</span>,
    <span style="color:#f92672">&#34;duplex&#34;</span>: <span style="color:#e6db74">&#34;full&#34;</span>,
  }
}
</code></pre></div><p>Το πρότυπο σε αυτή την περίπτωση θα μπορούσε να είναι όπως παρακάτω.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-jinja" data-lang="jinja">interface <span style="color:#75715e">{{</span> interface.name <span style="color:#75715e">}}</span>
 description <span style="color:#75715e">{{</span> interface.description <span style="color:#75715e">}}</span>
 ip address <span style="color:#75715e">{{</span> interface.ip_address <span style="color:#75715e">}}</span>
 speed <span style="color:#75715e">{{</span> interface.speed <span style="color:#75715e">}}</span>
 duplex <span style="color:#75715e">{{</span> interface.duplex <span style="color:#75715e">}}</span>
</code></pre></div><p>Προφανώς ισχύουν όσα είπαμε για τους συνδυασμούς που προκύπτουν, όπως και για το Ansible, αλλά στην περίπτωση του Python, όπως ήδη είπαμε, οι δυνατότητες συνδυασμών για custom logic και για επεξεργασία δεδομένων (import, process, export) είναι πολύ μεγαλύτερες.</p>
<h1 id="reading-material">Reading Material</h1>
<p>Στην τέχνη του Jinjutsu (δεν υπάρχει, αστειευόμαστε), δύο αληθινοί masters είναι ο Przemek Rogala και o John Cappobianco. Ο πρώτος έχει γράψει μια καταπληκτική σειρά από άρθρα για χρήση της jinja2 σε network automation με Python (<a href="https://ttl255.com/jinja2-tutorial-part-1-introduction-and-variable-substitution/">https://ttl255.com/jinja2-tutorial-part-1-introduction-and-variable-substitution/</a>) και δουλεύει πλέον στην NTC, ενώ ο δεύτερος (<em>Cisco Devnet Create 2021 Award Winner</em>) έχει γράψει το βιβλίο Automate Your Network το οποίο πραγματεύεται τη χρήση της Ansible για Network Automation (<a href="https://www.automateyournetwork.ca/)">https://www.automateyournetwork.ca/)</a>. (Ο John έκτοτε έχει γίνει Python convert και διαπρέπει μεταξύ άλλων στην ανάπτυξη με python του Merlin Open Source Project, στο οποίο έχει κάνει εκτενώς χρήση της Jinja2).</p>
<p>Υπάρχουν επίσης εξαιρετικά online courses που αφιερώνουν μέρος τους στην χρήση της Jinja2 με όλους τους τρόπους που αναφέραμε ήδη, αλλά και το ίδιο το documentation της Jinja.
Μπορείτε να εμβαθύνετε με όποιο τρόπο προτιμάτε ή να ξεκινήσετε από την λίστα των συνδέσμων που παραθέτουμε παρακάτω.</p>
<p>Καλή επιτυχία!</p>
<h1 id="παραπομπές">Παραπομπές</h1>
<ul>
<li><a href="https://github.com/pallets/jinja">https://github.com/pallets/jinja</a></li>
<li><a href="https://jinja.palletsprojects.com/en/3.0.x/intro/">https://jinja.palletsprojects.com/en/3.0.x/intro/</a></li>
<li><a href="https://realpython.com/primer-on-jinja-templating/">https://realpython.com/primer-on-jinja-templating/</a></li>
<li><a href="https://palletsprojects.com/p/jinja/">https://palletsprojects.com/p/jinja/</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_templating.html">https://docs.ansible.com/ansible/latest/user_guide/playbooks_templating.html</a></li>
<li><a href="https://www.linuxtechi.com/configure-use-ansible-jinja2-templates/">https://www.linuxtechi.com/configure-use-ansible-jinja2-templates/</a></li>
<li><a href="https://ansible.github.io/workshops/exercises/ansible_network/4-jinja/">https://ansible.github.io/workshops/exercises/ansible_network/4-jinja/</a></li>
<li><a href="https://ttl255.com/jinja2-tutorial-part-1-introduction-and-variable-substitution/">https://ttl255.com/jinja2-tutorial-part-1-introduction-and-variable-substitution/</a></li>
<li><a href="https://www.automateyournetwork.ca/">https://www.automateyournetwork.ca/</a></li>
<li><a href="https://twitter.com/ttl255/status/1317862708415442945?s=09">https://twitter.com/ttl255/status/1317862708415442945?s=09</a></li>
<li><a href="https://github.com/IPvZero/NETCONF-DMVPN-jinja2/blob/master/templates/eigrp.j2">https://github.com/IPvZero/NETCONF-DMVPN-jinja2/blob/master/templates/eigrp.j2</a></li>
<li><a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_templating.html">https://docs.ansible.com/ansible/latest/user_guide/playbooks_templating.html</a></li>
<li><a href="https://hackersandslackers.com/flask-jinja-templates/">https://hackersandslackers.com/flask-jinja-templates/</a></li>
<li><a href="https://www.youtube.com/watch?v=4yaG-jFfePc&amp;ab_channel=Codemy.com">https://www.youtube.com/watch?v=4yaG-jFfePc&amp;ab_channel=Codemy.com</a></li>
<li><a href="https://medium.com/codex/how-to-serve-html-pages-using-flask-and-jinja-597f0157c298">https://medium.com/codex/how-to-serve-html-pages-using-flask-and-jinja-597f0157c298</a></li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>Introduction to Yang</title>
            <link>https://netautogr.github.io/posts/2021/09/introduction-to-yang/</link>
            <pubDate>Fri, 24 Sep 2021 01:12:57 +0300</pubDate>
            
            <guid>https://netautogr.github.io/posts/2021/09/introduction-to-yang/</guid>
            <description>Γενικά Πριν αρχίσουμε Ας ξεκαθαρίσουμε κάτι από την αρχή. Δεν είναι δυνατό σε ένα άρθρο να πούμε όλα όσα πρέπει να γνωρίζετε για τα Yang Data Models. Ακόμα και ο τίτλος &amp;ldquo;Introduction&amp;rdquo; δεν είναι ακριβής. Πιο σωστός θα ήταν το &amp;ldquo;Σημείο έναρξης για να προσεγγίσετε τα Yang Data Models&amp;rdquo; ή κάτι παρόμοιο. Σε πολλά σημεία παραλείπουμε πληροφορίες. Άλλα σημεία δεν τα αναφέρουμε καθόλου. Ο σκοπός είναι το παρόν άρθρο να είναι εύκολο στην ανάγνωση, να προσφέρει μια περίληψη και ένα σωστό σημείο εκκίνησης, από το οποίο θα μπορέσετε να εξερευνήσετε περισσότερο τα σημεία για τα οποία ενδιαφέρεστε περισσότερο.</description>
            <content type="html"><![CDATA[<h1 id="γενικά">Γενικά</h1>
<h2 id="πριν-αρχίσουμε">Πριν αρχίσουμε</h2>
<p>Ας ξεκαθαρίσουμε κάτι από την αρχή. Δεν είναι δυνατό σε ένα άρθρο να πούμε όλα όσα πρέπει να γνωρίζετε για τα Yang Data Models. Ακόμα και ο τίτλος &ldquo;Introduction&rdquo; δεν είναι ακριβής. Πιο σωστός θα ήταν το &ldquo;Σημείο έναρξης για να προσεγγίσετε τα Yang Data Models&rdquo; ή κάτι παρόμοιο. Σε πολλά σημεία παραλείπουμε πληροφορίες. Άλλα σημεία δεν τα αναφέρουμε καθόλου. Ο σκοπός είναι το παρόν άρθρο να είναι εύκολο στην ανάγνωση, να προσφέρει μια περίληψη και ένα σωστό σημείο εκκίνησης, από το οποίο θα μπορέσετε να εξερευνήσετε περισσότερο τα σημεία για τα οποία ενδιαφέρεστε περισσότερο.
Επίσης για πρακτική εξάσκηση θα πρέπει να αναζήσετε καταλληλότερες πηγές.
Μην ξεχνάτε όμως ότι μπορείτε πάντα να ενταχθείτε στην κοινότητα μας και να αναζητήσετε βοήθεια.</p>
<h2 id="τί-είναι-τα-yang-data-models">Τί είναι τα YANG data models</h2>
<p>To YANG <a href="https://en.wikipedia.org/wiki/YANG">(Yet Another Next Generation)</a> είναι γλώσσα μοντελοποίησης. Πολλές φορές όμως χρησιμοποιούμε τον όρο αναφερόμενοι στα ίδια τα μοντέλα, στα δεδομένα τα οποία αναπαριστώνται με βάση αυτά τα μοντέλα ή τη γλώσσα μοντελοποίησης (Yang data modeling language / Yang data models / Yang data).</p>
<p>Κάποια στιγμή, προέκυψε η ανάγκη της δημιουργίας ενός νέου μοντέλου δεδομένων για τη διαχείριση των δικτυακών συσκευών και των λειτουργιών τους, όπου οι πληροφορίες για την κατάσταση και λειτουργικότητα των συσκευών (operational data) θα ήταν ξέχωρα από τις πληροφορίες για τη ρύθμιση τους (configuration data), όπου τα μοντέλα θα ήταν επεκτάσιμα και καλύτερα δομημένα, η μετάδοση θα ήταν ασφαλής (με χρήση κρυπτογράφησης) και αξιόπιστη (over TCP) και η χρήση των καναλιών μεταφοράς βελτιστοποιημένη, δηλαδή ότι δεν ήταν το SNMP και το αντίστοιχο μοντέλο δεδομένων, το <a href="https://www.iana.org/assignments/smi-numbers/smi-numbers.xhtml">SMI</a>.</p>
<p>To YANG σαν modeling language έδωσε επίσης τη δυνατότητα για δομές όχι αυστηρά δεδροειδείς αλλά με δυνατότητες για εισαγωγή άλλων μοντέλων (π.χ. interface &lt;-&gt; mac address &amp; ipv4 address) με πολλαπλούς τρόπους (π.χ. augmentation/deviation)</p>
<h2 id="χρησιμότητα">Χρησιμότητα</h2>
<h3 id="configoperational">Config/Operational</h3>
<p>Η επικρατούσα αντίληψη είναι πως τα <a href="https://github.com/YangModels/yang">YANG Data models</a> και τα σχετικά εργαλεία και συστατικά χρησιμοποιούνται για το configuration των δικτυακών συσκευών και υπηρεσιών, ενώ για το monitoring της υγείας και απόδοσης συσκευών και λειτουργιών συνεχίζει κανείς να χρησιμοποιεί το SNMP. Η πραγματικότητα είναι πως υπάρχουν μοντέλα YANG τα οποία επιτελούν και το σκοπό της παρακολούθησης και τα οποία συχνά έχουν το επίθεμα <em><strong>oper</strong></em>.</p>
<h3 id="telemetrystreamingonchange">Telemetry/Streaming/OnChange</h3>
<p>Με αυτό το σκεπτικό υπάρχουν αρκετές περιπτώσεις όπου η χρήση model driven παρακολούθησης για το δίκτυο και τις δικτυακές συσκευές έχει σημαντικά πλεονεκτήματα, όπως τη δυνατότητα για αποστολή συνεχών ομάδων μετρήσεων από τις ίδιες τις συσκευές σε συνεχόμενο ρυθμό (streaming telemetry) με ελάχιστη επιβάρυνση της απόδοσης των συσκευών. Επίσης οι ίδιες οι συσκευές μπορούν να ειδοποιούν στέλνοντας δεδομένα Yang μόνο όταν υπάρχει αλλαγή στην κατάσταση της συσκευής (<em>on change</em>). Η επιλογή των δεδομένων για την συνεχόμενη εκπομπή μπορεί να γίνει με τη μέθοδο της εγγραφής συνδρομής (subscription)</p>
<h3 id="απευθείας-προγραμματική-πρόσβαση-στα-δεδομένα">Απευθείας προγραμματική πρόσβαση στα δεδομένα</h3>
<p>Ακόμα όμως και εκτός των ορίων του Streaming Telemetry, η δυνατότητα να έχουμε προγραμματική πρόσβαση ανά πάσα στιγμή στις παραμέτρους λειτουργίας του δικτύου χωρίς να μεσολαβεί κάποια μετάφραση (<em>parsing</em> - βλέπετε <a href="https://netautogr.github.io/posts/2021/01/how-to-get-started-with-network-automation/">How to get started with Network Automation</a>) από συνδέσεις κονσόλας μέσω Telnet/SSH, αλλά απευθείας στα δεδομένα που ο κατασκευαστής προέβλεψε να θέσει στη διάθεση μας, είναι μια πολύ μεγάλη ευκολία.
Για την περίπτωση όπου θέλουμε να έχουμε προγραμματική πρόσβαση στη διαμόρφωση των παραμέτρων λειτουργίας του εξοπλισμού, η χρήση YANG Data Models με κατάλληλα πρωτόκολλα επικοινωνίας δίνει πολύ μεγάλη ευελιξία και ακρίβεια.</p>
<h3 id="yangmdt-vs-snmp">YANG/MDT vs SNMP</h3>
<p>Καταρχήν όπως είπαμε η ανάπτυξη στον τομέα του SNMP έχει σταματήσει από τόσο παλιά, που κάνει πραγματικά εντύπωση. Όποιος έχει παρακολουθήσει τις διαλέξεις (<a href="https://www.ciscolive.com/global/on-demand-library.html?search=BRKNMS-2032#/session/1564610718224001cM9p">presentation</a> και <a href="https://www.ciscolive.com/c/dam/r/ciscolive/emea/docs/2020/pdf/BRKNMS-2032.pdf">pdf</a>) του <a href="https://blogs.cisco.com/author/benoitclaise">Benoit Claise</a> ή έχει διαβάσει το βιβλίο του <a href="https://www.informit.com/store/network-programmability-with-yang-the-structure-of-9780135180396">Network Programmability with YANG: The Structure of Network Automation with YANG, NETCONF, RESTCONF, and gNMI</a> γνωρίζει ότι πρακτικά μετά το 2007 τα πράγματα είχαν εντελώς τελματώσει για το SNMP.</p>
<p>Επίσης όλοι γνωρίζουμε ότι SNMP είναι αρκετά δυσνόητο (ASN.1 notation, SMI tree, MIB imports, κλπ), οι υλοποιήσεις του αρκετά προβληματικές (μεγάλο πρόβλημα με ασυμβατότητα μεταξύ των MIBs) και όσο αφορά την ασφάλεια, δεν είναι τυχαίο που μεγάλος αριθμός συσκευών δεν υποστηρίζει την <em>&ldquo;ασφαλή&rdquo;</em> έκδοση SNMPv3, η οποία έχει πέντε διαφορετικές παραλαγές, όπου κάποιες από αυτές μόνο ασφαλείς δεν είναι. Σαν επισφράγισμα στον <a href="https://youtu.be/McNm_WfQTHw">&ldquo;τάφο&rdquo; του SNMP</a>, πολλοί λίγοι οργανισμοί τολμούν να εφαρμόσουν το συγκεκριμένο πρωτόκολλο και προτιμούν την λιγότερη ασφαλή αλλά <em>&ldquo;απλή&rdquo;</em> και <em>&ldquo;προβλέψιμη&rdquo;</em> έκδοση SNMPv2c.</p>
<p>Αντίθετα οι τρόποι μεταφοράς YANG Data προσφέρουν ασφάλεια δεδομένων κατά τη μεταφορά, τα μοντέλα προβλέπουν θέματα συμβατότητας και ο τρόπος αναπαράστασης είναι κατά πολύ βελτιωμένος σε σχέση με το SNMP. Επίσης για την χρήση σε monitoring/supervision οι δυνατότητες που προσφέρει το MDT - Model Driven Telemetry (γνωστό και ως Streaming Telemetry) για μεγαλύτερη πυκνότητα δεδομένων χωρίς μεγάλη επίπτωση στις επιδόσεις του εξοπλισμού, είτε για streaming data είτε on-change, είτε με outgoing subscriptions (no polling, μεγαλύτερη ασφάλεια και scalability), είτε incoming (συνεχή tcp connections όσο διαρκεί το streaming με ευθύνη του monitoring station). Για τον ορισμό των subscriptions είναι απαραίτητη η χρήση xpath querries και η μεταφορά γίνεται είτε μέσω Netconf είτε με GRPC.</p>
<p>Παρόλα αυτά, αν κανείς ξεκινήσει να ασχολείται με το YANG δανειζόμενος την οπτική γιγάντων του χώρου όπως ο <a href="https://www.linkedin.com/in/benoit-claise-7534b42/">Benoit Claise</a> και o <a href="https://www.linkedin.com/in/carlmoberg/">Carl Moberg</a> (πρώην <a href="https://www.tail-f.com/">Tail-f</a> / Cisco), μάλλον θα αρχίσει να το ξανασκέφτεται.. Ευτυχώς υπάρχουν και πιο εύκολοι δρόμοι και .. κι εμείς εδώ είμαστε ;)</p>
<h2 id="ιστορικό">Ιστορικό</h2>
<p>Η συζήτηση για την ανεπάρκεια των υπαρχόντων τεχνολογιών ξεκίνησε νωρίς, το 2002 με το <a href="https://datatracker.ietf.org/doc/html/rfc3535">IAB Network Management Workshop</a> το οποίο συμπληρώθηκε και με άλλα κείμενα π.χ. <a href="https://datatracker.ietf.org/doc/html/rfc3444">On the Difference between Information Models and Data Models</a>. Στη συνέχεια πρώτα καθορίστηκε ένα πρωτόκολλο για τη μεταφορά δεδομένων, το <a href="https://datatracker.ietf.org/doc/html/rfc4741">Netconf</a> το 2006 με την RFC4741, η οποία έγινε obsolete από την <a href="https://datatracker.ietf.org/doc/html/rfc6241">RFC6241</a> το 2011.</p>
<p>Στη συνέχεια προέκυψε η προδιαγραφή για τη γλώσσα YANG:<a href="https://datatracker.ietf.org/doc/html/rfc6020">YANG - A Data Modeling Language for the Network Configuration Protocol (NETCONF)</a> το 2010 και με τα χρόνια και τα σχετικά συστατικά της π.χ. <a href="https://datatracker.ietf.org/doc/html/rfc6991">Common YANG Data Types</a> και <a href="https://datatracker.ietf.org/doc/html/rfc8340">YANG Tree Diagrams</a>, ενώ το πρωτόκολλο <a href="https://datatracker.ietf.org/doc/html/rfc8040">RESTCONF</a> άργησε να καθοριστεί.
Στην πορεία αυτή βλέπει κανείς να συνδράμουν σημαντικά τόσο ακαδημαϊκά ιδρύματα αλλά και εταιρείες που έβαλαν τα θεμέλια για τις δυνατότητες και τη χρήση των YANG Models σήμερα, π.χ. Tail-f systems, Juniper, κλπ.
Ένα κρίσιμο σημείο είναι ότι η πορεία ανάπτυξης του SNMP σταμάτησε αρκετά νωρίς (περίπου το 2007), οι vendors δεν ανέπτυσαν πλέον τις MIB τους και έτσι σιγά εγκαταλείφθηκε η επένδυση σε αυτό το μοντέλο διαχείρισης και δόθηκε βάρος σε μοντέλα και τεχνολογίες όπως τα Yang Data Models.</p>
<p>Υπάρχουν πληθώρα δεδομένων και βιβλίων γύρω τόσο από το ιστορικό όσο και από την τεχνολογία και τη χρήση της αλλά το reference πάνω στη χρήση της YANG στο Network Programmability αποτελεί το βιβλίο των Benoit Claise, Joe Clarke &amp; Jan Lindblad: <a href="https://www.informit.com/store/network-programmability-with-yang-the-structure-of-9780135180396">Network Programmability with YANG: The Structure of Network Automation with YANG, NETCONF, RESTCONF, and gNMI</a></p>
<h1 id="είδη-μοντέλων">Είδη μοντέλων</h1>
<h2 id="open-models">Open Models</h2>
<p>Τα Open models είναι ανεξάρτητα από συγκεκριμένους vendors και αναπαριστούν τις παραμέτρους λειτουργίας των δικτυακών συσκευών σύμφωνα με όσα ορίζουν οργανισμοί με ανοικτά standards. Τέτοιοι οργανισμοί είναι το IETF και το OpenConfig. Προφανώς αφορούν λειτουργίες οι οποίες είναι κοινές σε δικτυακές συσκευές διαφορετικών κατασκευαστών, όπως τα πρωτόκολλα routing π.χ. ospf, οι ιδιότητες βασικών στοιχείων των συσκευών, π.χ. interfaces κλπ. To <a href="https://www.ietf.org/">IETF</a> δεν χρειάζεται ιδιαίτερες συστάσεις (ή δεν θα έπρεπε). To <a href="https://www.openconfig.net/">OpenConfig</a> είναι οργανισμός στον οποίο συμμετέχουν <a href="https://www.openconfig.net/about/participants/">αρκετοί vendors</a> στην προσπάθεια να δημιουργηθεί κάτι κοινό που προσαρμόζεται γρηγορότερα στις εξελίξεις.</p>
<h2 id="native-models">Native Models</h2>
<p>Τα Native Models είναι αυτά που ορίζονται από τους ίδιους τους vendors ανά μοντέλο/κατηγορία συσκευής και λειτουργικό σύστημα (π.χ. Cisco IOS-XE/17.3.1 - <a href="https://github.com/YangModels/yang/tree/master/vendor/cisco/xe/1731">https://github.com/YangModels/yang/tree/master/vendor/cisco/xe/1731</a>)</p>
<h1 id="δομή">Δομή</h1>
<h2 id="yang-modules--submodules">Yang Modules &amp; Submodules</h2>
<p>Τα Yang data models ορίζουν ομάδες δεδομένων που αναπαριστούν πλήρως ένα μοντέλο χρησιμοποιώντας modules και submodules. Ένα module αναπαριστά και ορίζει πλήρως ένα μόνο μοντέλο, ωστόσο μπορεί να εισάγει (<em>import</em>) εξωτερικά modules, να συμπεριλάβει (<em>include</em>) ένα ή περισσότερα submodules, να επεκτείνει ένα model (<em>augment</em>) ή να καθορίσει που οι προδιαγραφές του αποκλίνουν (<em>deviation</em>) από ένα μοντέλο.
Ένα module ορίζεται από ένα μοναδικό XML namespace (xmlns). Τα submodules είναι ενότητες στις οποίες μπορεί να διαιρεθεί ένα module για καλύτερη οργάνωση.</p>
<h2 id="yang-node-types">Yang Node Types</h2>
<p>Ανάλογα με τον τρόπο οργάνωσης και αναπάραστασης της πληροφορίας σε ένα μοντέλο, ορίζονται οι παρακάτω τύποι:</p>
<ul>
<li>container: Ένα subset από δεδομένα που μπορούν να είναι ανόμοια ως προς τον τύπο τους και ομαδοποιούνται για οργανωτικούς λόγους. Ένα container δεν διαθέτει data type.</li>
</ul>
<pre><code class="language-yang" data-lang="yang">container system {
    container login {
        leaf message {
            type string;
            description
                &quot;Message given at start of login session&quot;;
        }
    }
}
</code></pre><ul>
<li>list: Μια ομάδα από δεδομένα του ίδιου τύπου (μπορεί να είναι και ένα άλλο μοντέλο που εισάγεται σε αυτό που εξετάζουμε) και για την οργάνωση των οποίων και την απευθείας πρόσβαση σε συγκεκριμένα από αυτά, ορίζονται πεδία - κλειδιά.</li>
<li>key: Τα παραπάνω αναφερόμενα πεδία - κλειδιά, π.χ. το όνομα ενός δικτυακού interface. Μία λίστα μπορεί να έχει παραπάνω από ένα πεδίο κλειδί, και για την απευθείας πρόσβαση σε συγκεκριμένα δεδομένα, ανάλογα με την περίπτωση, πρέπει κανείς να ορίζει ή όλα τα κλειδιά ή κάποια από αυτά.</li>
</ul>
<pre><code class="language-yang" data-lang="yang">list user {
    key &quot;name&quot;;
    leaf name {
        type string;
    }
    leaf full-name {
        type string;
    }
    leaf class {
        type string;
    }
}
</code></pre><ul>
<li>leaf: Ένα απλό πεδίο όπου ορίζεται μια τιμή για το μοντέλο. Κάθε leaf συνήθως έχει συγκεκριμένο τύπο δεδομένων ενώ μπορεί να ορίζει και κανόνες για το πότε είναι σωστά τα δεδομένα που θέλει κάποιος να αποθηκεύσει σε αυτό (<em>Data Validation</em>).</li>
</ul>
<pre><code class="language-yang" data-lang="yang">leaf host-name {
    type string;
    description &quot;Hostname for this system&quot;;
}
</code></pre><ul>
<li>grouping
Ομάδες δεδομένων που μπορούν να επαναχρησιμοποιηθούν εντός του μοντέλου με το πρόθεμα <em>uses</em>.</li>
</ul>
<pre><code class="language-yang" data-lang="yang">grouping target {
    leaf address {
        type inet:ip-address;
        description &quot;Target IP address&quot;;
    }
    leaf port {
        type inet:port-number;
        description &quot;Target port number&quot;;
    }
}
container peer {
    container destination {
        uses target;
    }
}
</code></pre><h2 id="data-types--validation">Data types &amp; Validation</h2>
<h2 id="built-in-data-types">Built-in Data Types</h2>
<p>Όπως και σε άλλες γλώσσες έτσι και στην Yang είναι ορισμένοι ενσωματωμένοι τύποι δεδoμένων.
Τα παρακάτω ορίζονται στο documentation: <a href="https://datatracker.ietf.org/doc/html/rfc6991">Common YANG Data Types</a></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>binary</td>
<td>Text</td>
<td>Any binary data</td>
</tr>
<tr>
<td>bits</td>
<td>Text/Number</td>
<td>A set of bits or flags</td>
</tr>
<tr>
<td>boolean</td>
<td>Text</td>
<td>&ldquo;true&rdquo; or &ldquo;false&rdquo;</td>
</tr>
<tr>
<td>decimal64</td>
<td>Number</td>
<td>64-bit fixed point real number</td>
</tr>
<tr>
<td>empty</td>
<td>Empty</td>
<td>A leaf that does not have any value</td>
</tr>
<tr>
<td>enumeration</td>
<td>Text/Number</td>
<td>Enumerated strings with associated numeric values</td>
</tr>
<tr>
<td>identityref</td>
<td>Text</td>
<td>A reference to an abstract identity</td>
</tr>
<tr>
<td>instance-identifier</td>
<td>Text</td>
<td>References a data tree node</td>
</tr>
<tr>
<td>int8</td>
<td>Number</td>
<td>8-bit signed integer</td>
</tr>
<tr>
<td>int16</td>
<td>Number</td>
<td>16-bit signed integer</td>
</tr>
<tr>
<td>int32</td>
<td>Number</td>
<td>32-bit signed integer</td>
</tr>
<tr>
<td>int64</td>
<td>Number</td>
<td>64-bit signed integer</td>
</tr>
<tr>
<td>leafref</td>
<td>Text/Number</td>
<td>A reference to a leaf instance</td>
</tr>
<tr>
<td>string</td>
<td>Text</td>
<td>Human readable string</td>
</tr>
<tr>
<td>uint8</td>
<td>Number</td>
<td>8-bit unsigned integer</td>
</tr>
<tr>
<td>uint16</td>
<td>Number</td>
<td>16-bit unsigned integer</td>
</tr>
<tr>
<td>uint32</td>
<td>Number</td>
<td>32-bit unsigned integer</td>
</tr>
<tr>
<td>uint64</td>
<td>Number</td>
<td>64-bit unsigned integer</td>
</tr>
<tr>
<td>union</td>
<td>Text/Number</td>
<td>Choice of member types</td>
</tr>
</tbody>
</table>
<h2 id="derived-types">Derived Types</h2>
<p>Είναι τύποι δεδομένων που προκύπτουν κατασκευάζονται με την εντολή typedef.</p>
<pre><code class="language-yang" data-lang="yang">typedef percent {
    type uint16 {
        range &quot;0 .. 100&quot;;
    }
    description &quot;Percentage&quot;;
}

leaf completed {
    type percent;
}
</code></pre><h1 id="τρόποι-επικοινωνίας">Τρόποι επικοινωνίας</h1>
<p><img src="/images/yang-data.png" alt="yang data"></p>
<p>Παρακάτω βλέπουμε μια αναπαράσταση του Yang stack από την παρουσίαση του Hank Preston στο <a href="https://www.ciscolive.com/c/dam/r/ciscolive/emea/docs/2020/pdf/BRKDEV-1368.pdf">BRKDEV-1368 στο Cisco Live του 2020 ΕΜΕΑ</a>
<img src="/images/stack.png" alt="yang stack"></p>
<h2 id="netconf">Netconf</h2>
<p>Πρωτόκολλο ασφαλούς μεταφοράς YANG Data βασισμένο συνήθως σε XML RPCs τα οποία μεταδίδονται μέσω SSH (default port 830).
<a href="https://datatracker.ietf.org/doc/html/rfc4741">https://datatracker.ietf.org/doc/html/rfc4741</a>
<a href="https://datatracker.ietf.org/doc/html/rfc6241">https://datatracker.ietf.org/doc/html/rfc6241</a></p>
<p>Το Netconf μεταφέρει και επιστρέφει δεδομένα σε XML. Παρακάτω βλέπουμε το protocol stack του:
<img src="/images/netconf-stack.png" alt="netconf stack"></p>
<p>Παρακάτω βλέπουμε ένα παράδειγμα output από python script από το session BRKDEV-1368 στο Cisco Live:
<img src="/images/netconf.png" alt="netconf example"></p>
<p>Τα Netconf Operations είναι τα παρακάτω:</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt;get&gt;</td>
<td>Retrieve running configuration and device state information</td>
</tr>
<tr>
<td>&lt;get-config&gt;</td>
<td>Retrieve all or part of specified configuration data store</td>
</tr>
<tr>
<td>&lt;edit-config&gt;</td>
<td>Loads all or part of a configuration to the specified configuration data store</td>
</tr>
<tr>
<td>&lt;copy-config&gt;</td>
<td>Replace an entire configuration data store with another</td>
</tr>
<tr>
<td>&lt;delete-config&gt;</td>
<td>Delete a configuration data store</td>
</tr>
<tr>
<td>&lt;commit&gt;</td>
<td>Copy candidate data store to running data store</td>
</tr>
<tr>
<td>&lt;lock&gt;-&lt;unlock&gt;</td>
<td>Lock or unlock the entire configuration data store system</td>
</tr>
<tr>
<td>&lt;close-session&gt;</td>
<td>Graceful termination of NETCONF session</td>
</tr>
<tr>
<td>&lt;kill-session&gt;</td>
<td>Forced termination of NETCONF session</td>
</tr>
</tbody>
</table>
<p>Οι βιβλιοθήκες Python που υποστηρίζουν Netconf και με τις οποίες μπορεί κανείς να επικοινωνήσει με δικτυακό εξοπλισμό είναι οι:</p>
<ul>
<li>ncclient - <a href="https://github.com/ncclient/ncclient">https://github.com/ncclient/ncclient</a></li>
<li>scrapli-netconf - <a href="https://www.montanari.io/posts/2020/scrapli_netconf/">https://www.montanari.io/posts/2020/scrapli_netconf/</a></li>
</ul>
<p>Scrapli is a python framework developed by Carl Montanari.
Ncclient was developed by Shikar Bhushan. It is now maintained by Leonidas Poulopoulos and Einar Nilsen-Nygaard.</p>
<p>Για την επικοινωνία με τον εξοπλισμό, πρέπει να χρησιμοποιήσει κανείς είτε XML Subtrees είτε XML XPaths.
Η δεύτερη μέθοδος είναι σαφέστατα πιο κομψή.</p>
<h2 id="restconf">Restconf</h2>
<p>Πρωτόκολλο ασφαλούς μεταφοράς YANG Data βασισμένο σε HTTPS για το transport.
<a href="https://datatracker.ietf.org/doc/html/rfc8040">https://datatracker.ietf.org/doc/html/rfc8040</a></p>
<p>Επιστρέφει δεδομένα είτε σε JSON format είτε σε XML. Παρακάτω βλέπουμε το protocol stack του:
<img src="/images/restconf-stack.png" alt="restconf stack"></p>
<p>Κι εδώ βλέπουμε την αντιστοιχία των CRUD Operations του Restconf με τις αντίστοιχες του Netconf:</p>
<table>
<thead>
<tr>
<th>RESTCONF</th>
<th>NETCONF</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>&lt;get&gt; , &lt;get-config&gt;</td>
</tr>
<tr>
<td>POST</td>
<td>&lt;edit-config&gt; (operation=&quot;create&rdquo;)</td>
</tr>
<tr>
<td>PUT</td>
<td>&lt;edit-config&gt; (operation=&quot;create/replace&rdquo;)</td>
</tr>
<tr>
<td>PATCH</td>
<td>&lt;edit-config&gt; (operation=&quot;merge&rdquo;)</td>
</tr>
<tr>
<td>DELETE</td>
<td>&lt;edit-config&gt; (operation=&quot;delete&rdquo;)</td>
</tr>
</tbody>
</table>
<p>Τα payloads που χρησιμοποιούνται στο Restconf είναι συνήθως JSON ενώ οι απαντήσεις από τις συσκευές μπορούν να είναι σε XML(default) ή JSON.
Για χρήση εντός Python scripts μπορεί κανείς να χρησιμοποιήσει τόσο το requests library όσο και το httpx το οποίο υποστηρίζει ASYNC-IO.</p>
<h2 id="grpc">GRPC</h2>
<p>Το <a href="https://grpc.io/docs/what-is-grpc/introduction/">GRPC</a> είναι πρωτόκολο μεταφοράς κατασκευασμένο από τη Google, τα αρχικά σημαίνουν Google Remote Procedure Call.
Χρησιμοποιεί <a href="https://developers.google.com/protocol-buffers/docs/overview">Protocol Buffers</a> για το format των δεδομένων.
<img src="/images/GRPC.svg" alt="GRPC diagram"></p>
<h1 id="τρόποι-αναπαράστασης---εργαλεία">Τρόποι αναπαράστασης - εργαλεία</h1>
<h2 id="pyang">pyang</h2>
<p>Command Line εργαλείο βασισμένο σε python για human readable formated αναπαράσταση ενός μοντέλου Yang.
Η πιο απλή σύνταξη της εντολής είναι η παρακάτω, η οποία αναπαριστά ένα μοντέλο σε δενδροειδή μορφή:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">pyang –f tree &lt;yang-model-filename.yang&gt;
</code></pre></div><p>To Yang tree diagram καθορίζεται εδώ: <a href="https://datatracker.ietf.org/doc/html/rfc8340">https://datatracker.ietf.org/doc/html/rfc8340</a></p>
<p>Παράδειγμα παρμένο από το <a href="http://nxos-prog.ciscolive.com/pod0/labs/lab7/lab7-m1">site της Cisco για NX-OS Programmability</a> :</p>
<p><img src="/images/pyang-1.png" alt="pyang example"></p>
<p>O πηγαίος κώδικας διατίθεται στο <a href="https://github.com/mbj4668/pyang">https://github.com/mbj4668/pyang</a> ενώ εδώ μπορείτε να βρείτε ένα <a href="https://github.com/mbj4668/pyang/wiki/Tutorial">tutorial</a>.</p>
<h2 id="postman">Postman</h2>
<p>Το <a href="https://www.postman.com/product/what-is-postman/">Postman</a> είναι ένα REST API client. Διαθέτει δυνατότητα για δημιουργία και συγχρονισμό, εισαγωγή, εξαγωγή συλλογών από REST API calls, χρήση παραμέτρων και μεταβλητών, διάφορες μορφοποιήσεις δεδομένων εισόδου - εξόδου, και μεγάλη ευκολία χρήσης. Δεν είναι τυχαίο που αποτελεί το εργαλείο που χρησιμοποιείται πιο συχνά όταν κάποιος θέλει να επιδείξει ή να εξερευνίσει ένα REST API μέσω Restconf.
Στην περίπτωση των YANG data models, είναι προσφιλές εργαλείο εξερεύνησης μέσω Restconf των δυνατοτήτων και δεδομένων που υποστηρίζει ένας δικτυακός εξοπλισμός. Σε σύγκριση με το Pyang, μας δίνει τη δυαντότητα να αναζητήσουμε όσα γνωρίζουμε σε θεωρητικό επίπεδο για ένα μοντέλο, όπως αυτό εφαρμόζεται στην πράξη στον δικτακό εξοπλισμό. Συνήθως κανείς ξεκινά από τα capabilities του εξοπλισμού (το σύνολο των Yang models που εφαρμόζει ο εξοπλισμός) και προχωρά σε συγκεκριμένα μοντέλα και ιδιότητες. Μπορείτε να βρείτε πολλά εκπαιδευτικά βίντεο για το postman στο σχετικό κανάλι στο Youtube: <a href="https://www.youtube.com/c/postman">https://www.youtube.com/c/postman</a> αλλά και πολλά training videos από άλλες πλατφόρμες/κανάλια: <a href="https://www.youtube.com/watch?v=VywxIQ2ZXw4">https://www.youtube.com/watch?v=VywxIQ2ZXw4</a>
Φυσικά υπάρχουν κι αυτοί που ισχυρίζονται ότι δεν χρειάζονται το Postman, αφού μπορούν να ενσωματώσουν αυτές τις λειτουργίες σε εργαλεία IDE: <a href="https://www.youtube.com/watch?v=AbCTlemwZ1k">https://www.youtube.com/watch?v=AbCTlemwZ1k</a></p>
<h2 id="yang-catalogue">Yang Catalogue</h2>
<p>Άλλος ένας τρόπος να εξερευνήσει κανείς τα Yang Data Models. Στη διεύθυνση <a href="https://www.yangcatalog.org/">https://www.yangcatalog.org/</a> μπορεί κανείς να βρει όλα τα μοντέλα που δημοσιεύονται προς χρήση και να τα μελετήσει ενδελεχώς online. Είναι ένα εντυπωσιακό εγχείρημα (υπάρχουν σχετικές αναφορές στις διαλέξεις των Claise &amp; Moberg).</p>
<h2 id="anx">ANX</h2>
<p>To ANX είναι εργαλείο το οποίο επιτρέπει την απευθείας εξερεύνηση των μοντέλων YANG από τον ίδιο το δικτυακό εξοπλισμό και στη συνέχεια και την εξαγωγή τους αλλά και τη χρήση τους για την διαχείριση του ίδιου ή άλλων συμβατών με αυτόν. Έχει αναπτυχθεί από μηχανικούς της Cisco και μέχρι πρόσφατα ηταν το μοναδικό εργαλείο που επέτρεπε την add-hoc εξερεύνηση των μοντέλων χωρίς μεγάλη προσπάθεια και πρότερη γνώση.
Είναι Open Source και μπορεί να χρησιμοποιηθεί και σε μορφή Docker Container. Θα το συνατήσετε σε τουλάχιστον δύο διαφορετικές πλατφόρμες online training σε courses για Network Programmability.</p>
<h2 id="yang-suite">Yang-Suite</h2>
<p>Είναι ένα εξαιρετικό εργαλείο λογισμικού, ανεπτυγμένο και πάλι από μηχανικούς της Cisco, ως διάδοχος του πολύ επιτυχημένου αλλά πλέον παρωχημένου <a href="https://github.com/CiscoDevNet/yang-explorer">Yang Explorer</a>, το οποίο χρησιμοποιούνταν για την εξερεύνηση και διαχείριση μοντέλων YANG, ώσπου τα συστατικά στα οποία βασιζόταν σταμάτησαν να υποστηρίζονται.
Αναφορά στο Yang Explorer θα βρείτε και στο Cisco Code Exchange: <a href="https://developer.cisco.com/codeexchange/github/repo/CiscoDevNet/yang-explorer/">https://developer.cisco.com/codeexchange/github/repo/CiscoDevNet/yang-explorer/</a>
Το Yang Suite ωστόσο είναι σύγχρονο και ευέλικτο, έχει όλες τις δυνατότητες και πολλές περισσότερες και σύντομα θα προσφέρει στους μηχανικούς μια γέφυρα μεταξύ του παλιού κόσμου στον οποίο βασίζονταν (SNMP) και του καινούργιου (YANG). Όταν ανακοινωθεί επίσημα, θα ενημερώσουμε το άρθρο.
<a href="https://blogs.cisco.com/developer/363-yangsuite-01">https://blogs.cisco.com/developer/363-yangsuite-01</a>
<a href="https://developer.cisco.com/docs/yangsuite/">https://developer.cisco.com/docs/yangsuite/</a>
<a href="https://gblogs.cisco.com/pt/2021/07/01/introduction-to-yang-suite/">https://gblogs.cisco.com/pt/2021/07/01/introduction-to-yang-suite/</a></p>
<p><img src="/images/yangsuite.png" alt="yang suite"></p>
<h2 id="ydk---yang-development-kit">YDK - Yang Development Kit</h2>
<p>Υπάρχει άλλο ένα εργαλείο που μπορεί να χρησιμοποιηθεί προγραμματιστικά για χειρισμό Yang Data Models &amp; Yang Data. Διαθέτει βιβλιοθήλες C++ και Python.
<a href="https://developer.cisco.com/site/ydk/">https://developer.cisco.com/site/ydk/</a></p>
<h1 id="whats-next">What&rsquo;s next</h1>
<p>Η ομάδα μας δεν δημοσιευει tutorials. Μπορείτε να βρείτε πολλά σε blogs, YouTube videos, free &amp; paid training platforms.
Μπορείτε επίσης να αναζητησετε βοήθεια εντός της ομάδας.
Επόμενο introductory post: Introduction to PyATS.</p>
<h1 id="πηγές---links">Πηγές - Links</h1>
<p><a href="https://www.juniper.net/documentation/us/en/software/junos/netconf/topics/concept/netconf-yang-modules-overview.html">https://www.juniper.net/documentation/us/en/software/junos/netconf/topics/concept/netconf-yang-modules-overview.html</a>
<a href="https://www.fir3net.com/Networking/Protocols/an-introduction-to-netconf-yang.html">https://www.fir3net.com/Networking/Protocols/an-introduction-to-netconf-yang.html</a>
<a href="https://discuss.tail-f.com/c/yang/8">https://discuss.tail-f.com/c/yang/8</a>
<a href="https://grpc.io/docs/what-is-grpc/introduction/">https://grpc.io/docs/what-is-grpc/introduction/</a>
<a href="https://developers.google.com/protocol-buffers/docs/overview">https://developers.google.com/protocol-buffers/docs/overview</a></p>
<p><a href="https://github.com/YangModels/yang">https://github.com/YangModels/yang</a>
<a href="https://www.yangcatalog.org/">https://www.yangcatalog.org/</a>
<a href="https://github.com/mbj4668/pyang">https://github.com/mbj4668/pyang</a>
<a href="https://github.com/mbj4668/pyang/wiki/Tutorial">https://github.com/mbj4668/pyang/wiki/Tutorial</a>
<a href="https://blogs.cisco.com/developer/363-yangsuite-01">https://blogs.cisco.com/developer/363-yangsuite-01</a>
<a href="https://developer.cisco.com/docs/yangsuite/">https://developer.cisco.com/docs/yangsuite/</a>
<a href="https://gblogs.cisco.com/pt/2021/07/01/introduction-to-yang-suite/">https://gblogs.cisco.com/pt/2021/07/01/introduction-to-yang-suite/</a>
<a href="https://developer.cisco.com/codeexchange/github/repo/cisco-ie/anx">https://developer.cisco.com/codeexchange/github/repo/cisco-ie/anx</a>
<a href="https://github.com/cisco-ie/anx">https://github.com/cisco-ie/anx</a></p>
<p><a href="https://blogs.cisco.com/getyourbuildon/network-programmability-with-yang-the-structure-of-network-automation-with-yang-netconf-restconf-and-gnmi">https://blogs.cisco.com/getyourbuildon/network-programmability-with-yang-the-structure-of-network-automation-with-yang-netconf-restconf-and-gnmi</a>
<a href="https://www.ciscolive.com/c/dam/r/ciscolive/emea/docs/2020/pdf/BRKDEV-1368.pdf">https://www.ciscolive.com/c/dam/r/ciscolive/emea/docs/2020/pdf/BRKDEV-1368.pdf</a>
<a href="https://www.ciscolive.com/c/dam/r/ciscolive/emea/docs/2020/pdf/BRKNMS-2032.pdf">https://www.ciscolive.com/c/dam/r/ciscolive/emea/docs/2020/pdf/BRKNMS-2032.pdf</a>
<a href="https://www.netacad.com/sites/default/files/images/careers/Webinars/DevNet/devnet_session_7_networkprogrammability_yang_netconf_restconf.pdf">https://www.netacad.com/sites/default/files/images/careers/Webinars/DevNet/devnet_session_7_networkprogrammability_yang_netconf_restconf.pdf</a>
<a href="https://www.slideshare.net/cmoberg/a-30minute-introduction-to-netconf-and-yang">https://www.slideshare.net/cmoberg/a-30minute-introduction-to-netconf-and-yang</a>
<a href="https://www.tail-f.com/what-is-yang/">https://www.tail-f.com/what-is-yang/</a>
<a href="https://www.tail-f.com/wordpress/wp-content/uploads/2013/03/Tail-f-NETCONF-YANG-Service-Automation-LISA-Usenix-2011.pdf">https://www.tail-f.com/wordpress/wp-content/uploads/2013/03/Tail-f-NETCONF-YANG-Service-Automation-LISA-Usenix-2011.pdf</a>
<a href="http://nxos-prog.ciscolive.com/pod0/labs/lab7/lab7-m1">http://nxos-prog.ciscolive.com/pod0/labs/lab7/lab7-m1</a>
<a href="https://developers.google.com/protocol-buffers/docs/overview">https://developers.google.com/protocol-buffers/docs/overview</a>
<a href="https://grpc.io/docs/what-is-grpc/introduction/">https://grpc.io/docs/what-is-grpc/introduction/</a>
<a href="https://datatracker.ietf.org/meeting/101/materials/slides-101-netconf-grpc-network-management-interface-gnmi-00">https://datatracker.ietf.org/meeting/101/materials/slides-101-netconf-grpc-network-management-interface-gnmi-00</a>
<a href="https://www.postman.com/product/what-is-postman/">https://www.postman.com/product/what-is-postman/</a></p>
<p><a href="https://www.montanari.io/posts/2020/scrapli_netconf/">https://www.montanari.io/posts/2020/scrapli_netconf/</a>
<a href="https://github.com/ncclient/ncclient">https://github.com/ncclient/ncclient</a>
<a href="https://ncclient.readthedocs.io/en/latest/">https://ncclient.readthedocs.io/en/latest/</a></p>
<p><a href="https://www.cbtnuggets.com/learn/it-training/playlist/nrn:playlist:certification:5f57b50480e1f9001566c4cf/132?autostart=1">https://www.cbtnuggets.com/learn/it-training/playlist/nrn:playlist:certification:5f57b50480e1f9001566c4cf/132?autostart=1</a></p>
]]></content>
        </item>
        
        <item>
            <title>Introduction to git</title>
            <link>https://netautogr.github.io/posts/2021/05/introduction-to-git/</link>
            <pubDate>Mon, 17 May 2021 23:02:37 +0300</pubDate>
            
            <guid>https://netautogr.github.io/posts/2021/05/introduction-to-git/</guid>
            <description>Γενικά - Version Control Systems Τί είναι ένα VCS Ένα Version Control System (VCS) είναι ένα σύστημα που καταγράφει τις αλλαγές που πραγματοποιούνται σε κάποιο αρχείο ή σε ένα σύνολο από αρχεία στην διάρκεια του χρόνου. Επίσης μπορεί να πραγματοποιήσει ανάκληση προηγούμενων εκδόσεων του αρχείου αν αυτό απαιτηθεί. Ένα VCS σου επιτρέπει να επαναφέρεις κάποια αρχεία σε μια προηγούμενη κατάσταση, ένα ολόκληρο project σε μια προηγούμενη κατάσταση, να βλέπεις τις αλλαγές από προηγούμενες εκδόσεις, ποιος έκανε την τελευταία αλλαγή και ίσως προκάλεσε κάποια δυσλειτουργία και πολλά άλλα.</description>
            <content type="html"><![CDATA[<h1 id="γενικά---version-control-systems">Γενικά - Version Control Systems</h1>
<h2 id="τί-είναι-ένα-vcs">Τί είναι ένα VCS</h2>
<p>Ένα Version Control System (VCS) είναι ένα σύστημα που καταγράφει τις αλλαγές που πραγματοποιούνται σε κάποιο αρχείο ή σε ένα σύνολο από αρχεία στην διάρκεια του χρόνου. Επίσης μπορεί να πραγματοποιήσει ανάκληση προηγούμενων εκδόσεων του αρχείου αν αυτό απαιτηθεί. Ένα VCS σου επιτρέπει να επαναφέρεις κάποια αρχεία σε μια προηγούμενη κατάσταση, ένα ολόκληρο project σε μια προηγούμενη κατάσταση, να βλέπεις τις αλλαγές από προηγούμενες εκδόσεις, ποιος έκανε την τελευταία αλλαγή και ίσως προκάλεσε κάποια δυσλειτουργία και πολλά άλλα. Γνωστά version control systems που έχουν γνωρίσει ευρεία χρήση στο παρελθόν είναι τα Subversion, CVS, κ.α.</p>
<h2 id="local-version-control-systems">Local Version Control Systems</h2>
<p>Πολλοί επιλέγουν σαν μια μέθοδο Version Control την αντιγραφή των αρχείων που θέλουν να παρακολουθήσουν σε ένα διαφορετικό φάκελο ή φακέλους (ίσως με κάποιο timestamp) στην διάρκεια του χρόνου. Αυτή η πρακτική συνηθίζεται γιατί είναι απλή αλλά είναι και επιρρεπείς σε λάθη καθώς είναι εύκολο να ξεχάσεις σε ποιο φάκελο είσαι και κατά λάθος να γράψεις στα λάθος αρχεία η να αντιγράψεις αρχεία που δεν έπρεπε. Για την αντιμετώπιση τέτοιων θεμάτων αναπτύχθηκαν τα τοπικά VCS που περιλαμβάνουν μια απλή βάση δεδομένων που καταγράφει όλες τις αλλαγές στα αρχεία που απαιτείται.
Centralized Version Control Systems</p>
<p>Ένα ζήτημα που δεν μπορούσαν να αντιμετωπίσουν τα local VCS ήταν η ανάγκη των προγραμματιστών να συνεργαστούν για ένα project από διαφορετικά συστήματα. Έτσι αναπτύχθηκαν τα κεντρικοποιημένα VCS. Τέτοια συστήματα (όπως το CVS και το Subversion) περιλαμβάνουν ένα κεντρικό server που περιέχει όλα τα αρχεία που παρακολουθούνται καθώς και ένα αριθμό από clients που κατεβάζουν αρχεία  από τον κεντρικό server για να τα επεξεργαστούν. Για πολλά χρόνια αυτή ήταν η standard μέθοδος που χρησιμοποιούσαν οι προγραμματιστές για version control.</p>
<h2 id="centralized-version-control-systems">Centralized Version Control Systems</h2>
<p>Ένα ζήτημα που δεν μπορούσαν να αντιμετωπίσουν τα local VCS ήταν η ανάγκη των προγραμματιστών να συνεργαστούν για ένα project από διαφορετικά συστήματα. Έτσι αναπτύχθηκαν τα κεντρικοποιημένα VCS. Τέτοια συστήματα (όπως το CVS και το Subversion) περιλαμβάνουν ένα κεντρικό server που περιέχει όλα τα αρχεία που παρακολουθούνται καθώς και ένα αριθμό από clients που κατεβάζουν αρχεία  από τον κεντρικό server για να τα επεξεργαστούν. Για πολλά χρόνια αυτή ήταν η standard μέθοδος που χρησιμοποιούσαν οι προγραμματιστές για version control.
<img src="/images/git1.png" alt="Centralized VCS"></p>
<p>Αυτή η μέθοδος είχε πολλά πλεονεκτήματα σε σχέση με τα local VCS. Για παράδειγμα όλοι ξέρουν τι αλλαγές έχει κάνει ο καθένας σε κάποιο project. Επίσης οι administrators έχουν πλήρη έλεγχο στο τι μπορεί να κάνει κάποιος και γενικά είναι πολύ πιο απλό να διαχειρίζεσαι ένα κεντρικοποιημένο VCS από το να έχει ο καθένας ένα τοπικό σύστημα στον υπολογιστή του. Παρόλα αυτά ένα τέτοιο σύστημα έχει και πολλά μειονεκτήματα. Το πιο σημαντικό είναι ότι βασίζεται σε ένα κεντρικό server που αποτελεί single point of failure. Αν για κάποιο λόγο αυτός ο server δεν είναι λειτουργικός για κάποιο διάστημα τότε για όσο διαρκεί το πρόβλημα δεν μπορούν να πραγματοποιηθούν αλλαγές από την ομάδα. Επίσης αν ο σκληρός δίσκος του server παρουσιάσει κάποια δυσλειτουργία τότε κινδυνεύει να χαθεί ολόκληρο το ιστορικό του project και όλες οι εκδόσεις που έχουν καταγραφεί.</p>
<h2 id="distributed-version-control-systems">Distributed Version Control Systems</h2>
<p>Τα μειονεκτήματα των Centralized VCS ήρθαν να καλύψουν τα Distributed VCS. Σε τέτοια συστήματα DVCS (όπως το Git) οι clients δεν κατεβάζουν μόνο την τελευταία έκδοση των αρχείων που θέλουν να επεξεργαστούν αλλά κατεβάζουν ολόκληρο το repository με το πλήρες ιστορικό του. Έτσι οποιοσδήποτε client μπορεί να επαναφέρει πλήρως ένα repository σε περίπτωση που οποιοσδήποτε server εμφανίσει κάποια δυσλειτουργία.
<img src="/images/git2.png" alt="Distributed VCS"></p>
<h1 id="εισαγωγή-στο-git">Εισαγωγή στο GIT</h1>
<h2 id="τι-είναι-το-git">Τι είναι το GIT</h2>
<p>Η κύρια διαφορά του GIT από τα υπόλοιπα VCS είναι ο τρόπος που διαχειρίζεται τα δεδομένα. Τα περισσότερα συστήματα VCS αποθηκεύουν την πληροφορία σαν ένα σύνολο από αρχεία και για κάθε αρχείο αποθηκεύουν τις αλλαγές που γίνονται στην διάρκεια του χρόνου. Αντιθέτως το Git διαχειρίζεται την πληροφορία σαν ένα σύνολο από snapshots (commits) των αρχείων που παρακολουθούνται. Κάθε φορά που πρέπει να καταγράφουν αλλαγές σε κάποια αρχεία το Git παίρνει ένα snapshot από το σύνολο των αρχείων και αποθηκεύει μια αναφορά σε αυτό το snapshot. Επίσης όλες οι λειτουργίες του Git μπορούν να πραγματοποιηθούν στον τοπικό υπολογιστή καθώς έχει το πλήρες repository με το αντίστοιχο ιστορικό. Το GIT για οποιαδήποτε αλλαγή αποθηκεύει παράγει πρώτα ένα checksum με τον μηχανισμό SHA-1 hash και αυτό χρησιμοποιείται σαν αναφορά για αυτή την αλλαγή. Αυτό προσφέρει ακεραιότητα δεδομένων καθώς το Git διασφαλίζει ότι δεν μπορούν να αλλάξουν τα περιεχόμενα οποιουδήποτε αρχείου χωρίς αυτό να γίνει αντιληπτό.
To Git έχει γνωρίσει μεγάλη επιτυχία και έχει γίνει το de-facto standard για distributed source control και ένα βασικό εργαλείο που πρέπει να μάθει κάποιος προκειμένουν να αρχίσει το ταξίδι του στον κόσμο του DevOps.</p>
<p>Συνιστούμε να επισκεφθείτε τα παρακάτω sites:</p>
<ul>
<li><a href="https://git-scm.com/">https://git-scm.com/</a> - Git Website &amp; Documentation</li>
<li><a href="https://www.freecodecamp.org/news/what-is-git-and-how-to-use-it-c341b049ae61/">https://www.freecodecamp.org/news/what-is-git-and-how-to-use-it-c341b049ae61/</a> - Γρήγορη εισαγωγή χωρίς να μπαίνει κανείς σε ιδιαίτερο βάθος, από τη γνωστή πλατφόρμα για μάθηση coding.</li>
</ul>
<h2 id="πλατφόρμες-για-git-repositories">Πλατφόρμες για Git Repositories</h2>
<p>To ίδιο το Git υπάρχει σε εκδόσεις για διάφορα λειτουργικά συστήματα ενώ συνοδεύεται και με εργαλεία όπως το Git Bash, Git Desktop, κλπ.
Υπάρχουν όμως και πλατφόρμες που βασίζονται στο Git και δίνουν υπηρεσίες Online Repository, είτε στο Internet, είτε σε Enterprise Επίπεδο.
Οι πιο γνωστές είναι το <a href="https://www.github.com">Github</a> και το <a href="https://www.gitlab.com">Gitlab</a>. Ειδικά το Gitlab μπορεί κάποιος να το εγκαταστήσει τοπικά και σε δωρεάν έκδοση, σε γνωστά λειτουργικά συστήματα, σε Docker/Kunernetes, ακόμα και σε ένα RaspberryPi! <a href="https://about.gitlab.com/install/">https://about.gitlab.com/install/</a></p>
<h1 id="git-basics">GIT Basics</h1>
<h2 id="οι-3-καταστάσεις-του-git">Οι 3 καταστάσεις του Git</h2>
<p>Οι 3 κύριες καταστάσεις αρχείων στο Git είναι :</p>
<ul>
<li><strong>Modified</strong>: Έχει γίνει αλλαγή σε κάποιο αρχείο αλλά δεν έχει γίνει commit στην βάση δεδομένων του Git.</li>
<li><strong>Staged</strong>: Έχει επιλεγεί κάποιο αρχείο από την τρέχουσα έκδοση έτσι ώστε στο επόμενο commit να αποθηκευτούν οι αλλαγές του στην επόμενη έκδοση που θα δημιουργηθεί.</li>
<li><strong>Committed</strong>: Τα δεδομένα έχουν αποθηκευτεί σωστά στην τοπική βάση δεδομένων του Git.</li>
</ul>
<p>Τα 3 μέρη ενός Git project είναι :</p>
<ul>
<li><strong>Working Directory</strong></li>
<li><strong>Staging Area</strong></li>
<li><strong>Git Repository</strong>
<img src="/images/git3.png" alt="Git Locations"></li>
</ul>
<h3 id="working-directory">Working Directory</h3>
<p>Είναι ένα checkout μιας έκδοσης του project. Τα αρχεία του working directory ανακτώνται από την βάση δεδομένων που βρίσκεται στο git directory έτσι ώστε να μπορούν να χρησιμοποιηθούν και να τροποποιηθούν.</p>
<h3 id="staging-area">Staging Area</h3>
<p>Περιέχεται στο Git directory και αποθηκεύει την πληροφορία σχετικά με το τι θα πρέπει να καταχωρηθεί στο επόμενο commit.</p>
<h3 id="git-repository-local">Git Repository (Local)</h3>
<p>Σε αυτό το directory το Git αποθηκεύει όλα τα metadata και την βάση δεδομένων των αλλαγών για το project. Είναι το πιο σημαντικό μέρος του Git και είναι αυτό που αντιγράφεται όταν γίνεται clone ένα απομακρυσμένο repository.</p>
<h3 id="git-workflow-local">Git workflow (Local)</h3>
<p>Το βασικό Git workflow ακολουθεί τα παρακάτω βήματα :</p>
<ol>
<li>Γίνονται αλλαγές στο working directory.</li>
<li>Επιλέγονται τα αρχεία που θα γίνουν add στο staging area έτσι ώστε να γίνουν μέρος των αλλαγών που θα αποθηκευτούν στο επόμενο commit.</li>
<li>Πραγματοποιείται commit. Σε αυτό το βήμα όλα τα αρχεία που βρίσκονται στο staging area αποθηκεύονται σε ένα snapshot που καταχωρείται στο git directory.</li>
</ol>
<h3 id="remote-repository">Remote Repository</h3>
<p>Αναφέραμε φυσικά για Distributed Version Control Systems, μιλήσαμε για πλατφόρμες για συνεργασια μέσω git, και κλωνοποίηση απομακρυσμένων (remote) repositories.
Στο git υποστηρίζεται ως location και το <strong>remote repository</strong>, ή όπως αλλιώς αναφέρεται &ldquo;<strong>upstream repository</strong>&quot;.
Ένα remote repository μπορεί να αποτελεί το σημείο που συγκλίνουν όλες οι προσπάθειες των developers που συμμετέχουν σε ένα code project, οι οποίοι συνεργάζονται ασύγχρονα. Προφανώς η οργάνωση του remote repository γίνεται με παρόμοιο τρόπο αλλά προϋποθέτει πολλά ακόμα βήματα για να μπορεί να γίνει σωστά η ασύγχρονη αυτή συνεργασία, να ελεχθεί αν κάποιος έχει δικαίωμα ή όχι να συγχρονιστεί με τον κώδικα στο remote repository, ή και να παρέχει ενημερώσεις, και πολλά άλλα.
Περισσότερα γι αυτό θα θίξουμε στους τομείς που θα αναφέρουμε για:</p>
<ul>
<li>Git Config</li>
<li>Git Pull</li>
<li>Git Push</li>
<li>Git Branching</li>
</ul>
<h2 id="δημιουργία-git-repository---git-init">Δημιουργία Git Repository - git init</h2>
<p>Οι πιο συνηθισμένοι τρόποι για την δημιουργία ενός Git Repository είναι :</p>
<ul>
<li>Μπορεί να μετατραπεί ένας φάκελος του τοπικού υπολογιστή (που δεν υπόκειται σε κάποιο version control) σε ένα Git Repository. Αυτό μπορεί να γίνει με τις παρακάτω εντολές :</li>
</ul>
<p>Σε Windows:</p>
<pre><code class="language-DOS" data-lang="DOS">$ cd C:/Users/user/my_project
$ git init
</code></pre><p>ή σε Linux:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Bash" data-lang="Bash">mkdir my_project
cd myproject
git init .
</code></pre></div><p>Έτσι δημιουργείται ένας φάκελος .git μέσα στον φάκελο του project όπου περιέχει όλα τα απαραίτητα αρχεία του repository (και όχι μόνο όπως θα δούθμε παρακάτω..)</p>
<h2 id="αντιγραφή-ενός-git-repository---git-clone">Αντιγραφή ενός Git Repository - git clone</h2>
<ul>
<li>Μπορεί να αντιγραφεί ή &ldquo;κλωνοποιηθεί&rdquo; (clone) όπως λέμε, ένα υπάρχον Git Repository από ένα απομακρυσμένο υπολογιστή/server. Αυτό μπορεί να γίνει με την εντολή git clone <!-- raw HTML omitted -->. Για παράδειγμα αν θες να κάνει clone το netprog_basics repository από το CiscoDevNet στο github τότε η εντολή είναι :</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Bash" data-lang="Bash">$ git clone https://github.com/CiscoDevNet/netprog_basics.git
</code></pre></div><p>Αυτή η εντολή θα δημιουργήσει ένα φάκελο netprog_basics που θα περιέχει ένα φάκελο .git ο οποίος περιλαμβάνει το πλήρες repository του project με το ιστορικό του. Επίσης θα γίνει check out η τελευταία έκδοση των αρχείων έτσι ώστε να είναι έτοιμα να επεξεργαστούν. Στην περίπτωση αυτή το cloned repository κρατάει τη σύνδεση του με το απομακρυσμένο directory, με το οποίο μπορεί να συγχρονιστεί εκ νέου, εφόσον χρειαστεί να ενημερωθούν τα αρχεία στις τρέχουσες εκδόσεις τους.</p>
<h2 id="καταγραφή-αλλαγών-στο-repository">Καταγραφή αλλαγών στο Repository</h2>
<p>Κάθε αρχείο στο repository Μπορεί να είναι σε μια από τις καταστάσεις <strong>tracked</strong> ή <strong>untracked</strong>. Tracked είναι τα αρχεία που αποτέλεσαν μέρος του τελευταίου snapshot και μπορεί να είναι <strong>unmodified</strong>, <strong>modified</strong> ή <strong>staged</strong>. Με λίγα λόγια τα αρχεία σε κατάσταση tracked είναι τα αρχεία που παρακολουθεί το Git. Untracked είναι όλα τα υπόλοιπα αρχεία στον φάκελο που δεν παρακολουθούνται.</p>
<h3 id="git-status">Git status</h3>
<p>Η κύρια εντολή που χρησιμοποιείται για την παρακολούθηση της κατάστασης των αρχείων είναι <strong>git status</strong> :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Bash" data-lang="Bash">$ git status
On branch master
Your branch is up-to-date with <span style="color:#e6db74">&#39;origin/master&#39;</span>.
nothing to commit, working tree clean
</code></pre></div><p>Αυτό σημαίνει ότι το working directory είναι clean δηλαδή δεν υπάρχει αλλαγή σε κάποιο από τα αρχεία που είναι σε κατάσταση tracked. Τώρα έστω ότι προσθέτουμε ένα απλό αρχείο README στο working directory και εκτελούμε ξανά την εντολή <strong>git status</strong> :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Bash" data-lang="Bash">$ echo <span style="color:#e6db74">&#39;My Project&#39;</span> &gt; README
$ git status
On branch master
Your branch is up-to-date with <span style="color:#e6db74">&#39;origin/master&#39;</span>.
Untracked files:
  <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git add &lt;file&gt;...&#34;</span> to include in what will be committed<span style="color:#f92672">)</span>

    README

nothing added to commit but untracked files present <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git add&#34;</span> to track<span style="color:#f92672">)</span>
</code></pre></div><h3 id="git-add">Git Add</h3>
<p>Βλέπουμε ότι το αρχείο που προστέθηκε είναι στην κατάσταση untracked οπότε το Git δεν παρακολουθεί τις αλλαγές του. Ουσιαστικά πρόκειται για ένα αρχείο που δεν ήταν μέρος του τελευταίου snapshot (commit). Αν θέλουμε τώρα να αλλάξουμε την κατάσταση του αρχείου σε tracked  έτσι ώστε να παρακολουθείται από το Git θα πρέπει να εκτελέσουμε την εντολή <strong>git add</strong> :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Bash" data-lang="Bash">$ git add README
If you run your status command again, you can see that your README file is now tracked and staged to be committed:

$ git status
On branch master
Your branch is up-to-date with <span style="color:#e6db74">&#39;origin/master&#39;</span>.
Changes to be committed:
  <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git restore --staged &lt;file&gt;...&#34;</span> to unstage<span style="color:#f92672">)</span>

    new file:   README
</code></pre></div><p>Πλέον θεωρούμε ότι το αρχείο είναι staged καθώς είναι κάτω από το “Changes to be committed”.  Έστω ότι τροποποιούμε τώρα ένα ήδη υπάρχον tracked αρχείο CONTRIBUTING.md και εκτελούμε πάλι την εντολή <strong>git status</strong> :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Bash" data-lang="Bash">$ git status
On branch master
Your branch is up-to-date with <span style="color:#e6db74">&#39;origin/master&#39;</span>.
Changes to be committed:
  <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git reset HEAD &lt;file&gt;...&#34;</span> to unstage<span style="color:#f92672">)</span>

    new file:   README

Changes not staged <span style="color:#66d9ef">for</span> commit:
  <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git add &lt;file&gt;...&#34;</span> to update what will be committed<span style="color:#f92672">)</span>
  <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git checkout -- &lt;file&gt;...&#34;</span> to discard changes in working directory<span style="color:#f92672">)</span>

    modified:   CONTRIBUTING.md
</code></pre></div><p>To αρχείο CONTRIBUTING.md είναι κάτω από το “Changes not staged for commit” που σημαίνει ότι έχουν γίνει αλλαγές στο αρχείο αλλά δεν είναι staged. Για να γίνει staged θα πρέπει να γίνει και αυτό <strong>git add</strong> :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Bash" data-lang="Bash">$ git add CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with <span style="color:#e6db74">&#39;origin/master&#39;</span>.
Changes to be committed:
  <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git reset HEAD &lt;file&gt;...&#34;</span> to unstage<span style="color:#f92672">)</span>

    new file:   README
    modified:   CONTRIBUTING.md
</code></pre></div><p>Τώρα και τα δύο αρχείο είναι staged και θα αποτελέσουν μέρος του snapshot που θα δημιουργηθεί στο επόμενο commit. Έστω ότι σε αυτό το σημείο γίνεται μια ακόμα τροποποίηση στο αρχείο CONTRIBUTING.md πριν εκτελεστεί το commit :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Bash" data-lang="Bash">$ git status
On branch master
Your branch is up-to-date with <span style="color:#e6db74">&#39;origin/master&#39;</span>.
Changes to be committed:
  <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git reset HEAD &lt;file&gt;...&#34;</span> to unstage<span style="color:#f92672">)</span>

    new file:   README
    modified:   CONTRIBUTING.md

Changes not staged <span style="color:#66d9ef">for</span> commit:
  <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git add &lt;file&gt;...&#34;</span> to update what will be committed<span style="color:#f92672">)</span>
  <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git checkout -- &lt;file&gt;...&#34;</span> to discard changes in working directory<span style="color:#f92672">)</span>

    modified:   CONTRIBUTING.md
</code></pre></div><p>Παρατηρούμε ότι το αρχείο CONTRIBUTING.md είναι ταυτόχρονα και staged και unstaged. Αυτό γίνεται γιατί το Git κάνει stage ένα αρχείο στην κατάσταση ακριβώς που βρισκόταν όταν εκτελέστηκε το git add. Οπότε αφού έγιναν και πάλι αλλαγές στο αρχείο για να γίνει staged στην νέα του μορφή θα πρέπει να εκτελεστεί και πάλι η εντολή git add έτσι ώστε στο επόμενο commit να αποθηκευτεί η πιο updated έκδοση του αρχείου :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Bash" data-lang="Bash">$ git add CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with <span style="color:#e6db74">&#39;origin/master&#39;</span>.
Changes to be committed:
  <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git reset HEAD &lt;file&gt;...&#34;</span> to unstage<span style="color:#f92672">)</span>

    new file:   README
    modified:   CONTRIBUTING.md
</code></pre></div><h2 id="ομαδική-προσθήκη-αρχείων-στο-working-directory">Ομαδική προσθήκη αρχείων στο working directory</h2>
<p>Είδαμε πως προσθέτουμε ένα - ένα αρχείο στο working directory, ώστε στη συνέχεια να γίνει staged και στη συνέχεια να δημιουργηθεί ένα snapshot με το <strong>git commit</strong>.</p>
<p>Αν όμως δουλεύουμε με περισσότερα αρχεία και θέλουμε να τα προσθέσουμε όλα στο working directory; Τότε μπορούμε να χρησιμοποιήσουμε την εντολή git add με διαφορετικά ορίσματα, πχ.</p>
<ul>
<li>git add . (προσθέτει όλα τα αρχεία στο τρέχον directory, αν κάποια έχουν ήδη προστεθεί, προστίθενται αυτά που λείπουν)</li>
<li>git add * (το ίδιο με το προηγούμενο)</li>
<li>git add *.py (μόνο τα αρχεία που έχουν extension &lsquo;.py&rsquo;)</li>
</ul>
<h2 id="git-configuration">Git Configuration</h2>
<h3 id="γενικά">Γενικά</h3>
<p>Μέχρι τώρα έχουμε δει εντολές που δεν χρειάζονται ιδιαίτερες ρυθμίσεις στο τοπικό μας repository. Ωστόσο προτού προχωρήσουμε στην οριστική υποβολή των αρχείων του repository για τη δημιουργία ενός <em>snapshot</em> ή <em><strong>commit</strong></em> όπως λέγεται, πρέπει να περάσουμε κάποιες βασικές ρυθμίσεις στο repository μας.</p>
<h3 id="git-config-scopes">Git Config Scopes</h3>
<p>Οι ρυθμίσεις για το git ορίζονται σε τρία βασικά επίπεδα:</p>
<ul>
<li><em>Global</em>: Ορίζονται σε επίπεδο χρήστη για όλα τα πιθανά repositories που θα ορίσει ο χρήστης. Συνήθως σε linux systems βρίσκονται σε hidden dir .git κάτω από το home directory του χρήστη.</li>
<li><em>System</em>: Ορίζονται σε επίπεδο συστήματος και σε linux συστήματα βρίκονται συνήθως στο /etc/ directory. Δεν είναι σύνηθες να ορίζονται ρυθμίσεις σε αυτό το επίπεδο, η ανάπτυξη μέσω git έχει μεγάλη σχέση με την ταυτότητα του εκάστοτε χρήστη.</li>
<li><em>Local</em>: Ορίζονται ανά project directory. Συνήθως βρίσκονται σε hidden dir .git στο directory του project.</li>
</ul>
<h3 id="basic-configuration">Basic configuration</h3>
<p>To Git διατηρεί τα αρχεία του σε hidden directory εντός του project όπου αποθηκεύονται δεδομένα και ρυθμίσεις με όνομα .git .
Ωστόσο διατηρεί και global ρυθμίσεις σε κεντρικό directory.
Το λιγότερο που μπορεί/πρέπει κανείς να ρυθμίσει στο .git/config αρχείο είναι με τις παρακάτω εντολές:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Bash" data-lang="Bash">git config user.name <span style="color:#e6db74">&#34;John Doe&#34;</span>
git config user.email johndoe@example.com
</code></pre></div><p>Οι ρυθμίσεις μπορούν να γίνουν είτε σε τοπικό επίπεδο ανά project directory είτε σε καθολικό (global) επίπεδο:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Bash" data-lang="Bash">$ git config --global user.name <span style="color:#e6db74">&#34;John Doe&#34;</span>
$ git config --global user.email johndoe@example.com
</code></pre></div><h3 id="προβολή-config">Προβολή Config</h3>
<p>Με τις εντολές git config μαζί με τον ορισμό του scope μπορούμε να ρυθμίσουμε, να ακυρώσουμε ρυθμίσεις και να δούμε τις τρέχουσες ρυθμίσεις. Η προβολή των τρεχουσών ρυθμίσεων για το τοπικό project dir γίνεται με την εντολή:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">git config --local --list
</code></pre></div><p>ή</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">git config --list
</code></pre></div><p>(το local είναι το default).
Αντικαθιστώντας την λέξη local με <em>system</em> ή <em>global</em> βλέπουμε τις αντίστοιχες ρυθμίσεις σε επίπεδο <em>system</em> ή <em>global</em>.
Παρακάτω βλέπουμε ένα τυπικό output αν δεν έχουμε κάνει τίποτε άλλο πέραν του init:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">core.repositoryformatversion<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>
core.filemode<span style="color:#f92672">=</span>true
core.bare<span style="color:#f92672">=</span>false
core.logallrefupdates<span style="color:#f92672">=</span>true
</code></pre></div><p>Μπορούμε αντίστοιχα να δούμε το αρχείο ρυθμίσεων:</p>
<pre><code class="language-#" data-lang="#">[core]
        repositoryformatversion = 0
        filemode = true
        bare = false
        logallrefupdates = true
</code></pre><h3 id="προαπαιτούμενες-ρυθμίσεις">Προαπαιτούμενες ρυθμίσεις</h3>
<p>To git θα αρνηθεί να προχωρήσει σε commit αν δεν έχουμε ορίσει τις εξής βασικές παραμέτρους που αναφέραμε νωρίτερα:</p>
<ul>
<li><em>user.name</em></li>
<li><em>user.email</em></li>
</ul>
<p>Εκτός της χρήσης των εντολών:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">git config user.name &lt;user name&gt;
git config user.email &lt;user email&gt;
</code></pre></div><p>Διαφορετικά μπορεί κανείς να κάνει κατευθείαν edit το αρχείο:</p>
<pre><code class="language-#" data-lang="#">[core]
        repositoryformatversion = 0
        filemode = true
        bare = false
        logallrefupdates = true
[user]
        email = user1@example.com
        name = user1name
</code></pre><p>Με αντίστοιχο τρόπο ορίζονται και άλλες παράμετροι οι οποίες παίζουν ρόλο είτε για λειτουργία σε τοπικό επίπεδο είτε για λειτουργία με απομακρυσμένα repositories.
Ενδεχομένως να χρειαστεί να οριστεί και η παράμετρος <em><strong>http.sslVerify</strong></em> σε <em><strong>False</strong></em>.</p>
<p>Τώρα είμαστε έτοιμοι να προχωρήσουμε σε commit!</p>
<h2 id="git-commit">Git commit</h2>
<p>Αφού έχει ολοκληρωθεί η δημιουργία του staging area (και έχουμε ολοκληρώσει τις βασικές ρυθμίσεις) το επόμενο βήμα είναι να γίνουν commit οι αλλαγές. Οποιοδήποτε αρχείο έχει τροποποιηθεί ή έχει δημιουργηθεί και δεν έχει προστεθεί με git add δεν θα αποτελέσει μέρος του επόμενου commit.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Bash" data-lang="Bash">git commit
</code></pre></div><p>Συνήθως κατά το git commit μας ζητείται να ορίσουμε ένα σύντομο μήνυμα που συνοδεύει το συγκεκριμένο commit.
Για να οριστεί κατευθείαν το μήνυμα παράλληλα με το commit, μπορούμε να χρησιμοποιήσουμε την ίδια εντολή με μια μικρή παραλλαγή:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Bash" data-lang="Bash">git commit -am <span style="color:#e6db74">&#34;Commit Message&#34;</span>
</code></pre></div><p>Παρακάτω φαίνεται ο κύκλος ζωής της κατάστασης των αρχείων στο Git:
<img src="/images/git4.png" alt="Git Circle of Life"></p>
<h2 id="git-log">Git Log</h2>
<p>Βασικό πλεονέκτημα όπως είπαμε των Source Control systems είναι η δυνατότητα να διαχωρίσουμε την πορεία ενός coding project σε διαφορετικά snapshots στο χρόνο και να μπορούμε, αν χρειαστεί, να μετακινηθούμε προς τα πίσω σε συγκεκριμένα σημεία στο &ldquo;παρελθόν&rdquo;.
Η παρακολούθηση της πορείας των διαδοχικών commits αλλά γενικά και των συμβάντων κατά τη χρήση του git, προκύπτει με τη χρήση της εντολής git log:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Bash" data-lang="Bash">git log

ή 
git log --oneline <span style="color:#f92672">(</span>πολύ διαδεδομένο για να δείχνει κάθε commit σε μόνο μια γραμμή ώστε να φαίνεται συνοπτικά όλο το commit history<span style="color:#f92672">)</span>
</code></pre></div><p>Ειδικά η δεύτερη σύνθεση της εντολής δίνει μια λίστα όπου σε κάθε γραμμή φαίνεται αριστερά ένα hash value για το συγκεκριμένο commit, και το μήνυμα με το οποίο έχει αποθηκευτεί το commit (αυτό που ορίσαμε με το option -am). To hash value είναι ιδιαίτερα σημαντικό για ενέργειες που αφορούν την επιστροφή σε προηγούμενα σημεία του git history.</p>
<p>Π.χ. αν τρέξουμε το command στο repository όπου γράφουμε το παρόν, παίρνουμε το παρακάτω:</p>
<pre><code class="language-git" data-lang="git">1771f5a (HEAD -&gt; master) more changes
b123574 changing..
2ff0bc8 first blocks to introduction to Git
b941b52 Test commit
d4e87c3 updated intro to docker
f844640 added intro to docker
</code></pre><p>Βλέπουμε ότι υπάρχει κι άλλη πληροφορία εδώ.. π.χ. τί είναι το HEAD -&gt; master) ; Μην βιάζεστε, περισσότερα γι αυτό παρακάτω.</p>
<p>Παραπομπές για git log:</p>
<ul>
<li><a href="https://www.thegeekstuff.com/2014/04/git-log/">https://www.thegeekstuff.com/2014/04/git-log/</a></li>
<li><a href="https://git-scm.com/book/en/v2/Git-Basics-Viewing-the-Commit-History">https://git-scm.com/book/en/v2/Git-Basics-Viewing-the-Commit-History</a></li>
<li><a href="https://git-scm.com/docs/git-log">https://git-scm.com/docs/git-log</a> (documentation για το git log)</li>
</ul>
<h2 id="git-head">Git Head</h2>
<p>To Head είναι ο pointer που δείχνει που βρισκόμαστε στο git history αυτή τη στιγμή. H &ldquo;χειραγώγηση&rdquo; του HEAD ώστε να δείχνει στο σημείο που θέλουμε είναι πολύ βασικό εργαλείο τόσο για την μετακίνηση στο Git History όσο και μεταξύ Git Branches.
Περισσότερα στις περιγραφές των :</p>
<ul>
<li>Git Checkout</li>
<li>Git Reset</li>
<li>Get Revert</li>
</ul>
<h1 id="αναίρεση-αλλαγών">Αναίρεση αλλαγών</h1>
<h2 id="αναίρεση-unstaged-αλλαγών">Αναίρεση unstaged αλλαγών.</h2>
<p>Aς πούμε ότι κάνετε μια αλλαγή και θέλετε να την αναιρέσετε. Αν είχατε προηγουμένως κάνει commit και τρέξετε το git status, θα πάρετε μια απάντηση για το ότι υπάρχουν modified αρχεία, π.χ.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Bash" data-lang="Bash">$git status
On branch master
Your branch is ahead of <span style="color:#e6db74">&#39;origin/master&#39;</span> by <span style="color:#ae81ff">4</span> commits.
  <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git push&#34;</span> to publish your local commits<span style="color:#f92672">)</span>

Changes not staged <span style="color:#66d9ef">for</span> commit:
  <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git add &lt;file&gt;...&#34;</span> to update what will be committed<span style="color:#f92672">)</span>
  <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git restore &lt;file&gt;...&#34;</span> to discard changes in working directory<span style="color:#f92672">)</span>
        modified:   content/posts/introduction_to_git.md

no changes added to commit <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git add&#34;</span> and/or <span style="color:#e6db74">&#34;git commit -a&#34;</span><span style="color:#f92672">)</span>
</code></pre></div><p>Σας αναφέρει ξεκάθαρα &ldquo;Changes not staged for commit&rdquo;.
Αν θέλετε να γυρίσετε στην προηγούμενη έκδοση ή θα πρέπει να ακολουθήσετε τις οδηγίες για το git restore, ή μπορείτε να τρέξετε την εντολή git checkout με όρισμα το αρχείο που είναι modified, π.χ.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Bash" data-lang="Bash">$git checkout content/posts/introduction_to_git.md
Updated <span style="color:#ae81ff">1</span> path from the index
</code></pre></div><p>Το αποτέλεσμα είναι να αναιρεθούν οι αλλαγές και το αρχείο αυτό να επιστρέψει στη μορφή που είχε στο τελευταίο commit. Αν τρέξετε και πάλι git status, θα δείτε ότι το τοπικό working tree είναι καθαρό.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Bash" data-lang="Bash">$ git status
On branch master
Your branch is ahead of <span style="color:#e6db74">&#39;origin/master&#39;</span> by <span style="color:#ae81ff">4</span> commits.
  <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git push&#34;</span> to publish your local commits<span style="color:#f92672">)</span>

nothing to commit, working tree clean
</code></pre></div><p>(Προφανώς όταν το έκανα αυτό έχασα τις αλλαγές και ευτυχώς τις είχα αποθηκεύσει αλλού ώστε να τις αποκαταστήσω, γιατί όσο αφορά το git, είχαν αναιρεθεί!)
Το git checkout έχει και άλλες χρήσεις, αλλά προς το παρόν ας μείνουμε εντός θέματος στην αναίρεση αλλαγών.</p>
<h2 id="αναίρεση-staging">Αναίρεση staging</h2>
<p>Έστω ότι προχωρήσατε παρακάτω. Κάνατε stage τς αλλαγές με git add αλλά το μετανιώσατε. Θέλετε να γυρίσετε προς τα πίσω, δηλαδή να κρατήσετε προς το παρόν τις αλλαγές, αλλά να μην είναι πλέον staged. Ή θα χρησιμοποιήσετε την εντολή που σας προτείνει το git, την git restore &ndash;staged με όρισμα το αρχείο που έγινε stage, ή θα χρησιμοποιήσετε την εντολή git reset. Π.χ.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Bash" data-lang="Bash">$ git status
On branch master
Your branch is ahead of <span style="color:#e6db74">&#39;origin/master&#39;</span> by <span style="color:#ae81ff">4</span> commits.
  <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git push&#34;</span> to publish your local commits<span style="color:#f92672">)</span>

Changes to be committed:
  <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git restore --staged &lt;file&gt;...&#34;</span> to unstage<span style="color:#f92672">)</span>
        modified:   content/posts/introduction_to_git.md

$ git reset content/posts/introduction_to_git.md
Unstaged changes after reset:
M       content/posts/introduction_to_git.md
$ git status
On branch master
Your branch is ahead of <span style="color:#e6db74">&#39;origin/master&#39;</span> by <span style="color:#ae81ff">4</span> commits.
  <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git push&#34;</span> to publish your local commits<span style="color:#f92672">)</span>

Changes not staged <span style="color:#66d9ef">for</span> commit:
  <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git add &lt;file&gt;...&#34;</span> to update what will be committed<span style="color:#f92672">)</span>
  <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git restore &lt;file&gt;...&#34;</span> to discard changes in working directory<span style="color:#f92672">)</span>
        modified:   content/posts/introduction_to_git.md

no changes added to commit <span style="color:#f92672">(</span>use <span style="color:#e6db74">&#34;git add&#34;</span> and/or <span style="color:#e6db74">&#34;git commit -a&#34;</span><span style="color:#f92672">)</span>
</code></pre></div><p>Το αρχείο δεν είναι πλέον staged αρά παραμένει modified.</p>
<h2 id="αναίρεση-commit">Αναίρεση commit</h2>
<p>Όταν έχει γίνει το commit μπορούμε να γυρίσουμε πίοω ή κατά ένα commit ή για περισσότερα. Οι αλλαγές αναιρούνται σειριακά. Αν γυρίσουμε πίσω τρία commits, τότε ότι έχει γίνει ενδιάμεσα δεν θα υπάρχει πια. Υπάρχουν δύο τρόποι να το πετύχουμε αυτό. Είτε ορίζοντας τον αριθμό των commits που θέλουμε να πάμε πίσω είτε ορίζοντας το hash του commit που θέλουμε να πάμε. Δηλαδή:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Bash" data-lang="Bash">$ git log --all --decorate --oneline
530cfac <span style="color:#f92672">(</span>HEAD -&gt; master<span style="color:#f92672">)</span> writing git reset
03b1d5e <span style="color:#f92672">(</span>origin/master, origin/HEAD<span style="color:#f92672">)</span> working on git reset
cb6ede2 Working on git reset
a2e1f4b working on commit
6a66aa2 working on git reset
5448ed2 ready to share with the team
1e62faa git log, head, remote repo
1771f5a more changes
b123574 changing..
7d77268 Merge branch <span style="color:#e6db74">&#39;master&#39;</span> of https://github.com/netautogr/hugo adding content <span style="color:#66d9ef">for</span> <span style="color:#e6db74">&#39;Introduction to Git&#39;</span>
2ff0bc8 first blocks to introduction to Git
</code></pre></div><p>Προτού προχωρήσουμε είναι σημαντικό να καταλάβουμε τα τρία options που έχουμε για το git reset: soft, mixed και hard. Κάθε μια από τις παρακάτω εντολές μπορούν να χρησιμοποιηθούν και για μεμονωμένα αρχεία.</p>
<h3 id="git-reset-head---soft">git reset HEAD~ &ndash;soft</h3>
<p>Ο HEAD πάει πίσω στο αμέσως προηγούμενο commit και τα τωρινά περιεχόμενα του φακέλου (ότι διαφέρει) εμφανίζονται ως unstaged.</p>
<h3 id="git-reset-head---mixed">git reset HEAD~ &ndash;mixed</h3>
<p>Ο HEAD πάει πίσω στο αμέσως προηγούμενο commit και τα τωρινά περιεχόμενα του φακέλου (ότι διαφέρει) εμφανίζονται ως staged. Είναι και η προεπιλογή οπότε η εντολή git reset HEAD~ έχει ακριβώς το ίδιο αποτέλεσμα (χωρίς option)</p>
<h3 id="git-reset-head---hard">git reset HEAD~ &ndash;hard</h3>
<p>Ο HEAD πάει πίσω στο αμέσως προηγούμενο commit και τα τωρινά περιεχόμενα του φακέλου (ότι διαφέρει) διαγράφονται.</p>
<h3 id="git-reset-headnumber">git reset HEAD~<!-- raw HTML omitted --></h3>
<p>Ο HEAD πάει πίσω όσα commit ορίσουμε με το νουμερο. Προφανώς μπορεί να συνδυαστεί με τα options που αναφέραμε νωρίτερα.</p>
<h3 id="git-reset-head">git reset HEAD</h3>
<p>Γυρνάμε στο HEAD το ίδιο</p>
<h3 id="git-reset-hash-file">git reset <!-- raw HTML omitted --> <!-- raw HTML omitted --></h3>
<p>Σημαίνει &ldquo;τράβα το αρχείο <!-- raw HTML omitted --> από το commit με hash <!-- raw HTML omitted -->&rdquo; (αντί να το τραβήξουμε από το commit που δείχνει ο ΗEAD).</p>
<h2 id="git-revert">Git Revert</h2>
<p>Όπως αναφέραμε όταν κάνουμε <code>git reset --hard</code>, τα περιεχόμενα που είχαμε διαγράφονται οριστικά. Το git reset έχει γενικά και τη συνέπεια ότι το ενδιάμεσο git history που είχε καταγραφεί με τις αλλαγές που θέλουμε να αναιρέσουμε, διαγράφεται επίσης!</p>
<p><strong>Τί γίνεται αν θέλουμε να &ldquo;επιστρέψουμε στο παρελθόν&rdquo; στο στυλ που το έκαναν οι εκδικητές στο &ldquo;Endgame&rdquo;?</strong> Δηλαδή όπως λέει κι ο HULK, όταν επιστρέφεις στο παρελθόν <em><strong>&ldquo;your past is now your future&rdquo;</strong></em>!
Θέλουμε δηλαδή να φαίνεται η πορεία που είχαμε μέχρις εδώ, ότι αναιρέσαμε μια συγκεκριμένη αλλαγή, και μετά συνεχίσαμε από εκεί.
Για το σκοπό αυτό μπορούμε να χρησιμοποιήσουμε την εντολή</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Bash" data-lang="Bash">git revert 
</code></pre></div><p>Η σύνταξη είναι η ίδια. Μας επιτρέπει να κάνουμε ένα <em>&ldquo;selective undo&rdquo;</em> για συγκεκριμένο commit διατηρώντας το history μέχρι τώρα. To revert που κάναμε σημειώνεται μπροστά στο git history. Προφανώς ανάλογα με το τί προέκυψε από το revert ενδεχομένως να φτάσουμε στο ίδιο σημείο που περιγράφουμε παρακάτω, με &ldquo;ασύμβατες αλλαγές&rdquo;. Ας μην προτρέχουμε όμως. Συνεχίστε να διαβάζετε ;)</p>
<h1 id="branching--merging">Branching &amp; Merging</h1>
<p>Η ιδέα πίσω από το branching είναι αυτή της παράλληλης ανάπτυξης νέων features ή παραλλαγών του βασικού κώδικα. Γενικά το git έχει ως σκοπό την οργανωμένη και ασύγχρονη ανάπτυξη κώδικα από πολλαπλές συνεργαζόμενες πλευρές. Όμως δεν είναι ανάγκη να εργάζονται όλοι πάνω σε μία και μοναδική έκδοση του κώδικα που μπορεί να είναι και ο παραγωγικός κώδικας. Μπορούν τα νέα features να αναπτύσσονται σε εκδόσεις του κώδικα οι οποίες &ldquo;διακλαδίζονται&rdquo; (<em>branch</em>) από τη βασική και όταν είναι έτοιμα, ο κώδικας τους &ldquo;συγχωνεύεται&rdquo; (<em>merge</em>) ξανά με τη βασική.</p>
<p>Άλλη περίπτωση που το branching είναι πολύ χρήσιμο είναι η περίπτωση του κώδικα δοκιμώμ (<em>test branch</em>). Στην περίπτωση αυτή μπορεί στο test branch αυτό να αναπτύσσεται ο κώδικας ο οποίος προκύπτει από τη βασική έκδοση (<em>main/master branch</em> - ναι γιατί έχουμε να λάβουμε υπόψη και την political correctness, τρομάρα μας), ο οποίος τακτικά όταν ολοκληρώνεται ένας κύκλος δοκιμών γίνεται merge πίσω στο βασικό κλάδο.</p>
<h2 id="branching">Branching</h2>
<p>Η δημιουργία ενός branch από το βασικό και η αλλαγή πάνω σε αυτό τον κλάδο μπορεί να γίνει με δύο τρόπους:</p>
<ul>
<li>Πρώτα δημιουργία του κλάδου και μετά αλλαγή σε αυτών σε δύο βήματα:</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Bash" data-lang="Bash">git branch &lt;branch-name&gt;
git checkout &lt;brach-name&gt;
</code></pre></div><ul>
<li>Δημιουργία του κλάδου και αλλαγή σε αυτόν σε ένα βήμα:</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Bash" data-lang="Bash">git checkout -b &lt;branch-name&gt;
</code></pre></div><p>Μπορούμε να γυρίσουμε πίσω στον βασικό κλάδο με</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Bash" data-lang="Bash">git checkout master
</code></pre></div><p>Κάθε φορά που αλλάζουμε κλάδο, τα περιεχόμενα του working directory αλλάζουν για να αντικατατοπτρίσουν την εικόνα του συγκεκριμένου κλάδου.</p>
<h2 id="merging">Merging</h2>
<p>Όταν τελειώσουμε την επεξεργασία του διαχωροσμένου κλάδου έρχεται η στιγμή που πρέπει να συγχωνευτεί με τον κύριο κλάδο. Αυτό γίνεται με χρήση της εντολής merge. Για να κάνουμε merge πρέπει να βρισκόμαστε στον κλάδο με τον οποίο θέλουμε να συγχωνευτεί ο διαχωρισμένος. Για να συγχωνεύσουμε τον κλάδο test-feature1 στον master πρέπει πρώτα να επιστρέψουμε στο master και μετά να εκδώσουμε την εντολή merge:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Bash" data-lang="Bash">git checkout master
git merge test-feature1
</code></pre></div><p>Τα αποτελέσματα της εντολής merge εξαρτώνται από το τί έχει συμβεί στο μεταξύ από όταν είχε δημιουργηθεί ο κλάδος test-feature1 και τι πορεία είχε στο μεταξύ ο κύριος κλάδος. Τρία είναι τα βασικά ενδεχόμενα:</p>
<ul>
<li>Δεν έχει γίνει καμία αλλαγή στον κύριο κλάδο.
Αυτό που θα συμβεί σε αυτή την περίπτωση είναι γνωστό και ως Fast Forward Merge, δηλαδή ο HEAD απλώς μετακινείται στο τελευταίο commit του test-feature1 κλάδου και αυτά είναι πλέον τα περιεχόμενα του master branch</li>
<li>Έχουν γίνει αλλαγές και στον κύριο κλάδο αλλά δεν είναι αντικρουόμενες και η συγχώνευση ολοκληρώνεται χωρίς πρόβλημα.</li>
<li>Έχουν γίνει αλλαγές και στον κύριο κλάδο, οι οποίες δεν είναι συμβατές με τις αλλαγές που έχουν γίνει στον κλαδο test-feature1. Σε αυτή την περίπτωση υπάρχει <strong>σύγκρουση</strong> (<em>conflict</em>). To git θα μας πληροφορήσει σχετικά και θα μας παρουσιάσει τη σύγκριση των δύο κλάδων. Είτε στο command line είτε σε κάποιο IDE που χρησιμοποιούμε, θα πρέπει χειροκίνητα να επέμβουμε και να διορθώσουμε τη σύγκρουση : 1) αποδεχόμενοι το κομμάτι του κλάδου test-feature1, 2) αποδεχόμενοι το κκομμάτι του κύριου κλάδου, 3) κάνοντας edit το τμήμα της σύγκρουσης όπως νομίζουμε.
Με ότι καταλήξουμε, εφόσον κάνουμε εκ νέου commit, αυτό θα μείνει πλέον ως merged περιεχόμενο στον κύριο κλάδο.</li>
</ul>
<h2 id="διαγραφή-και-έλεγχος-branches">Διαγραφή και έλεγχος branches</h2>
<p>Στη συνέχεια μπορούμε αν θέλουμε να διαγράψουμε τον κλάδο που είχαμε δημιουργήσει με την εντολή:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Bash" data-lang="Bash">git branch -d &lt;branch-name&gt;
</code></pre></div><p>Μπορούμε να δούμε όλα τα branches με την εντολή:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Bash" data-lang="Bash">git branch --all
</code></pre></div><p>Εφόσον λειτουργούμε σε ένα πλαίσιο CI/CD (<em>Continuous Integration/Continuous Deployment/Delivery</em>) ενδεχομένως κάποια branches να αναπτύσσονται συνεώς και ο κώδικας που αναπτύσσεται σε ξεχωριστό περιβάλλον π.χ το test brach πιθανόν να γίνεται deploy μετά από κάθε commit στο test περιβάλλον.</p>
<p>Αν θέλει κανείς να δει το ιστορικό των commit&rsquo;s διευκολύνοντας μας στην παρακολούθηση των branching and merging, μπορεί να εκτελέσει την παρακάτω εντολή:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Bash" data-lang="Bash">git log --all --decorate --oneline --graph

* 6e596fb <span style="color:#f92672">(</span>HEAD -&gt; master, origin/master, origin/HEAD<span style="color:#f92672">)</span> finishing merging
* 530cfac writing git reset
* 03b1d5e working on git reset
* cb6ede2 Working on git reset
* a2e1f4b working on commit
* 6a66aa2 working on git reset
* 5448ed2 ready to share with the team
* 1e62faa git log, head, remote repo
* 1771f5a more changes
* b123574 changing..
*   7d77268 Merge branch <span style="color:#e6db74">&#39;master&#39;</span> of https://github.com/netautogr/hugo adding content <span style="color:#66d9ef">for</span> <span style="color:#e6db74">&#39;Introduction to Git&#39;</span>
|<span style="color:#ae81ff">\ </span> 
| * b941b52 Test commit
* | 2ff0bc8 first blocks to introduction to Git
|/  
</code></pre></div><h1 id="δουλεύοντας-με-repote-repositories">Δουλεύοντας με repote repositories</h1>
<h2 id="γενικά-1">Γενικά</h2>
<p>Από τη στιγμή που κάποιος αναπτύσσει μέσα σε μια ομάδα, έχει πλέον νόημα η χρήση remote online repositories όπου θα γίνεται συγχρονισμός και θα καθορίζεται η συνεργασία με το πλαίσιο που ορίζει το git. Οι προβλεπόμενες δομές και διαδικασίες προχωράνε σε βάθος, ωστόσο για αρχή θα πρέπει κάποιος να ορίσει τις αντίστοιχες ρυθμίσεις για το remote repository και τον τρόπο login/authenticate σε αυτό.
Εφόσον η ανάπτυξη γίνεται με κάποιο IDE που είναι <em>git friendly</em>, oι ρυθμίσεις αυτές θα πρέπει να προσαρμοστούν και να συνδυαστούν με αντίστοιχες ρυθμίσεις εντός του IDE, ώστε οι βασικές ενέργειες που εκτελούνται με το Git να μπούν να εκτελεστούν με μεγάλη ευκολία με το GUI του IDE.</p>
<h2 id="public--private-repositoriesservers">Public &amp; Private Repositories/Servers</h2>
<p>Η συνεργασία δεν έχει νόημα αν δεν <em>ανεβεί</em> περιεχόμενο σε server που να έχουν πρόσβαση και άλλοι developers. Γνωστά sites που δίνουν τέτοια δυνατότητα είτε για δημόσια repositories ή για repositories περιορισμένης πρόσβασης, είναι το Github - <a href="https://github.com">https://github.com</a> και το Gitlab - <a href="https://about.gitlab.com/">https://about.gitlab.com/</a> .
Αν θέλετε να στήσετε ιδιωτικό repository στο enterprise περιβάλλον που εργάζεστε, αυτό είναι σαφέστατα πιο εύκολο με το gitlab το οποίο διαθέτει και έκδοση δωρεάν για τέτοιο σκοπό. Το πως μπορεί κανείς να στήσει το gitlab σε τέτοια μορφή είναι πέρα από το scope του παρόντος άρθρου.
Το Gitlab διαθέτει και ενισχυμένες δυνατότητες για enterprise level DevOps (CI/CD κλπ) στο ίδιο προϊόν. Από την άλλη, το Github είναι πλέον στον έλεγχο της Microsoft, η οποία είναι πίσω από την ανάπτυξη του Visual Studio Code (πολύ διαδεδομένου IDE για ανάπτυξη κώδικα), το οποίο δίνει αυξημένες δυνατότητες integration μεταξύ του εργαλείου και του Github, χωρίς ιδιαίτερο κόπο.</p>
<h2 id="ελάχιστες-ενέργειες">Ελάχιστες ενέργειες</h2>
<p>Δύο είναι τα βασικά σενάρια:</p>
<ul>
<li>Δημιουργείτε ένα τοπικό repository το οποίο θέλετε στη συνέχεια να ανεβάσετε σε ένα Git Server ώστε να είναι εφικτή η συνεργασία με τρίτους γι αυτό το project.</li>
<li>Τραβάτε τον κώδικα από ένα remote repository από κάποιον git server σε τοπικό directory και στη συνέχεια προχωράτε σε τοπική επεξεργασία του project συγχρονίζοντας κατά διαστήματα τις αλλαγές τόσο τις δικές σας προς το remote όσο και άλλες αλλαγές που συμβαίνουν στο remote και γίνονται commit &amp; push από άλλους, στο δικό σας τοπικό repository.</li>
</ul>
<p>Και στις δύο περιπτώσεις είναι απαραίτητο να έχετε δημιουργήσει χρήστη στην απομακρυσμένη πλατφόρμα και να έχετε την κατάλληλη πρόσβαση/δικαιώματα είτε για να φτιάξετε νέο project είτε για να συμμετέχετε στην ανάπτυξη ενός υπάρχοντος. Αυτές οι ενέργειες γίνονται στην ίδια την πλατφόρμα και προηγούνται. Στη συνέχεια η επικοινωνία γίνεται με δύο δυνατούς τρόπους:</p>
<ul>
<li>μέσω ssh (τελεί υπό κατάργηση)</li>
<li>μέσω https (συνήθως μέσω API Token)</li>
</ul>
<h3 id="δημιουργία-remoteupstream-από-local-repository">Δημιουργία remote/upstream από local repository</h3>
<p>Στo πρώτo σενάριο είναι απαραίτητο να έχετε ορίσει δύο βασικά κομμάτια ρυθμίσεων:</p>
<ul>
<li>Την τοποθεσία του remote repository και τον ορισμό του ως upstream</li>
<li>Την αντιστοίχιση του τοπικού τρέχοντος branch με αντίστοιχο branch στο remote/upstream</li>
</ul>
<p>Οι απαραίτητες εντολές είναι οι:</p>
<ul>
<li><em>git remote add origin <!-- raw HTML omitted -->.git</em> - ορίζει ως origin (remote) το remote repo url</li>
<li><em>git branch &ndash;set-upstream-to origin/<!-- raw HTML omitted --></em> - ορίζει το remote branch ως upstream του τρέχοντος τοπικού branch. Αν το τρέχον είναι το master, τότε η εντολή:</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">git branch --set-upstream-to origin/master 
</code></pre></div><p>καθορίζει το remote master ως αντίστοιχο upstream του local master branch.</p>
<p>Στη συνέχεια μπορούμε να εκτελέσουμε την εντολή</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">git push origin master 
</code></pre></div><p>για να συγχρονίσουμε το remote master branch με τις τελευταίες αλλαγές του τοπικού master.</p>
<p>Οι κινήσεις αυτές μπορούν να γίνουν και σε ένα βήμα με την εντολή:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">git -c http.sslVerify<span style="color:#f92672">=</span>false push --set-upstream &lt;remote repo url&gt;.git &lt;remote branch&gt;
</code></pre></div><p>Αν πρέπει πρώτα να τραβήξουμε τυχόν αλλαγές από το remote repo τότε εκτελούμε την εντολή:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">git pull 
</code></pre></div><h3 id="δημιουργία-local-repository-από-remoteupstream">Δημιουργία local repository από remote/upstream</h3>
<p>Αυτό γίνεται με απλό τρόπο με τη χρήση της εντολής git clone:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">git clone https://&lt;username&gt;:&lt;API_Token&gt;@&lt;remote repo url&gt;.git &lt;local path - optional&gt; --progress
</code></pre></div><h3 id="έλεγχος-ρυθμίσεων">Έλεγχος ρυθμίσεων</h3>
<p>Αν δείτε ότι κατόπιν εκτέλεσης της εντολής υπολείπονται ρυθμίσεις στο config, μπορείτε να εφαρμόσετε τις εντολές που αναφέραμε παραπάνω για να τις συμπληρώσετε (π.χ. <em>git branch &ndash;set-upstream-to</em>)
Μπορείτε να χρησιμοποιήσετε την εντολή <em>git remote -v</em> και το <em>git status remote</em> για να ελέγχετε την κατάσταση.</p>
<h3 id="authentication">Authentication</h3>
<p>Ένας απλός τρόπος είναι να ορίσετε στο config ότι τα credentials αποθηκεύονται σε τοπικό αρχείο με την εντολή:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">git config credential.helper store --file &lt;filepath&gt;
</code></pre></div><p>ή σε επίπεδο χρήστη με την εντολή</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">git config --global credential.helper store --file &lt;filepath&gt;
</code></pre></div><p>Στη συνέχεια στην πρώτη προσπάθεια για git push ή git pull, θα πάρετε prompt για το password του χρήστη με user name αυτό που ορίσατε στο config. Εδώ προφανώς με όσα γράφουμε μέχρι τώρα, το password αντιστοιχεί στο https API Token.</p>
<p><strong>Η επιτυχημένη εργασία με remote repositories είναι η βάση για τη συνεργατική ανάπτυξη κώδικα σε κοινά project ομάδων, ανεξάρτητα με την τοποθεσία των μελών της εκάστοτε ομάδας</strong>.</p>
<h2 id="the-cli-way-or-the-ide-way">The CLI way or the IDE way?</h2>
<p>Αν χρησιμοποιείτε IDE όπως το Visual Studio Code, τo authentication προς γνωστά remote sites γίνεται πιο εύκολα εφόσον το επιθυμούμε. Στην περίπτωση του github μπορεί να γίνει login από το profil του χρήστη ή να δοθεί εξουσιοδότηση από τη σελίδα του Github προς το visual studio code αν εκτελέσει κανείς το κατάλληλο link.
Αλλά και οι υπόλοιπες εργασίες, όπως το git init, add, commit, add remote, git push, pull, branch, status, log, κλπ μπορούν να εκτελεστούν με τη βοήθεια VS Code extensions, όπως:</p>
<ul>
<li>gitlab workflow</li>
<li>gitlab explorer</li>
<li>git lens</li>
<li>git autoconfig</li>
<li>git automator</li>
<li>git history</li>
<li>git-ignore</li>
</ul>
<p>κλπ.
Κάθε extension έχει δικό της κομμάτι στο αρχείο ρυθμίσεων του vs code. Το αρχείο είναι διαμορφωμένο σε μορφή json.</p>
<h1 id="σημαντικά-links">Σημαντικά links</h1>
<h2 id="γενικά-2">Γενικά</h2>
<p><a href="https://git-scm.com/book/en/v2/">https://git-scm.com/book/en/v2/</a>
<a href="https://ohshitgit.com/">https://ohshitgit.com/</a>
<a href="https://developer.cisco.com/learning/tracks/devnet-beginner/programming-fundamentals/git-basic-workflows/step/1">https://developer.cisco.com/learning/tracks/devnet-beginner/programming-fundamentals/git-basic-workflows/step/1</a>
<a href="https://towardsdatascience.com/an-easy-beginners-guide-to-git-2d5a99682a4c">https://towardsdatascience.com/an-easy-beginners-guide-to-git-2d5a99682a4c</a>
<a href="https://community.codenewbie.org/wolde_ai/git-learn-the-basics-part-one-1f6b">https://community.codenewbie.org/wolde_ai/git-learn-the-basics-part-one-1f6b</a>
<a href="https://towardsdatascience.com/the-only-6-git-commands-you-need-to-know-995065db1ae0">https://towardsdatascience.com/the-only-6-git-commands-you-need-to-know-995065db1ae0</a>
<a href="https://towardsdatascience.com/learn-enough-git-to-be-useful-281561eef959">https://towardsdatascience.com/learn-enough-git-to-be-useful-281561eef959</a>
<a href="https://www.freecodecamp.org/news/understanding-git-basics-commands-tips-tricks/">https://www.freecodecamp.org/news/understanding-git-basics-commands-tips-tricks/</a>
<a href="https://towardsdatascience.com/mastering-git-commands-the-logic-behind-git-ad3fbcc6fb33">https://towardsdatascience.com/mastering-git-commands-the-logic-behind-git-ad3fbcc6fb33</a></p>
<h2 id="git-branching">Git Branching</h2>
<p><a href="https://learngitbranching.js.org/">https://learngitbranching.js.org/</a>
<a href="https://www.freecodecamp.org/news/how-to-use-branches-in-git/">https://www.freecodecamp.org/news/how-to-use-branches-in-git/</a></p>
<h2 id="visual-studio---git-integration">Visual Studio - Git Integration</h2>
<p><a href="https://channel9.msdn.com/Shows/Visual-Studio-Toolbox/The-New-Git-Experience">https://channel9.msdn.com/Shows/Visual-Studio-Toolbox/The-New-Git-Experience</a>
<a href="https://devblogs.microsoft.com/visualstudio/enhanced-productivity-with-git-in-visual-studio/">https://devblogs.microsoft.com/visualstudio/enhanced-productivity-with-git-in-visual-studio/</a>
<a href="https://docs.microsoft.com/en-us/visualstudio/version-control/?view=vs-2019">https://docs.microsoft.com/en-us/visualstudio/version-control/?view=vs-2019</a></p>
<h2 id="git-tutorials---labs">Git Tutorials - Labs</h2>
<p><a href="https://git-scm.com/docs/gittutorial">https://git-scm.com/docs/gittutorial</a>
<a href="https://youtu.be/DVRQoVRzMIY">https://youtu.be/DVRQoVRzMIY</a>
<a href="https://www.youtube.com/watch?v=USjZcfj8yxE">https://www.youtube.com/watch?v=USjZcfj8yxE</a>
<a href="https://developer.cisco.com/learning/tracks/devnet-beginner/programming-fundamentals/git-basic-workflows/step/1">https://developer.cisco.com/learning/tracks/devnet-beginner/programming-fundamentals/git-basic-workflows/step/1</a>
<a href="https://developer.cisco.com/learning/lab/git-intro/step/1">https://developer.cisco.com/learning/lab/git-intro/step/1</a>
<a href="https://developer.cisco.com/learning/lab/collab-tools-python-scripting-basics-with-git-itp/step/1">https://developer.cisco.com/learning/lab/collab-tools-python-scripting-basics-with-git-itp/step/1</a>
<a href="https://developer.cisco.com/learning/lab/git-branching/step/1">https://developer.cisco.com/learning/lab/git-branching/step/1</a>
<a href="https://developer.cisco.com/learning/lab/git-servers/step/1">https://developer.cisco.com/learning/lab/git-servers/step/1</a>
<a href="https://css-tricks.com/creating-the-perfect-commit-in-git/">https://css-tricks.com/creating-the-perfect-commit-in-git/</a>
<a href="https://levelup.gitconnected.com/top-30-git-commands-you-should-know-to-master-git-cli-f04e041779bc">https://levelup.gitconnected.com/top-30-git-commands-you-should-know-to-master-git-cli-f04e041779bc</a>
<a href="https://www.freecodecamp.org/news/advanced-git-interactive-rebase-cherry-picking-reflog-and-more/">https://www.freecodecamp.org/news/advanced-git-interactive-rebase-cherry-picking-reflog-and-more/</a>
<a href="https://github.com/GitCredentialManager/git-credential-manager">https://github.com/GitCredentialManager/git-credential-manager</a>
<a href="https://dzone.com/articles/the-best-vs-code-extensions-to-supercharge-git">https://dzone.com/articles/the-best-vs-code-extensions-to-supercharge-git</a>
<a href="https://dev.to/sagarbarapatre/how-to-become-a-git-expert-1jl2">https://dev.to/sagarbarapatre/how-to-become-a-git-expert-1jl2</a>
<a href="https://dev.to/mrdanishsaleem/git-cheatsheet-4kpn">https://dev.to/mrdanishsaleem/git-cheatsheet-4kpn</a>
<a href="https://towardsdatascience.com/a-git-cheatsheet-that-all-coders-need-bf8ad4d91576">https://towardsdatascience.com/a-git-cheatsheet-that-all-coders-need-bf8ad4d91576</a>
<a href="https://www.freecodecamp.org/news/git-for-professionals/">https://www.freecodecamp.org/news/git-for-professionals/</a>
<a href="https://towardsdatascience.com/how-to-learn-git-in-simple-words-263618071dd8">https://towardsdatascience.com/how-to-learn-git-in-simple-words-263618071dd8</a>
<a href="https://www.sitepoint.com/5-ways-to-undo-mistakes-with-git/">https://www.sitepoint.com/5-ways-to-undo-mistakes-with-git/</a>
<a href="https://dev.to/sankalpswami1122/git-essentials-4kff">https://dev.to/sankalpswami1122/git-essentials-4kff</a>
<a href="https://levelup.gitconnected.com/using-git-in-visual-studio-code-2f16fde8406e">https://levelup.gitconnected.com/using-git-in-visual-studio-code-2f16fde8406e</a></p>
<h1 id="next-steps">Next steps</h1>
<p>Στην επόμενη version του άρθρου θα προσθέσουμε βασικά στοιχεία για το πως μπορεί κάποιος να διαχειριστεί το git σε ένα project μέσα από ένα IDE όπως το Visual Studio Code καθώς και να καθορίσει remote repositories (upstream/origin) και να χρησιμοποιήσει git servers για το συγχρονισμό των projects για ομάδες και κατά προέκταση σε συνδυασμό με εργαλεία CI.</p>
]]></content>
        </item>
        
        <item>
            <title>Introduction to Docker</title>
            <link>https://netautogr.github.io/posts/2021/02/introduction-to-docker/</link>
            <pubDate>Fri, 12 Feb 2021 09:45:49 +0200</pubDate>
            
            <guid>https://netautogr.github.io/posts/2021/02/introduction-to-docker/</guid>
            <description>Εισαγωγή To Docker είναι μια αρχιτεκτονική για containers. Άλλη αντίστοιχη αρχιτεκτονική είναι το OCI (Open Container Initiative). Τα containers ενσωματώνουν όλα τα κομμάτια που χρειάζεται μια εφαρμογή για να λειτουργήσει ξεχωριστά από τις υπόλοιπες σε ένα ενιαίο πακέτο, το οποίο απομονώνεται από τις υπόλοιπες εφαρμογές και λειτουργικό σύστημα με τρόπους που βασίζονται στη χρήση linux namespaces και έχουν τις απαρχές τους στο chroot jail. Θα μπορούσε κανείς να πει ότι τα containers υλοποιούν operating system virtualization κατά αντίστοιχο τρόπο που τα Virtual Machines υλοποιούν hardware virtualization.</description>
            <content type="html"><![CDATA[<h2 id="εισαγωγή">Εισαγωγή</h2>
<p>To Docker είναι μια αρχιτεκτονική για containers. Άλλη αντίστοιχη αρχιτεκτονική είναι το OCI (Open Container Initiative). Τα containers ενσωματώνουν όλα τα κομμάτια που χρειάζεται μια εφαρμογή για να λειτουργήσει ξεχωριστά από τις υπόλοιπες σε ένα ενιαίο πακέτο, το οποίο απομονώνεται από τις υπόλοιπες εφαρμογές και λειτουργικό σύστημα με τρόπους που βασίζονται στη χρήση linux namespaces και έχουν τις απαρχές τους στο chroot jail. Θα μπορούσε κανείς να πει ότι τα containers υλοποιούν operating system virtualization κατά αντίστοιχο τρόπο που τα Virtual Machines υλοποιούν hardware virtualization. Κατά τον ίδιο τρόπο λοιπόν που τα Virtual Machines λειτουργούν απομονωμένα και μοιράζονται το ίδιο φυσικό hardware, έτσι και τα containers λειτουργούν απομονωμένα και μοιράζονται το ίδιο λειτουργικό σύστημα με απόλυτη απομόνωση σε επίπεδο λειτουργικού και processes.</p>
<p><img src="https://www.redhat.com/cms/managed-files/virtualization-vs-containers.png" alt="os-virtualization" title="OS Virtualization"></p>
<p><strong>Ξεκινήστε πρώτα από εδώ:</strong></p>
<ul>
<li><a href="https://docs.docker.com/">https://docs.docker.com/</a></li>
<li><a href="https://youtu.be/iqqDU2crIEQ">https://youtu.be/iqqDU2crIEQ</a> How to get started with Docker</li>
<li><a href="https://youtu.be/QeQ2MH5f_BE">https://youtu.be/QeQ2MH5f_BE</a> Simplify things with docker-compose</li>
<li><a href="https://youtu.be/3c-iBn73dDE">https://youtu.be/3c-iBn73dDE</a> Docker Tutorial for Beginners [FULL COURSE in 3 Hours]</li>
</ul>
<p>Και δείτε κι αυτά:</p>
<ul>
<li><a href="https://www.netapp.com/devops-solutions/what-are-containers/">https://www.netapp.com/devops-solutions/what-are-containers/</a></li>
<li><a href="https://www.docker.com/resources/what-container">https://www.docker.com/resources/what-container</a></li>
<li><a href="https://www.redhat.com/en/topics/containers/whats-a-linux-container">https://www.redhat.com/en/topics/containers/whats-a-linux-container</a></li>
<li><a href="https://opensource.com/article/19/10/namespaces-and-containers-linux">https://opensource.com/article/19/10/namespaces-and-containers-linux</a></li>
<li><a href="https://www.simplilearn.com/tutorials/docker-tutorial/what-is-docker-container">https://www.simplilearn.com/tutorials/docker-tutorial/what-is-docker-container</a></li>
<li><a href="https://github.com/wsargent/docker-cheat-sheet">https://github.com/wsargent/docker-cheat-sheet</a> Αυτό μπαίνει και στο τέλος..</li>
</ul>
<h2 id="συστατικά">Συστατικά</h2>
<p>Μπορεί κανείς να πάρει μια ιδέα από το παρακάτω post:</p>
<p><a href="https://developers.redhat.com/blog/2016/01/13/a-practical-introduction-to-docker-container-terminology/?utm_campaign=containers&amp;intcmp=70160000000h1s6AAA">https://developers.redhat.com/blog/2016/01/13/a-practical-introduction-to-docker-container-terminology/?utm_campaign=containers&amp;intcmp=70160000000h1s6AAA</a></p>
<p>Ακολουθούν συνοπτικοί ορισμοί:</p>
<h3 id="docker-server">Docker server</h3>
<p>Γνωστός και ως docker host, είναι στο μηχάνημα (φυσικό ή VM) που φιλοξενεί τα containers και είναι το λογισμικό που διαμοιράζει τα resources, φροντίζει για την απομόνωση και την λειτουργία των containers (start, stop, κλπ) αλλά και την επικοινωνία τους είτε μεταξύ τους είτε με τον υπόλοιπο κόσμο.</p>
<h3 id="docker-client">Docker client</h3>
<p>Το σύνολο των εντολών (linux) ή το ξεχωριστό λογισμικό (windows) που αποτελούν το περιβάλλον με το οποίο ο χρήστης ή μια εξωτερική εφαρμογή μπορεί να επικοινωνήσει με το Docker Server και να επηρεάσει τη λειτουργία των containers.</p>
<h3 id="docker-engine">Docker Engine</h3>
<p>Το σύνολο της client-server εφαρμογής που περιλαμβάνει</p>
<ul>
<li>Docker Server</li>
<li>Docker Client</li>
<li>Docker APIs</li>
</ul>
<p><a href="https://docs.docker.com/engine/">https://docs.docker.com/engine/</a></p>
<h3 id="docker-images">Docker images</h3>
<p>Βασικά πακέτα πάνω στα οποία μπορεί κανείς να βασιστεί και να φτιάξει containers ή πιο σύνθετα images. Είναι δυνατό να φτιαχτούν πολύπλοκα σύνολα λογισμικού με αντίστοιχα πολύπλοκο τρόπο. Επίσης μπορεί ένα image να φτιαχτεί με layers. Ο τρόπος που φτιάχνεται ένα image από στοιχειώδη συστατικά μπορεί να προδιαγραφεί απόλυτα με την χρήση των dockerfiles. Η διαδικασία της κατασκευής του image ονομάζεται build. Η δυνατότητα ορισμού των προδιαγραφών του build για ένα image δίνει τη δυνατότητα της χρήσης των containers ως Infrastructure as Code (περιγράφω απλώς πως θέλω να είναι το image και αυτό χτίζεται κατά τις προδιαγραφές μου αυτόματα).
Έχει σημασία η προσοχή στις διαδικασίες που ορίζονται στα dockerfile καθώς κάθε εντολή καταλήγει στο να προσθέσει ένα ακόμα layer στο image. Τα layers από τη στιγμή που θα προστεθούν είναι immutable. Γι αυτό και πολλές φορές οι εντολές σε κάθε βήμα ενός Dockerfile καταλήγουν να είναι αρκετά πολύπλοκες, καθώς δεν μπορεί κανείς να διαγράψει στην πράξη σε ένα επόμενο layer αρχεία που προστέθηκαν σε προηγούμενο layer. Επειδή τα images αποθηκεύονται σε κεντρικά σημεία - <strong>Docker registry</strong> - και γίνονται download από εκεί, το μέγεθος των images έχει σημασία για την αποδοτικότητα της υποδομής.</p>
<p><a href="https://circleci.com/blog/tips-for-optimizing-docker-builds/">https://circleci.com/blog/tips-for-optimizing-docker-builds/</a></p>
<h2 id="docker-hub">Docker Hub</h2>
<p>Η κεντρική αποθήκη της Docker για τα images. Είναι ο δημόσιος &ldquo;κάταλογος&rdquo; - Registry για τα images και μπορεί ο καθένας να δημοσιεύσει τα δικά του, είτε εταιρείες/ιδρύματα είτε ιδιώτες. Μπορεί φυσικά κανείς να διαθέτει και private registry που φιλοξενείται στη δική του ιδιωτική υποδομή.</p>
<p><a href="https://hub.docker.com/">https://hub.docker.com/</a></p>
<h3 id="docker-containers">Docker containers</h3>
<p>Τα αγαπημένα μας κουτάκια που φτιάχνονται κατ'ομοίωση των images αλλά μπορούν να επηρεαστούν κατά τη δημιουργία τους ώστε να υπάρξουν τροποιήσεις. Επίσης κατά τη δημιουργία των containers από κάποιο image, όπου το container είναι πλέον σαν ένα ξεχωριστό σύνολο από processes και εφαρμογές, μπορούν να οριστούν και διάφορες παράμετροι λειτουργίας, όπως μέρη του filesystem του host στα οποία έχει πρόσβαση το container με συγκεκριμένα δικαιώματα, τα network ports τα οποία ορίζονται ως σημεία πρόσβασης για το container είτε από το εξωτερικό δίκτυο είτε από το εσωτερικό &ldquo;εικονικό&rdquo; δίκτυο του docker host.</p>
<h3 id="docker-networking">Docker networking</h3>
<p>Γενικά μπορούμε να σκεφτούμε το τρόπο που επικοινωνούν τα containers μεταξύ τους αλλά και με το υπόλοιπο δίκτυο ως bridging. Δημιουργούνται εικονικά bridges στον Docker host που μπορούν να έχουν ή να μην έχουν επικοινωνία με το εξωτερικό δίκτυο. Ένα container μπορεί να επικοινωνεί με περισσότερα από ένα bridges. Αυτό δίνει τη δυνατότητα για πολύπλοκους συνδυασμούς ώστε κάποια containers π.χ. να επικοινωνούν μόνο μεταξύ τους και να χρησιμοποιούν τρίτο container για να δώσουν services προς το εξωτερικό δίκτυο. Φυσικά τέτοιες αρχιτεκτονικές είναι αρκετά πολύπλοκες και η χρήση τους γίνεται αρκετά απλούστερη με τη χρήση εργαλείων για orchestration. Η επικοινωνία μεταξύ containers μπορεί αν χρειαστει να ξεπεράσει τα όρια ενός docker host, κάτι το οποίο θεωρείται αρκετά πολύπλοκο σαν αρχιτεκτονική και πέρα από τη λογική ενός εισαγωγικού post.</p>
<h2 id="χρήση">Χρήση</h2>
<p>Η χρήση των containers μπορεί να αφορά από την αυτοματοποίηση των διαδικασιών χτησίματος μιας πλατφόρμας ή μιας εφαρμογής μέχρι την πλήρη χρήση <strong>Infrastructure as Code</strong>.
Μπορούν να θεωρηθούν, όταν οι εφαρμογές που υλοποιούν διαχωρίζονται απόλυτα ως προς τα services σε ξεχωριστά containers, ότι αποτελούν βασικό συστατικό του <strong>Microservices Architecture</strong>, ειδικά με το συνδυασμό με εργαλεία orchestration, όπου μπορεί κανείς να χρησιμοποιήσει υποδομές <strong>CI/CD</strong> για να ενημερώνει τον κώδικα των εφαρμογών, να χτίζει τα κατάλληλα images, να σηκώνει τα containers, να κάνει τις δοκιμές κλπ δημιουργώντας πλήρεις κύκλους ανάπτυξης και λειτουργίας λογισμικού και υπηρεσιών.
Το <strong>orchestration</strong> γενικά μπορεί να διευκολύνει αρκετά τη χρήση των containers σε κάθε σενάριο.
Εδώ και κάποια χρόνια η χρήση των containers εξετάζεται και σε περιπτώσεις <strong>edge computing</strong> στο δίκτυο, καθώς πολλές πλατφόρμες networking υποστηρίζουν containers όπως π.χ. τα Cisco Catalyst 9K και όχι μόνο..
<a href="https://blogs.cisco.com/developer/minecraft-on-catalyst-switch">https://blogs.cisco.com/developer/minecraft-on-catalyst-switch</a> Can You Play Minecraft on a Cisco Switch? Flo Pachinger</p>
<h2 id="docker-compose">Docker-compose</h2>
<p>Προδιαγραφές καταγεγραμμένες σε αρχεία ρυθμίσεων, μπορούν να χρησιμοποιηθούν απο κατάλληλα εργαλεία για να επιτευχθεί η αυτοματοποίηση της δημιουργίας images και containers. Ένα τέτοιο εργαλείο για την πλατφόρμα Docker με απλή λειτουργία, κυρίως για λόγους test &amp; development (χωρίς να αποκλείεται περιορισμένη χρήση σε production) είναι το docker-compose.</p>
<ul>
<li><a href="https://docs.docker.com/compose/">https://docs.docker.com/compose/</a> Πλήρες documentation της πλατφόρμας</li>
<li><a href="https://docs.docker.com/compose/production/">https://docs.docker.com/compose/production/</a> Πως να προσαρμόσετε το docker-compose για χρήση στην παραγωγή.</li>
</ul>
<p>Στο docker-compose χρησιμοποιούνται αρχεια yaml για τον ορισμό services τα οποία χτίζονται με containers αλλά και για τον ορισμό της επικοινωνίας αυτών των services μεταξύ τους και με τον εξωτερικό κόσμο. Το docker-compose σαν λογισμικό βασίζεται σε ένα αριθμό από εντολών και είναι αντίστοιχο με το docker client runtime σε σχέση με το τί μπορεί να εκτελεστεί για να επηρεάσουμε τη λειτουργία των services βασισμένα στα docker containers ή να κάνουμε συγκεκιμένους ελέγχους. Η χρήση της πλατφόρμας Docker απλοποιείται εξαιρετικά με τη χρήση του docker-compose.
Βασικό μειονέκτημα του docker-compose είναι η έλλειψη υποστήριξης scale out δηλαδή να μπορεί κανείς να προσθέτει/αφαιρεί nodes οριζόντια για όποιο service χρειάζεται ώστε να ανταποκρίνεται στο φόρτο και τις ανάγκες για τις συγκεκριμένες εφαρμογές.
Για τέτοιες περιπτώσεις είναι απαραίτητες διαφορετικά εργαλεία όπως το docker swarm ή το Kubernetes</p>
<h3 id="kubernetes">Kubernetes</h3>
<p>Το απόλυτο εργαλείο για υποστήριξη microservices architecture και scalable υποδομών εφαρμογών σε περιβάλλοντα cloud. Βασικό του συστατικό είναι το pod το οποίο μπορεί να περιλαμβάνει ένα ή περισσότερα services. Η προσθήκη ή αφαίρεση pods είναι ο τρόπος που μια τέτοια υποδομή αντιμετωπίζει την αύξηση/μείωση του load για τις εφαρμογές που χτίζονται πάνω στα containers. Πρόσφατα ανακοινώθηκε ότι το Kubernetes δεν θα υποστηρίζει πλέον docker containers αλλά η ακριβής ερμηνεία αυτής της ανακοίνωσης αφήνεται σε πιο ειδικούς από μένα (&ldquo;ναι μεν αλλά&hellip;&quot;)
<a href="https://youtu.be/7KUdmFyefSA">https://youtu.be/7KUdmFyefSA</a> - Kubernetes is dropping Docker support - What does it mean for YOU?</p>
<p>Στο παρακάτω post εξηγούνται οι διαφορές Docker &amp; Kuburnetes με παραδείγματα:</p>
<p><a href="https://www.freecodecamp.org/news/kubernetes-vs-docker-whats-the-difference-explained-with-examples/">https://www.freecodecamp.org/news/kubernetes-vs-docker-whats-the-difference-explained-with-examples/</a></p>
<p>Κι αυτό λίγο πιο παλιό :</p>
<p><a href="https://containerjournal.com/topics/container-ecosystems/kubernetes-vs-docker-a-primer/amp/">https://containerjournal.com/topics/container-ecosystems/kubernetes-vs-docker-a-primer/amp/</a></p>
<h2 id="εγκατάσταση">Εγκατάσταση</h2>
<p>Παρατίθενται δύο δημοφιλή post για</p>
<ul>
<li>πως να εγκατασταθεί το docker σε πλατφόρμα Ubuntu, μαζί με παραδείγματα για τη χρήση και δημοφιλείς εντολές για τον docker client <a href="https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-on-ubuntu-20-04">https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-on-ubuntu-20-04</a></li>
<li>πως να εγκατασταθεί το docker-compose σε πλατφόρμα Ubuntu, μαζί με παραδείγματα για τη χρήση και δημοφιλείς εντολές <a href="https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-compose-on-ubuntu-20-04">https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-compose-on-ubuntu-20-04</a></li>
</ul>
<h2 id="networking">Networking</h2>
<p>Παρατίθενται links που εξηγούν πως επικοινωνούν τα containers και πως αυτό μπορεί να ορισθεί μέσω του docker client ή του docker-compose.</p>
<ul>
<li><a href="https://ostechnix.com/explaining-docker-networking-concepts/">https://ostechnix.com/explaining-docker-networking-concepts/</a></li>
<li><a href="https://docs.docker.com/compose/networking/">https://docs.docker.com/compose/networking/</a> Networking in Compose</li>
<li><a href="https://youtu.be/z-ITjDQT7DU">https://youtu.be/z-ITjDQT7DU</a> Linux Bridges, IP Tables, and CNI Plug-Ins, A Container Networking Deepdive</li>
</ul>
<p>Μερικές πολύ καλές παρουσιάσεις από Cisco Live On Demand Library (χρειάζεστε λογαριασμό):</p>
<ul>
<li><a href="https://www.ciscolive.com/global/on-demand-library.html?search=container%20networking#/session/1500302064183001RdRv">https://www.ciscolive.com/global/on-demand-library.html?search=container%20networking#/session/1500302064183001RdRv</a> Demystifying Container Networking, Matthew Johnson (Εξαιρετικός απλά).</li>
<li><a href="https://www.ciscolive.com/global/on-demand-library.html?search=container%20networking#/session/1564346298969001mFaH">https://www.ciscolive.com/global/on-demand-library.html?search=container%20networking#/session/1564346298969001mFaH</a> Container Netwokring Deep Dive, Ivan Kovacevic (Ψυχραιμία εδώ, θα πάθετε πλάκα, αλλά καλύ υπομονή, μας τρέλανε ο τύπος, ήμουν μέσα.. Βαρκελώνη 2020)</li>
</ul>
<h2 id="logging">Logging</h2>
<p>Η παρατήρηση των logs είναι εξίσου σημαντική στην πλατφόρμα docker &amp; docker-compose όσο και στο linux. Αν δεν βλέπεις logs χάνεις τουλάχιστον το 50% της εικόνας</p>
<p><a href="https://sematext.com/blog/docker-logs-location/">https://sematext.com/blog/docker-logs-location/</a></p>
<h2 id="debugging">Debugging</h2>
<p>Τί γίνεται όταν κάτι δεν παέι καλά; Προσωπικά θα διάβαζα κάποιο βιβλίο (π.χ. <a href="https://www.oreilly.com/library/view/troubleshooting-docker/9781783552344/">https://www.oreilly.com/library/view/troubleshooting-docker/9781783552344/</a>) ή θα παρακολουθούσα κάποιο course στη θέση σας, όμως ορίστε ένα μικρό post με σχετικές συμβουλές. Ειδικά το docker top, πολύ σημαντική εντολή.</p>
<p><a href="https://medium.com/@betz.mark/ten-tips-for-debugging-docker-containers-cde4da841a1d">https://medium.com/@betz.mark/ten-tips-for-debugging-docker-containers-cde4da841a1d</a></p>
<p>κι αυτό από τη Digital Ocean:
<a href="https://www-digitalocean-com.cdn.ampproject.org/v/s/www.digitalocean.com/community/tutorials/how-to-debug-and-fix-common-docker-issues.amp?amp_gsa=1&amp;amp_js_v=a6&amp;usqp=mq331AQHKAFQArABIA%3D%3D#amp_tf=From%20%251%24s&amp;aoh=16087631049485&amp;referrer=https%3A%2F%2Fwww.google.com&amp;ampshare=https%3A%2F%2Fwww.digitalocean.com%2Fcommunity%2Ftutorials%2Fhow-to-debug-and-fix-common-docker-issues">https://www-digitalocean-com.cdn.ampproject.org/v/s/www.digitalocean.com/community/tutorials/how-to-debug-and-fix-common-docker-issues.amp?amp_gsa=1&amp;amp_js_v=a6&amp;usqp=mq331AQHKAFQArABIA%3D%3D#amp_tf=From%20%251%24s&amp;aoh=16087631049485&amp;referrer=https%3A%2F%2Fwww.google.com&amp;ampshare=https%3A%2F%2Fwww.digitalocean.com%2Fcommunity%2Ftutorials%2Fhow-to-debug-and-fix-common-docker-issues</a></p>
<p>κι ένα video:</p>
<p><a href="https://www.youtube.com/watch?v=o9uKZBQP1uY"><img src="https://img.youtube.com/vi/o9uKZBQP1uY/0.jpg" alt="IMAGE ALT TEXT HERE"></a></p>
<h2 id="άλλα-χρήσιμα-links----διάβασμα">Άλλα Χρήσιμα links -  Διάβασμα</h2>
<p>Διαβάστε οπωσδήποτε τη σειρά των posts από Julio Gomes και Rodie Hassan. Η πρώτη έχει απίστευτο ταξίδι στον κόσμο του Devops. Η δεύτερη εκτείνεται σε μια σειρά από άρθρα εξειδικευμένα κατά αντικείμενο. Παρατίθενται χωριστά.</p>
<ul>
<li><a href="https://12factor.net/">https://12factor.net/</a> The Twelve Factor App Methodology, Βασικό διάβασμα για να καταλάβει κανείς τί ενέπνευσε αυτή την τεχνολογία.</li>
</ul>
<p>Η Σειρά του Julio Gomez - Programmability Lead in Cisco EMEAR (εκπληκτικός τύπος)</p>
<ul>
<li><a href="https://blogs.cisco.com/developer/why-containers?utm_campaign=docker&amp;utm_source=otwitter&amp;utm_medium=devnet-blogs-juliogomez&amp;linkId=49937033">https://blogs.cisco.com/developer/why-containers?utm_campaign=docker&amp;utm_source=otwitter&amp;utm_medium=devnet-blogs-juliogomez&amp;linkId=49937033</a> - If You’re Not Familiar with Containers, You’re Missing Out on Something Big – DevOps Series, Part 1 by <strong>Julio Gomez</strong></li>
</ul>
<p>Rodie Hasan:</p>
<ul>
<li><a href="https://ccie.tv/fun-with-docker/">https://ccie.tv/fun-with-docker/</a></li>
<li><a href="https://ccie.tv/fun-with-docker-part-2a-getting-started/">https://ccie.tv/fun-with-docker-part-2a-getting-started/</a></li>
<li><a href="https://ccie.tv/fun-with-docker-part-2b-more-getting-started/">https://ccie.tv/fun-with-docker-part-2b-more-getting-started/</a></li>
<li><a href="https://ccie.tv/fun-with-docker-part-3-docker-compose/">https://ccie.tv/fun-with-docker-part-3-docker-compose/</a></li>
<li><a href="https://ccie.tv/fun-with-docker-part-4-docker-volumes/">https://ccie.tv/fun-with-docker-part-4-docker-volumes/</a></li>
<li><a href="https://ccie.tv/fun-with-docker-part-5-docker-networking/">https://ccie.tv/fun-with-docker-part-5-docker-networking/</a></li>
</ul>
<p>Cisco Learning Labs on Devnet (χρειάζεται εγγραφή στο Devnet):</p>
<ul>
<li><a href="https://developer.cisco.com/learning/lab/containers-101/step/1">https://developer.cisco.com/learning/lab/containers-101/step/1</a></li>
<li><a href="https://developer.cisco.com/learning/lab/docker-101/step/1">https://developer.cisco.com/learning/lab/docker-101/step/1</a></li>
</ul>
<p>Docker Cheatsheet (πάλι):</p>
<ul>
<li><a href="https://github.com/wsargent/docker-cheat-sheet">https://github.com/wsargent/docker-cheat-sheet</a></li>
</ul>
<p>Blog Posts &amp; Youtube Videos:</p>
<ul>
<li><a href="https://www.linkedin.com/pulse/introduction-containers-docker-kubernetes-derek-winchester">https://www.linkedin.com/pulse/introduction-containers-docker-kubernetes-derek-winchester</a></li>
<li><a href="https://www.youtube.com/watch?v=2uweFMQCWEs&amp;ab_channel=edureka%21">https://www.youtube.com/watch?v=2uweFMQCWEs&amp;ab_channel=edureka%21</a> - Dockerfile Tutorial Video, Edureka</li>
<li><a href="https://phoenixnap.com/kb/how-to-ssh-into-docker-container">https://phoenixnap.com/kb/how-to-ssh-into-docker-container</a></li>
<li><a href="https://css-tricks.com/a-gentle-introduction-to-using-a-docker-container-as-a-dev-environment/">https://css-tricks.com/a-gentle-introduction-to-using-a-docker-container-as-a-dev-environment/</a></li>
<li><a href="https://www.coursera.org/lecture/sdn/docker-and-containerization-oyA43">https://www.coursera.org/lecture/sdn/docker-and-containerization-oyA43</a></li>
<li><a href="https://dev.to/rohansawant/installing-docker-and-docker-compose-on-the-raspberry-pi-in-5-simple-steps-3mgl">https://dev.to/rohansawant/installing-docker-and-docker-compose-on-the-raspberry-pi-in-5-simple-steps-3mgl</a></li>
<li><a href="https://dev.to/kojikanao/15-docker-commands-for-beginners-4m4d">https://dev.to/kojikanao/15-docker-commands-for-beginners-4m4d</a></li>
<li><a href="https://www.javacodegeeks.com/2018/07/docker-tutorial-containers.html">https://www.javacodegeeks.com/2018/07/docker-tutorial-containers.html</a></li>
<li><a href="https://dev.to/kbk0125/docker-containers-explained-by-renting-office-space-p0o">https://dev.to/kbk0125/docker-containers-explained-by-renting-office-space-p0o</a></li>
<li><a href="https://pythonspeed.com/docker/">https://pythonspeed.com/docker/</a> Production-ready Docker packaging for Python developers</li>
<li><a href="https://www.freecodecamp.org/news/the-docker-handbook/">https://www.freecodecamp.org/news/the-docker-handbook/</a></li>
<li><a href="https://docker.events.cube365.net/docker/dockercon">https://docker.events.cube365.net/docker/dockercon</a></li>
<li><a href="https://sreeninet.wordpress.com/2017/11/02/docker-networking-tip-troubleshooting/amp/">https://sreeninet.wordpress.com/2017/11/02/docker-networking-tip-troubleshooting/amp/</a></li>
<li><a href="https://pythonspeed.com/articles/base-image-python-docker-images/">https://pythonspeed.com/articles/base-image-python-docker-images/</a></li>
</ul>
<p>Καλή επιτυχία!! Αν χρειαστείτε βοήθεια, επικοινωνήστε μαζί μας! Σε επόμενο άρθρο θα μιλήσουμε για χρήση της πλατφόρμας docker &amp; docker-compose στην εγκατάσταση και λειτουργία δημοφιλών λύσεων και εφαρμογών για μηχανικούς ΙΤ.</p>
]]></content>
        </item>
        
        <item>
            <title>How to Get Started With Network Automation</title>
            <link>https://netautogr.github.io/posts/2021/01/how-to-get-started-with-network-automation/</link>
            <pubDate>Thu, 07 Jan 2021 23:02:40 +0200</pubDate>
            
            <guid>https://netautogr.github.io/posts/2021/01/how-to-get-started-with-network-automation/</guid>
            <description>Εισαγωγή Λένε πως το πιο δύσκολο πράγμα στην πτήση είναι η απογείωση.. Στην ενασχόληση με το network automation, αυτο ισχύει σίγουρα. Αν ψάξει κανείς στο internet θα βρει αρκετό περιεχόμενο που έχει σκοπό να αναδείξει κίνητρα, οφέλη, μια νέα φιλοσοφία. Οπωσδήποτε πρέπει κανείς να ανοίξει το μυαλό του σε νέο τρόπο σκέψης, εργασίας και συνεργασίας με αρκετά νέα εργαλεία και τεχνογνωσία. Αλλά το βασικό πρόβλημα δεν είναι η φιλοσοφία. Εντάξει, παίζει σημαντικό ρόλο.</description>
            <content type="html"><![CDATA[<h2 id="εισαγωγή">Εισαγωγή</h2>
<p>Λένε πως το πιο δύσκολο πράγμα στην πτήση είναι η απογείωση.. Στην ενασχόληση με το network automation, αυτο ισχύει σίγουρα.
Αν ψάξει κανείς στο internet θα βρει αρκετό περιεχόμενο που έχει σκοπό να αναδείξει κίνητρα, οφέλη, μια νέα φιλοσοφία.
Οπωσδήποτε πρέπει κανείς να ανοίξει το μυαλό του σε νέο τρόπο σκέψης, εργασίας και συνεργασίας με αρκετά νέα εργαλεία και τεχνογνωσία.
Αλλά το βασικό πρόβλημα δεν είναι η φιλοσοφία. Εντάξει, παίζει σημαντικό ρόλο. Αν όμως κάποιος έχει φτάσει μέχρι εδώ, σημαίνει ότι έχει ήδη πειστεί σε κάποιο βαθμό ότι κάτι πρέπει ή κάτι θέλει να κάνει. Αυτό που χρειάζεται είναι να του εξηγήσει κάποιος τί είναι αυτό το &ldquo;κάτι&rdquo;, τί συμβαίνει εκεί έξω και τί είναι διαθέσιμο και από που να αρχίσει.</p>
<h2 id="σκοπός">Σκοπός</h2>
<p>Ο σκοπός του κειμένου αυτού δεν είναι να υποδείξει τα use cases για κάθε εργαλείο για κάθε <em>&ldquo;network automation engineer&rdquo;</em>. Αυτό είναι αδύνατο. Ο βασικός σκοπός είναι ο καινούριος εκπαιδευόμενος να μάθει για τα εργαλεία και τις τεχνολογίες στη διάθεση του. Γνωρίζοντας αυτά, εκείνος ή εκείνη θα μπορέσει να αναγνωρίσει το τί ακριβώς ταιριάζει σαν λύση στα προβλήματα που μόνο εκείνος γνωρίζει για το περιβάλλον του.</p>
<h2 id="βασικά-σημεία-εκκίνησης">Βασικά σημεία εκκίνησης</h2>
<p>Υπάρχουν αρκετά blog posts στο internet πλέον για συγκεκριμένα use cases, όπως και ανοικτές κοινότητες, είτε οργανωμένες από network &amp; system vendors (Cisco, Juniper, Vmware, Redhat, κλπ) είτε ανεξάρτητες ομάδες οργανωμένες γύρω από κάποιο εργαλείο. Σε κάποιες από αυτές θα βρείτε βάσεις δεδομένων με use cases.
Συμμετέχοντας σε κάποιες κοινότητες (όπως αυτήν εδώ) ενδεχομένως θα σας δοθεί η ευκαιρία να μιλήσετε με κάποιους που έχουν κάνει ήδη κάτι κοντά σε αυτό που θέλετε να πετύχετε.</p>
<p>Όμως το πεδίο είναι ακόμα παρθένο. Υπάρχει αρκετός χώρος για καινοτομία. Οπότε, αν δεν βρίσκετε άμεσα αυτό ακριβώς που θέλετε, υπομονή. Από την άλλη ίσως σας δοθεί η ευκαιρία να αναπτύξετε κάτι κι εσείς!</p>
<h2 id="κι-αν-θέλω-οπωσδήποτε-συμβουλές"><em>&ldquo;Κι αν θέλω οπωσδήποτε συμβουλές;&quot;</em></h2>
<p>Τότε θα πρέπει να αναζητήσετε blog posts σχετικά με το γιατί και το πως:</p>
<ul>
<li>Why automate
<ul>
<li><a href="https://www.juniper.net/us/en/dm/infographic/four-reasons-to-automate/">https://www.juniper.net/us/en/dm/infographic/four-reasons-to-automate/</a></li>
<li><a href="https://www.redhat.com/en/topics/automation">https://www.redhat.com/en/topics/automation</a></li>
<li><a href="https://www.cisco.com/c/en/us/solutions/automation/network-automation.html">https://www.cisco.com/c/en/us/solutions/automation/network-automation.html</a></li>
</ul>
</li>
<li>How to get started
<ul>
<li><a href="https://www.rogerperkin.co.uk/network-automation/how-to-learn/">https://www.rogerperkin.co.uk/network-automation/how-to-learn/</a></li>
<li><a href="https://blog.danielteycheney.com/posts/starting-your-network-automation-journey/">https://blog.danielteycheney.com/posts/starting-your-network-automation-journey/</a></li>
<li><a href="https://www.ipspace.net/kb/NetAutJourney/">https://www.ipspace.net/kb/NetAutJourney/</a></li>
</ul>
</li>
<li>Introduction Videos - Προτείνω τη σειρά NetDevOps Live
<ul>
<li><a href="https://developer.cisco.com/netdevops/live/">https://developer.cisco.com/netdevops/live/</a></li>
<li><a href="https://www.youtube.com/watch?v=_6ZoQ1QRw7I&amp;list=PL2k86RlAekM-0_lErsVdS_xqQMLYRcdhU">https://www.youtube.com/watch?v=_6ZoQ1QRw7I&amp;list=PL2k86RlAekM-0_lErsVdS_xqQMLYRcdhU</a></li>
<li><a href="https://www.youtube.com/playlist?list=PL2k86RlAekM8AVJ4i_spFJfSHknNMGOkI">https://www.youtube.com/playlist?list=PL2k86RlAekM8AVJ4i_spFJfSHknNMGOkI</a></li>
</ul>
</li>
</ul>
<p>Δείτε και τις προτάσεις για <em>What to read next</em> στο τέλος του άρθρου.</p>
<p>Βασικά πάρτε απόφαση ότι δεν είναι δυνατό ξαφνικά να τα μάθετε όλα, όπως και δεν είναι δυνατό, αν θέλετε πρακτικά αποτελέσματα, να μάθετε πρώτα &ldquo;τέλεια&rdquo; ένα εργαλείο ή μια τεχνολογία και μετά να την εφαρμόσετε στην πράξη για να λύσετε κάποιο πρόβλημα που σας απασχολεί.</p>
<p>Κάντε μικρά βήματα, και μην φοβάστε το &ldquo;πασάλειμμα&rdquo;. Στην ουσία ακολουθήστε το μονοπάτι &ldquo;learn by doing&rdquo;. Θα μπορέσετε να έχετε σύντομα μικρές νίκες, οι οποίες θα σας δώσουν ενέργεια για να συνεχίσετε την προσπάθεια και να εμβαθύνετε. Και μετά αποφασίζετε για την τελική σας κατεύθυνση. Το βασικό ερώτημα, είναι αυτό που ακολουθεί:</p>
<h3 id="to-code-or-not-to-code">To code or not to code</h3>
<p>Πολλοί διαχωρίζουν τα τεχνολογικά εργαλεία για το network automation σε αυτά που απαιτούν γνώσεις γλώσσας προγραμματισμού και σε αυτά που χρησιμοποιούν περιγραφικές γλώσσες συγκεκριμένου πεδίου εφαρμογής, τις λεγόμενες <em>DSL</em> (Domain Specific Language). Με αυτό το σκεπτικό πολλές φορές διαλέγουν αυτό που θεωρούν κατάλληλο ανάλογα με το περιβάλλον της εφαρμογής του εργαλείου, π.χ. ανάλογα με τις προγραμματιστικές γνώσεις και ικανότητες αυτών που θα το χρησιμοποιήσουν.</p>
<h4 id="to-code---devices">To Code - Devices</h4>
<p>Στην πρώτη περίπτωση μπορεί κανείς να χρησιμοποιήσει διάφορες γλώσσες για να &ldquo;μιλήσει&rdquo; με δικτυακό εξοπλισμό ή με REST APIs (API - Application Programming Interface, REST - REpresentational State Transfer) εργαλείων λογισμικού που συνήθως χρησιμοποιούνται για τη διαχείριση δικτυακών υπηρεσιών και συσκευών ή άλλους σκοπούς, όπως π.χ. Cisco Prime Infrastructure, ή Cisco DNA, Cisco SD-WAN, Cisco Meraki, Netbox, κλπ.
Οι πιο διαδεδομένες επιλογές για την πρώτη περίπτωση είναι οι Python &amp; Go, αλλα είναι δυνατό να χρησιμοποιήσει κανείς και άλλες, όπως Perl &amp; TCL.
Στο παρακάτω άρθρο, αναφέρονται 5 γλώσσες με την πέμπτη επιλογή να είναι η Ansible, εσφαλμένα κατά τη γνώμη μου καθώς δεν είναι γλώσσα προγραμματισμού:
<a href="https://www.techrepublic.com/article/5-programming-languages-network-architects-should-learn/">https://www.techrepublic.com/article/5-programming-languages-network-architects-should-learn/</a></p>
<h4 id="to-code---rest-apis">To Code - (REST) APIs</h4>
<p>Ο πιο απλός τρόπος να εξερευνήσει κάποιος ένα API είναι ή με ενσωματωμένο documentation όπως είναι το swagger interface, ή με εφαρμογές που μπορούν να κάνουν API requests χωρίς να χρησιμοποιούν προγραμματιστικό κώδικα. Τέτοιες εφαρμογές ονομάζονται REST Clients, και μια από τις πιο γνωστές είναι ο <strong><a href="https://www.postman.com">Postman</a></strong></p>
<p>O Postman μπορεί να δημιουργήσει API calls συμπληρώνοντας απλώς URLs και επιλογές στο γραφικό του περιβάλλον και να μετατρέψει αυτό to request σε κώδικα για διάφορες γλώσσες, π.χ. python, java, javascript, C, C#, PHP, Ryby, Swift, κλπ. Έτσι μπορείτε άμεσα να δείτε πως θα μπορούσε να είναι ένα request στη γλώσσα προγραμματισμού που σας ενδιαφέρει.</p>
<p>Σε περίπτωση που θέλει κανείς να επενδύσει σε μια γλώσσα προγραμματισμού για να κάνει REST API calls, υπάρχουν περισσότερες επιλογές για γλώσσες, π.χ. python, java, javascript, κλπ αλλά θα ανταμοιφθεί αν επιλέξει τη γλώσσα Python για να το κάνει, καθώς του δίνεται αρκετή ευελιξία. Ο πιο διαδεδομένος τρόπος είναι με τη χρήση της βιβλιοθήκης requests, είτε χρησιμοποιώντας http/https sessions είτε μεμονωμένα requests. Υπάρχουν όμως κι άλλες επιλογές, όπως η βιβλιοθήκη httpx, η οποία γνωρίζει αρκετή εφαρμογή τελευταία.</p>
<ul>
<li><em>What is a REST API</em> - <a href="https://youtu.be/lsMQRaeKNDk">https://youtu.be/lsMQRaeKNDk</a></li>
<li><em>REST API concepts and examples</em> - <a href="https://youtu.be/7YcW25PHnAA">https://youtu.be/7YcW25PHnAA</a></li>
</ul>
<h4 id="not-to-code">Not to code?</h4>
<p>Δεν σας αρέσει ο προγραμματισμός; Προσωπική μου άποψη, καλύτερα να αλλάξετε γνώμη αλλά αν επιμένετε υπάρχουν διάφορα εργαλεία που μπορείτε να χρησιμοποιήσετε. Θα πρέπει ωστόσο να επενδύσετε χρόνο να μάθετε την περιγραφική αυτή γλώσσα και ένα λεξιλόγιο που δεν θα είναι μεν γλώσσα προγραμματισμού αλλά θα έχει συντακτικό και γενικά δομή και κανόνες.
Τέτοια εργαλεία είναι π.χ. το <strong>Ansible</strong>, το <strong>Cheff</strong>, το <strong>Puppet</strong> και άλλα.
Το πιο εύκολο για να αρχίσετε να ασχολείστε είναι το Ansible αλλά είναι καθαρά θέμα προσωπικής επιλογής από ένα σημείο και μετά.
To Ansible είναι εργαλείο που κατασκευάστηκε και αναπτύσσεται/συντηρείται από τη Redhat, χρησιμεύει για αυτοματισμό σε διάφορους τομείς, από servers και services, μέχρι http/rest API calls, μέχρι network devices &amp; services και πολλά άλλα, ενώ μπορεί να εγκατασταθεί σε περιβάλλοντα Linux αλλά τελευταία είναι δυνατή και η εγκατάσταση του σε περιβάλλοντα Windows. Έχουμε ήδη ένα post σχετικά με το Ansible και θα υπάρξουν κι άλλα. Για να μάθετε περισσότερα κατευθυνθείτε αρχικά εδώ</p>
<ul>
<li><a href="https://www.ansible.com/">https://www.ansible.com/</a></li>
<li><a href="https://www.ansible.com/resources/get-started">https://www.ansible.com/resources/get-started</a></li>
</ul>
<p>και θα εμπλουτίσουμε το περιεχόμενο σιγά - σιγά γι αυτό. Το Ansible είναι free για εγκατάσταση και χρήση αλλά υπάρχει εταιρική έκδοση μιας πλατφόρμας διαχείρισης του από τη Redhat, γνωστή με το όνομα <a href="https://www.ansible.com/products/tower">Ansible Tower</a></p>
<h3 id="cloud">Cloud?</h3>
<p>Δεν είμαι ειδικός. Υπάρχει μεγάλη δυνατότητα να αυτοματοποιήσετε τις λειτουργίες που χρησιμοποιείτε με cloud services ανάλογα με τις δυνατότητες που δίνει ο cloud provider, μην ξεχνάτε πως οτιδήποτε θεωρείτε ότι λειτουργεί στο cloud είναι στην ουσία software applications, ενδεχομένως ακόμα και βασικές δικτυακές λειτουργίες. Πολύ δημοφιλές εργαλείο είναι το <strong>Terraform</strong> της Hashicorp για το οποίο όλοι ελπίζουμε ο Ν.Κ. να μας μάθει λίγα πράγματα.
Προς το παρόν κρατήστε τα παρακάτω:</p>
<ul>
<li><a href="https://www.terraform.io/intro/index.html">https://www.terraform.io/intro/index.html</a></li>
<li><a href="https://learn.hashicorp.com/tutorials/terraform/automate-terraform">https://learn.hashicorp.com/tutorials/terraform/automate-terraform</a></li>
</ul>
<h3 id="άγνωστες-λέξεις---buzz-words">Άγνωστες λέξεις - Buzz Words</h3>
<p>Έχετε λοιπόν αποφασίσει να αρχίσετε να ασχολείστε με Network Automation και με την πρώτη φορά που αρχίζετε να διαβάζετε κάποιο κείμενο ή να δείτε κάποιο video, βομβαρδίζεστε με άγνωστες λέξεις:</p>
<h4 id="parsing"><em>Parsing</em></h4>
<p>Όταν χρησιμοποιούμε εργαλεία για να επικοινωνήσουμε με συσκευές ή (REST) APIs, συνήθως λαμβάνουμε απαντήσεις στις εντολές μας ή στα API Calls μας οι οποίες είναι με μορφή STRING (σειρές χαρακτήρων), ή χρησιμοποιώντας πιο απλή ορολογία, κείμενο. Φανταστείτε το κείμενο που παίρνετε ως απάντηση σε μια κονσόλα δικτυακής συσκευής. Σαν μηχανικοί έχετε μάθει να το ερμηνεύετε. Για να είναι όμως αξιοποιήσημο προγραμματιστικά, ώστε πχ. να το συνδυάσετε με άλλα δεδομένα ή να το κάνετε δεδομένα εισαγωγής για άλλα εργαλεία ή να ελέγξετε αν ισχύει κάποιο ενδεχόμενο κλπ, πρέπει να περάσετε αυτό το κείμενο από ειδικά φίλτρα ώστε να απομονώσετε τις πληροφορίες που σας ενδιαφέρουν και τις οποίες ο κώδικας σας ή το DSL-based εργαλείο σας θα αναγνωρίσει και θα επεξεργαστεί. Σε αυτές τις περιπτώσεις έχει κανείς δύο επιλογές:</p>
<ul>
<li>Εφαρμογή Regular Expressions - γνωστό και ως RegEx, υπάρχει δυνατότητα χρήσης του και σε γλώσσες όπως η Python αλλά και σε DSL-Based εργαλεία, με πλεονέκτημα τη μεγάλη αποτελεσματικότητα και ακρίβεια (αν χρησιμοποιηθεί σωστά) και μεινονεκτήματα την πολυπλοκότητα στην εκμάθηση και τη χρήση.</li>
<li>Χρήση προκατασκευασμένων φίλτρων γνωστών ως parsers, οι οποίοι έχουν προδιαγεγραμμένα πρότυπα ώστε να αναγνωρίζουν και να απομονώνουν δεδομένα ανάλογα με συγκεκριμένες εντολές και requests. Π.χ. μια εντολή
<pre><code class="language-cisco" data-lang="cisco">show ip interfaces
</code></pre><p>χρειάζεται parser ειδικά κατασκευασμένο γι αυτή ο οποίος θα δώσει αυτόματα τις απαντήσεις χωρισμένες σε συγκεκριμένα πεδία δεδομένων. Σας μπέρδεψα; Λογικό. Χρειάζεται να δείτε παραδείγματα. Σύντομα σε ξεχωριστό άρθρο. Προς το παρόν κρατήστε ότι η απάντηση από την παραπάνω εντολή μπορεί να μας ενδεχομένως να μας δώσει σε ξεχωριστές μεταβλητές το όνομα και τον τύπο του interface, την ip address και την network mask, το αν είναι ενεργό ή όχι, κλπ, ώστε να μπορούμε να τις επεξεργαστούμε για να εφαρμόσουμε την αυτοματοποιημένη λογική που επιθυμούμε. Γνωστοί parsers με τη μορφή βιβλιοθηκών python, είναι οι text-fsm/ntc, pyats/genie, ttp. Υπάρχει δυνατότητα χρήσης κάποιων από αυτούς και από DSL-based εργαλεία.</p>
</li>
</ul>
<h4 id="json-xml-yang"><em>JSON, XML, Yang</em></h4>
<p>Η χρήση σκέτων strings για την αποθήκευση δεδομένων προφανώς δεν είναι πρακτική και αξιόπιστη. Σε πολλές περιπτώσεις βολεύει να κωδικοποιήσουμε τα δεδομένα με συγκεκριμένο τρόπο, ώστε να είναι πιο πρακτική η αποθήκευση και η ανάκτηση τους και να μπορούμε με μονοσήμαντο και αποτελεσματικό τρόπο να φτάσουμε ακριβώς στα δεδομένα που μας ενδιαφέρουν. To JSON - Javascript Syntax Notation και το XML - eXtensible Markup Language είναι τρόποι κωδικοποίησης δεδομένων, ο καθένας με τα πλεονεκτήματα και μειονεκτήματα του.
Η γλώσσα Yang χρησιμοποιείται για την αναπαράσταση μοντέλων δεδομένων (data models) με σκοπό να μπορούμε αποτελεσματικά να περιγράψουμε και να αποθηκεύσουμε δεδομένα σε ψηφιακή μορφή, όπου αποστολέας και παραλήπτης των δεδομένων έχουν ήδη κοινή γνώση για την αναμενόμενη μορφή των αποθηκευμένων δεδομένων και των κανόνων που τα διέπουν. Περισσότερα γι αυτά σε ξεχωριστό άρθρο, μαζί με τις επόμενες άγνωστες λέξεις</p>
<h4 id="netconf-restconf"><em>Netconf, Restconf</em></h4>
<p>Πρωτόκολλα για την διαχείριση και ρύθμιση συσκευών/λογισμικών χρησιμοποιώντας συγκεκριμένα (Yang) data models που υποστηρίζουν αυτές ώστε να καθορίσουμε ακριβώς και με αποδοτικότερο τρόπο τις παραμέτρους λειτουργίας τους και να πάρουμε πληροφορίες σχετικά με την κατάσταση και την απόδοση τους. Κάθε ένα από αυτά υποστηρίζει συγκεκριμένους τρόπους κωδικοποίησης των δεδομένων και λειτουργεί με συγκεκριμένη τεχνολογία για την ασφαλή μεταφορά των δεδομένων μεταξύ πηγής και παραλήπτη.</p>
<h4 id="connection-providers"><em>Connection Providers</em></h4>
<p>Συνήθως βιβλιοθήκες γλωσσών προγραμματισμού για τη σύνδεση με δικτυακές συσκευές ή άλλα συστήματα (π.χ. firewalls ή servers).
Εφόσον μιλάμε για συσκευές σαν τις παραπάνω διακρίνονται</p>
<ul>
<li>σε αυτούς που χρησιμοποιούν <em>legacy</em> τρόπους σύνδεσης, π.χ. πάνω από SSH/Telnet. Γνωστότερες περιπτώσεις είναι τα netmiko, napalm, scrapli (και pyats, αναφέρεται ξεχωριστά για λόγους που θα αναφερθούν παρακάτω)</li>
<li>σε αυτούς που χρησιμοποιούν τα γνωστά πρωτόκολλα Netconf/Restconf και Yang data models. Γνωστότερες περιπτώσεις είναι τα ncc, netconf-scrapli, http requests/httpx</li>
</ul>
<h4 id="network-testing-framerworks"><em>Network Testing Framerworks</em></h4>
<p>Αν και θα μπορούσαμε ενδεχομένως να μιλήσουμε γενικά για testing, εδώ κάνουμε ειδική αναφορά στο network testing framework, το οποίο η Cisco χρησιμοποιεί εσωτερικά εδώ και πάνω από 10 χρόνια, ενώ εδώ και 4 χρόνια το έχει ανοίξει για χρήση από όλους ως ανοικτό λογισμικό: Pyats/Genie</p>
<ul>
<li><a href="https://developer.cisco.com/docs/pyats/">https://developer.cisco.com/docs/pyats/</a></li>
<li><a href="https://developer.cisco.com/pyats/">https://developer.cisco.com/pyats/</a></li>
</ul>
<p>To PyATS έχει multi-layered αρχιτεκτονική όπου κάθε layer μπορεί να χρησιμοποιηθεί ανεξάρτητα από τα άλλα και διαθέτει και ικανότητες parsing με χιλιάδες parsers και μοντέλα για συσκευές από πολλούς διαφορετικούς κατασκευαστές πέραν της Cisco. Εδώ και μεγάλο διάστημα έχει ανακοινωθεί και διατεθεί και η πλατφόρμα διαχείρισης του με γραφικό τρόπο με πολλες έξτρα δυνατότητες, το <strong>XPRESSO</strong> το οποίο είναι στην ουσία ένα PyATS Dashboard</p>
<ul>
<li><a href="https://xpresso-sjc-1.cisco.com/home">https://xpresso-sjc-1.cisco.com/home</a></li>
<li><a href="https://developer.cisco.com/docs/pyats/#!pyats-dashboard-xpresso">https://developer.cisco.com/docs/pyats/#!pyats-dashboard-xpresso</a></li>
</ul>
<h4 id="concurrencyparallelismparallel-execution--configuration"><em>Concurrency/Parallelism/Parallel Execution &amp; Configuration</em></h4>
<p>Χωρίς να μπούμε σε λεπτομέρειες που θα μας δώσουν με ακρίβεια τον ορισμό των παραπάνω, ας παραμείνουμε στην ουσία που είναι ότι μπορείτε με κάποια εργαλεία να εκτελέσετε ομάδες ενεργειών παράλληλα σε ένα μεγάλο αριθμό από συσκευές, αν ο αριθμός τους είναι τέτοιος ώστε να έχει νόημα να κερδίσετε αρκετό χρόνο με την &ldquo;παράλληλη&rdquo; εκτέλεση της ίδιας δέσμης ενεργειών σε όλες. Τέτοια frameworks που επιτρέπουν κάτι τέτοιο είναι τα</p>
<ul>
<li>Nornir (Python Based, μπορεί να χρησιμοποιήσει διάφορουης connection providers)</li>
<li>PyATS (Python Based, own connection provider)</li>
<li>Ansible</li>
</ul>
<p>Και εδώ θα δούμε το αντικείμενο αυτό σε ξεχωριστό άρθρο. Κάποια links ειδικά για το Nornir:</p>
<ul>
<li><a href="https://nornir.readthedocs.io/en/latest/">https://nornir.readthedocs.io/en/latest/</a></li>
<li><a href="https://nornir.readthedocs.io/en/latest/tutorial/overview.html">https://nornir.readthedocs.io/en/latest/tutorial/overview.html</a></li>
<li><a href="https://github.com/nornir-automation/nornir/discussions">https://github.com/nornir-automation/nornir/discussions</a></li>
</ul>
<h4 id="devops-netdevops-containers-docker-kubernetes-microservices-cicd-"><em>DevOps, NetDevOps, Containers, Docker, Kubernetes, Microservices, CI/CD, &hellip;</em></h4>
<p>Ψυχραιμία. Σιγά - Σιγά. Τα παραπάνω είναι συστατικά μιας νέας κουλτούρας για ανάπτυξη εφαρμογών όσο αφορά στο network automation αλλά στον κόσμο των developpers δεν είναι τόσο καινούρια. Κρατήστε ότι όλα αυτά έχουν να κάνουν με Coding Methodologies και Development Projects από ομάδες συνεργατών, τα οποία θα εξετάσουμε σιγά - σιγά. Θα αποφύγουμε να μετατρέψουμε το συγκεκριμένο post σε Καζαμία του Automation και σας δίνουμε ραντεβού σε επόμενα post για περισσότερες εξηγήσεις για τα συγκεκριμένα. Δεν είναι σίγουρα κάτι που θα ασχοληθείτε τον πρώτο καιρό που θα κάνετε επαφή με το αντικείμενο.</p>
<h2 id="τελειώσαμε"><em>&ldquo;Τελειώσαμε;&quot;</em></h2>
<p>Με τίποτε. Απλώς αρχίζουμε. Είπαμε, υπομονή. Αν έχετε διαβάσει ως εδώ, είτε με την πρώτη, είτε γενικά, μάλλον έχετε υπομονή. Σας υπόσχομαι ότι αξίζει τον κόπο.</p>
<h2 id="ωραία-όλα-αυτά-και-τώρα-τί-κάνω-εγώ"><em>&ldquo;Ωραία όλα αυτά.. Και τώρα τί κάνω εγώ;&quot;</em></h2>
<p>Είπαμε και στην αρχή κάποια πράγματα. Ακολουθούν προτάσεις:</p>
<h2 id="αναζητήστε-κοινότητες-και-ενημέρωση">Αναζητήστε κοινότητες και ενημέρωση</h2>
<h3 id="άναρχα">Άναρχα</h3>
<p>Μπορείτε να ψάξετε σε μέσα δικτύωσης όπως το Twitter ή το LinkedIn για άτομα και groups που ασχολούνται με αυτά τα αντικείμενα ώστε να φτιάξετε σιγά-σιγά ένα κύκλο ενημέρωσης και συζήτησης. Παίρνει χρόνο αλλά αξίζει τον κόπο. Βοηθάει η χρήση των hashes (#) σε αυτη την περίπτωση. Κάντε σχετικές αναζητήσεις ή ρωτήστε και εμάς.</p>
<h3 id="οργανωμένα">Οργανωμένα</h3>
<p>Υπάρχουν αρκετές κοινότητες από απλούς μηχανικούς χωρίς δεσμεύσεις και προτιμήσεις (σαν και τη δικιά μας κοινότητα). Άλλες οργανώνονται γύρω από discussion sites/tools όπως το Slack, άλλες με εργαλεία σαν το discorde, άλλες με podcasts κλπ.</p>
<h3 id="blogs">Blogs</h3>
<h4 id="automate-your-network---john-capobianco">Automate your Network - John Capobianco</h4>
<p>Υπάρχουν blogs που είναι επικεντρωμένα στο automation. Θα ξεκινήσουμε με ένα που δεν είναι το πιο αντιπροσωπευτικό για όλα, ανήκει όμως σε έναν παθιασμένο automation μηχανικό που είναι φανατικός υποστηρικτής του Ansible και chief technologist στη Βουλή του Καναδά. Το ιδιαίτερο σε αυτή την περίπτωση έγκειται επίσης στο ότι έχει πολύ πρόσφατα συγκεντρώσει σε μία σελίδα links για blogs, github repos, community pages κλπ, όπου φιλοξενείται πλέον σύνδεσμος και για την δική μας κοινότητα:</p>
<ul>
<li><a href="https://www.automateyournetwork.ca/">https://www.automateyournetwork.ca/</a></li>
<li><a href="https://www.automateyournetwork.ca/community-links/">https://www.automateyournetwork.ca/community-links/</a></li>
</ul>
<h4 id="python-for-network-engineers---kirk-byers">Python for Network Engineers - Kirk Byers</h4>
<p><a href="https://pynet.twb-tech.com/">https://pynet.twb-tech.com/</a> - Ο Kirk Byers είναι μηχανικός δικτύων με εξαιρετικές γνώσεις τόσο γύρω από Python όσο και το Ansible και εκτός από το περιεχόμενο στο site του, διαθέτει δωρεάν ένα email course για Python ειδικά για Network Engineers, όπου κάνει γρήγορη εισαγωγή στη γλώσσα και στη συνέχεια εξηγεί πως μπορεί κανείς να συνδεθεί προγραμματιστικά σε συσκευές χρησιμοποιώντας τη βιβλιοθήκη Netmiko για τη γλώσσα Python, η οποία υποστηρίζει συνδέσεις μέσω SSH &amp; Telnet. To Netmiko υποστηρίζει και τη χρήση parsers για να παίρνετε δεδομένα σε δομημένη μορφή, είτε με τη χρήση textfsm/ntc είτε με χρήση PyATS/Genie. Το επόμενο free course αρχίζει στις 2 Μαρτίου, μπορείτε να γραφτείτε εδώ:</p>
<p><a href="https://pynet.twb-tech.com/email-signup.html">https://pynet.twb-tech.com/email-signup.html</a></p>
<p>Τα paid courses αφορούν Python (Advanced), Ansible &amp; Nornir. Σας συμβουλεύω να γραφτείτε το στο email course το οποίο περιλαμβάνει κείμενο, παραδείγματα και video από την πλατφόρμα Vimeo.</p>
<h4 id="nwmichl-blog">NWMichl Blog</h4>
<p><a href="https://nwmichl.net/">https://nwmichl.net/</a> - O Michael Shoen είναι ένας εξαιρετικός μηχανικός, χωρίς ίχνος ματαιοδοξίας, και πολύ καταρτισμένος σχεδόν σε κάθε τεχνικό πεδίο που αφορά τον αυτοματισμό.</p>
<h4 id="ttl255---przemek-rogalas-blog">TTL255 - Przemek Rogala&rsquo;s blog</h4>
<p><a href="https://ttl255.com/">https://ttl255.com/</a> - Ο Przemek έχει ιδιαίτερο ταλέντο να συνδυάζει δικτυακά θέματα με κομμάτια automation υψηλών απαιτήσεων, όπως η σειρά του για jinja templates, ή για το Python SDK Pynetbox που χρησιμεύει για τη διευκόλυνση της διαχείρισης του API του Netbox.</p>
<h4 id="network-to-code---ntc">Network to Code - NTC</h4>
<p><a href="https://blog.networktocode.com/">https://blog.networktocode.com/</a> - Η εταιρεία που δημιουργήθηκε από ένα slack channel και κατέληξε να είναι ίσως η καλύτερη εταιρεία consulting για network automation.</p>
<h4 id="cisco-developer-blog">Cisco Developer Blog</h4>
<p><a href="https://blogs.cisco.com/developer">https://blogs.cisco.com/developer</a> - Το κομμάτι των Cisco Blogs που αφορά στο NetDevOps και το Network Automation. Θα βρείτε εκεί και κάποια blog posts από μηχανικούς της κοινότητας μας ;)</p>
<h4 id="real-python-tutorials">Real Python Tutorials</h4>
<p><a href="https://realpython.com/">https://realpython.com/</a> - Εξαιρετικό site όπου μπορείτε να βρείτε blog posts και videos οργανωμένα θεματικά για το πως να κάνετε συγκεκριμένα πράγματα με τον Python, πως να δουλέψετε με αρχεία, ή πως να δημιουργήσετε και να στείλετε emails, πως να διαβάσετε αρχεία κειμένου ή excel, κλπ. Έχει και δυνατότητα subscription για πιο προχωρημένα πράγματα.</p>
<h3 id="ψάξτε-για-εκπαίδευση">Ψάξτε για εκπαίδευση</h3>
<h4 id="vendor-backed-sites">Vendor backed Sites</h4>
<ul>
<li>Cisco Devnet -  <a href="https://developer.cisco.com/">https://developer.cisco.com/</a> - Γραφτείτε στο πρόγραμμα στης Cisco για το δικτυακό αυτοματισμό και θα αποκτήσετε πρόσβαση σε μεγάλο αριθμό από resouces.
Τί είναι το Cisco Devnet; Δείτε αυτό <a href="https://youtu.be/YuCgIUORimU">https://youtu.be/YuCgIUORimU</a>
<ul>
<li>Cisco Devnet Learning Tracks - Περιεχόμενο για εκμάθηση οργανωμένο ανά περιοχή - <a href="https://developer.cisco.com/learning/tracks">https://developer.cisco.com/learning/tracks</a></li>
<li>Cisco Devnet Learning Labs - Περιεχόμενο που λειτουργεί σε συνδυασμό με εργαστήρια στο Cloud της Cisco (Sandboxes) - <a href="https://developer.cisco.com/learning/labs">https://developer.cisco.com/learning/labs</a></li>
<li>Cisco Devnet Sandboxes - <a href="https://developer.cisco.com/site/sandbox/">https://developer.cisco.com/site/sandbox/</a></li>
<li>Cisco Devnet Sandbox Catalog - <a href="https://devnetsandbox.cisco.com/RM/Topology">https://devnetsandbox.cisco.com/RM/Topology</a></li>
</ul>
</li>
<li>Cisco Learning Network - <a href="https://learningnetwork.cisco.com/s/">https://learningnetwork.cisco.com/s/</a>
<ul>
<li>Cisco Devnet Associate Prep Program - <a href="https://learningnetwork.cisco.com/s/learning-plan-detail-standard?ltui__urlRecordId=a1c3i0000007q9cAAA">https://learningnetwork.cisco.com/s/learning-plan-detail-standard?ltui__urlRecordId=a1c3i0000007q9cAAA</a></li>
<li>Cisco SDN Training Videos - <a href="https://learningnetwork.cisco.com/s/learning-plan-detail-standard?ltui__urlRecordId=a1c3i0000005hZzAAI">https://learningnetwork.cisco.com/s/learning-plan-detail-standard?ltui__urlRecordId=a1c3i0000005hZzAAI</a></li>
</ul>
</li>
<li>Juniper - <a href="https://learningportal.juniper.net/juniper/user_activity_info.aspx?id=11478">https://learningportal.juniper.net/juniper/user_activity_info.aspx?id=11478</a></li>
<li>Redhat - <a href="https://www.redhat.com/en/blog/red-hat-provides-free-learning-opportunities">https://www.redhat.com/en/blog/red-hat-provides-free-learning-opportunities</a></li>
<li>Vmware Kubernetes Academy - <a href="https://kube.academy/">https://kube.academy/</a></li>
<li>Hashicorp - <a href="https://learn.hashicorp.com/">https://learn.hashicorp.com/</a></li>
<li>Checkpoint - <a href="https://sc1.checkpoint.com/documents/latest/APIs/#introduction~v1.7%20">https://sc1.checkpoint.com/documents/latest/APIs/#introduction~v1.7%20</a></li>
</ul>
<h4 id="learning-platforms">Learning Platforms</h4>
<ul>
<li>Pluralsight - <a href="https://www.pluralsight.com/">https://www.pluralsight.com/</a></li>
<li>O&rsquo;Reilly Online - <a href="https://www.oreilly.com/online-learning/">https://www.oreilly.com/online-learning/</a></li>
<li>Udemy - <a href="https://www.udemy.com/">https://www.udemy.com/</a></li>
<li>GNS3 Academy - <a href="https://gns3.teachable.com/">https://gns3.teachable.com/</a></li>
<li>Codemy - <a href="https://codemy.com/">https://codemy.com/</a></li>
<li>CBT Nuggets - <a href="https://www.cbtnuggets.com/">https://www.cbtnuggets.com/</a></li>
<li>LinkedIn - Η παλιά πλατφόρμα Linda.com - <a href="https://www.cbtnuggets.com/">https://www.cbtnuggets.com/</a></li>
<li>Pact - <a href="https://www.packtpub.com/free-learning">https://www.packtpub.com/free-learning</a></li>
<li>IpSpace.net - Η πλατφόρμα του Ivan Pelpejnak - <a href="https://www.ipspace.net/Main_Page">https://www.ipspace.net/Main_Page</a></li>
</ul>
<h4 id="youtube">Youtube</h4>
<p><a href="https://www.youtube.com/">https://www.youtube.com/</a></p>
<h3 id="αναζητήστε-use-cases">Αναζητήστε Use Cases</h3>
<h4 id="special-websitessearch-engines">Special Websites/Search Engines</h4>
<ul>
<li>Cisco Devnet Code Exchange - <a href="https://developer.cisco.com/codeexchange/">https://developer.cisco.com/codeexchange/</a></li>
<li>Cisco Devnet Automation Exchange - <a href="https://developer.cisco.com/network-automation/">https://developer.cisco.com/network-automation/</a></li>
</ul>
<h4 id="github">Github</h4>
<p><a href="https://github.com/">https://github.com/</a></p>
<h2 id="what-to-read-next">What to read next</h2>
<ul>
<li>
<p>Πολύ καλή εισαγωγική παρουσίαση από τον Cisco Devnet Frontman Hank Preston από το Cisco Live On Demand Library (Cisco Live Barcelona 2020) <a href="https://www.ciscolive.com/global/on-demand-library.html?search=how%20to%20be%20a%20network%20engineer%20in%20a%20programmable%20age&amp;search.event=ciscoliveemea2020&amp;search.event=ciscoliveemea2019#/session/1564527385244001ctfJ">εδώ</a></p>
</li>
<li>
<p>Ο Daniel Dibb είναι ένας πολύ γνωστός Network Architect, μέλος του CCIE Advisory Council, ο οποίος συντηρεί ένα εξαιρετικό και βραβευμένο blog site με τίτλο <a href="https://lostintransit.se/">Lost in Transit</a></p>
<p>Ξεκίνησε φέτος μια προσπάθεια ως αρχάριος να προσεγγίσει το Network Automation και κατέγραψε την πορεία του μέχρι την απόκτηση του πρώτου του Network Automation Certification. Ξεκίνησε αρκετά επιφυλακτικά, και αυτό καταγράφεται στο πρώτο του blog, <a href="https://lostintransit.se/2020/06/02/getting-over-my-fear-of-network-automation/">εδώ</a></p>
</li>
<li>
<p>How to get started with Network Automation, by Hank Preston - <a href="https://blogs.cisco.com/developer/learning-network-automation">https://blogs.cisco.com/developer/learning-network-automation</a></p>
</li>
<li>
<p><em>A Development Team is more than the sum of its parts</em> - Ένα blog post γραμμένο από τους Γ.Θ. και Κ.Δ. σχετικά με τον τρόπο και τα οφέλη της πραγματική συνεργασίας στο Development για Network Automation Projects - <a href="https://blogs.cisco.com/developer/team-more-than-sum">https://blogs.cisco.com/developer/team-more-than-sum</a></p>
</li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>EEM monitor interface stats</title>
            <link>https://netautogr.github.io/posts/2020/11/eem-monitor-interface-stats/</link>
            <pubDate>Thu, 26 Nov 2020 01:28:49 +0200</pubDate>
            
            <guid>https://netautogr.github.io/posts/2020/11/eem-monitor-interface-stats/</guid>
            <description>The following applet is triggered whenever the transmit rate on the given interface falls below the configured threshold.
event manager applet speaker_monitor_Gi7/0/9 authorization bypass event interface name GigabitEthernet7/0/9 parameter transmit_rate_bps entry-op le entry-val 1500000 entry-type value poll-interval 120 action 1.01 syslog msg &amp;quot;------ EEM GENERATED MESSAGE ---------&amp;quot; action 1.02 syslog msg &amp;quot;----- SPEAKER RECEIVE RATE UNDER 1.5Mbps DETECTED ----&amp;quot; action 1.03 cli command &amp;quot;enable&amp;quot; action 1.05 cli command &amp;quot;configure terminal&amp;quot; action 1.</description>
            <content type="html"><![CDATA[<p>The following applet is triggered whenever the transmit rate on the given interface falls below the configured threshold.</p>
<pre><code>event manager applet speaker_monitor_Gi7/0/9 authorization bypass
event interface name GigabitEthernet7/0/9 parameter transmit_rate_bps entry-op le entry-val 1500000 entry-type value poll-interval 120
action 1.01 syslog msg &quot;------ EEM GENERATED MESSAGE ---------&quot;
action 1.02 syslog msg &quot;----- SPEAKER RECEIVE RATE UNDER 1.5Mbps DETECTED ----&quot;
action 1.03 cli command &quot;enable&quot;
action 1.05 cli command &quot;configure terminal&quot;
action 1.07 cli command &quot;interface GigabitEthernet7/0/9&quot;
action 1.08 cli command &quot;shutdown&quot;
action 1.09 wait 5
action 1.10 cli command &quot;no shutdown&quot;
action 2 mail server &quot;$_email_server&quot; to &quot;$_email_to&quot; from &quot;$_email_from&quot; subject &quot;Dante Speaker was rebooted&quot; body &quot;Dante Speaker on port GigabitEthernet7/0/9 was rebooted due to not receiving multicast audio stream.&quot;
</code></pre><p><em>courtesy of Chris Partsenidis</em></p>
]]></content>
        </item>
        
        <item>
            <title>EEM monitor traffic</title>
            <link>https://netautogr.github.io/posts/2020/11/eem-monitor-traffic/</link>
            <pubDate>Thu, 26 Nov 2020 01:25:46 +0200</pubDate>
            
            <guid>https://netautogr.github.io/posts/2020/11/eem-monitor-traffic/</guid>
            <description>The two below applets monitor Upload and Download traffic on specific interfaces. When they exceed 7Mbps for more than 180 seconds (3 minutes), it will execute the configured commands, capture the output and email it to me. Very useful for monitoring WAN links.
event manager applet wan-download_monitor authorization bypass event interface name GigabitEthernet0/1 parameter receive_rate_bps entry-op ge entry-val 7000000 entry-type increment poll-interval 180 action 1.01 syslog msg &amp;quot;------ EEM GENERATED MESSAGE ---------&amp;quot; action 1.</description>
            <content type="html"><![CDATA[<p>The two below applets monitor Upload and Download traffic on specific interfaces. When they exceed 7Mbps for more than 180 seconds (3 minutes), it will execute the configured commands, capture the output and email it to me. Very useful for monitoring WAN links.</p>
<pre><code>event manager applet wan-download_monitor authorization bypass
event interface name GigabitEthernet0/1 parameter receive_rate_bps entry-op ge entry-val 7000000 entry-type increment poll-interval 180
action 1.01 syslog msg &quot;------ EEM GENERATED MESSAGE ---------&quot;
action 1.02 syslog msg &quot;----- HIGH DOWNLOAD RATE DETECTED ----&quot;
action 1.03 cli command &quot;enable&quot;
action 1.04 set result &quot;&quot;
action 1.05 cli command &quot;show ip flow top-talkers&quot;
action 1.06 append result &quot;$_cli_result&quot;
action 1.07 cli command &quot;show interface gig 0/1&quot;
action 1.08 append result &quot;$_cli_result&quot;
action 2 mail server &quot;$_email_server&quot; to &quot;$_email_to&quot; from &quot;$_email_from&quot; subject &quot;High Download Rate Detected&quot; body &quot;Router has detected high Download rate exceeding 7 Mbps for over 4 minutes: $result&quot;
</code></pre><pre><code>event manager applet wan-upload_monitor authorization bypass
event interface name GigabitEthernet0/1 parameter transmit_rate_bps entry-op ge entry-val 7000000 entry-type increment poll-interval 180
action 1.01 syslog msg &quot;------ EEM GENERATED MESSAGE ---------&quot;
action 1.02 syslog msg &quot;----- HIGH UPLOAD RATE DETECTED ----&quot;
action 1.03 cli command &quot;enable&quot;
action 1.04 set result &quot;&quot;
action 1.05 cli command &quot;show ip flow top-talkers&quot;
action 1.06 append result &quot;$_cli_result&quot;
action 1.07 cli command &quot;show interface gig 0/1&quot;
action 1.08 append result &quot;$_cli_result&quot;
action 2 mail server &quot;$_email_server&quot; to &quot;$_email_to&quot; from &quot;$_email_from&quot; subject &quot;High Upload Rate Detected&quot; body &quot;Router has detected high Upload rate exceeding 7 Mbps for over 4 minutes: $result&quot;
</code></pre><p><em>courtesy of Chris Partsenidis</em></p>
]]></content>
        </item>
        
        <item>
            <title>EEM monitor environment</title>
            <link>https://netautogr.github.io/posts/2020/11/eem-monitor-environment/</link>
            <pubDate>Thu, 26 Nov 2020 01:24:34 +0200</pubDate>
            
            <guid>https://netautogr.github.io/posts/2020/11/eem-monitor-environment/</guid>
            <description>The following applet is triggered whenever there is a system environment message (%ENVMON) generated in the device&amp;rsquo;s syslog. E.g high temperature, failed power supply etc. As soon as EEM &amp;ldquo;sees&amp;rdquo; %ENVMON messages, it will execute the below commands, capture the output and email it to me:
event manager applet env_monitor authorization bypass event syslog pattern &amp;quot;%ENVMON&amp;quot; action 1.01 syslog msg &amp;quot;------ EEM GENERATED MESSAGE ---------&amp;quot; action 1.02 syslog msg &amp;quot;------ENVIRONMENT PROBLEM DETECTED----&amp;quot; action 1.</description>
            <content type="html"><![CDATA[<p>The following applet is triggered whenever there is a system environment message (%ENVMON) generated in the device&rsquo;s syslog. E.g high temperature, failed power supply etc. As soon as EEM &ldquo;sees&rdquo; %ENVMON messages, it will execute the below commands, capture the output and email it to me:</p>
<pre><code>event manager applet env_monitor authorization bypass
event syslog pattern &quot;%ENVMON&quot;
action 1.01 syslog msg &quot;------ EEM GENERATED MESSAGE ---------&quot;
action 1.02 syslog msg &quot;------ENVIRONMENT PROBLEM DETECTED----&quot;
action 1.03 cli command &quot;enable&quot;
action 1.04 set result &quot;&quot;
action 1.05 cli command &quot;show clock&quot;
action 1.06 append result &quot;$_cli_result&quot;
action 1.07 cli command &quot;show environment table&quot;
action 1.08 append result &quot;$_cli_result&quot;
action 2 mail server &quot;$_email_server&quot; to &quot;$_email_to&quot; from &quot;$_email_from&quot; subject &quot;Router Environmental Change Notification&quot; body &quot;$result&quot;
</code></pre><p><em>courtesy of Chris Partsenidis</em></p>
]]></content>
        </item>
        
        <item>
            <title>EEM monitor CPU</title>
            <link>https://netautogr.github.io/posts/2020/11/eem-monitor-cpu/</link>
            <pubDate>Thu, 26 Nov 2020 01:22:15 +0200</pubDate>
            
            <guid>https://netautogr.github.io/posts/2020/11/eem-monitor-cpu/</guid>
            <description>This applet monitors CPU usage. It&amp;rsquo;s extremely useful to monitor router or switch CPU usage. If the CPU usage exceeds 70% for more than 2 minutes, it will execute the commands below, capture the output and email it to me. Be mindful that the SNMP IODs might change depending on the IOS version or hardware device:
event manager applet cpu_monitor authorization bypass event snmp oid 1.3.6.1.4.1.9.9.109.1.1.1.1.3.1 get-type exact entry-op gt entry-val &amp;quot;70&amp;quot; entry-type value poll-interval 120 maxrun 20 action 1.</description>
            <content type="html"><![CDATA[<p>This applet monitors CPU usage. It&rsquo;s extremely useful to monitor router or switch CPU usage. If the CPU usage exceeds 70% for more than 2 minutes, it will execute the commands below, capture the output and email it to me. Be mindful that the SNMP IODs might change depending on the IOS version or hardware device:</p>
<pre><code>event manager applet cpu_monitor authorization bypass
event snmp oid 1.3.6.1.4.1.9.9.109.1.1.1.1.3.1 get-type exact entry-op gt entry-val &quot;70&quot; entry-type value poll-interval 120 maxrun 20
action 1.01 syslog msg &quot;------ EEM GENERATED MESSAGE ---------&quot;
action 1.02 syslog msg &quot;------HIGH CPU DETECTED----, CPU:$_snmp_oid_val %&quot;
action 1.03 cli command &quot;enable&quot;
action 1.04 set result &quot;&quot;
action 1.05 cli command &quot;show proc cpu sorted&quot;
action 1.06 append result &quot;$_cli_result&quot;
action 1.07 cli command &quot;show proc cpu history&quot;
action 1.08 append result &quot;$_cli_result&quot;
action 2 mail server &quot;$_email_server&quot; to &quot;$_email_to&quot; from &quot;$_email_from&quot; subject &quot;Router High CPU Usage Notification&quot; body &quot;$result&quot;
</code></pre><p><em>courtesy of Chris Partsenidis</em></p>
]]></content>
        </item>
        
        <item>
            <title>EΕΜ monitor track</title>
            <link>https://netautogr.github.io/posts/2020/11/e%CE%B5%CE%BC-monitor-track/</link>
            <pubDate>Thu, 26 Nov 2020 01:19:26 +0200</pubDate>
            
            <guid>https://netautogr.github.io/posts/2020/11/e%CE%B5%CE%BC-monitor-track/</guid>
            <description>This applet monitors &amp;ldquo;track 3&amp;rdquo; events which is configured to monitor a VM server via Ping. When &amp;lsquo;Track 3&amp;rsquo; is up, it will trigger this script, execute the show commands, capture the output and send them to me in an email:
event manager applet vm-2008-up authorization bypass event track 3 state up action 1.01 wait 5 action 1.02 syslog msg &amp;quot;------ IP SLA GENERATED MESSAGE ---------&amp;quot; action 1.03 syslog msg &amp;quot;------ VM-2008 Server UP ----&amp;quot; action 1.</description>
            <content type="html"><![CDATA[<p>This applet monitors &ldquo;track 3&rdquo; events which is configured to monitor a VM server via Ping. When &lsquo;Track 3&rsquo; is up, it will trigger this script, execute the show commands, capture the output and send them to me in an email:</p>
<pre><code>event manager applet vm-2008-up authorization bypass
event track 3 state up
action 1.01 wait 5
action 1.02 syslog msg &quot;------ IP SLA GENERATED MESSAGE ---------&quot;
action 1.03 syslog msg &quot;------ VM-2008 Server UP ----&quot;
action 1.04 cli command &quot;enable&quot;
action 1.05 set result &quot;&quot;
action 1.06 cli command &quot;show clock&quot;
action 1.07 append result &quot;$_cli_result&quot;
action 1.08 cli command &quot;show track 3 brief&quot;
action 1.09 append result &quot;$_cli_result&quot;
action 2 mail server &quot;$_email_server&quot; to &quot;$_email_to&quot; from &quot;$_email_from&quot; subject &quot;VM-2008 Server UP&quot; body &quot;$result&quot;
</code></pre><p><em>courtesy of Chris Partsenidis</em></p>
]]></content>
        </item>
        
        <item>
            <title>EEM send mail</title>
            <link>https://netautogr.github.io/posts/2020/11/eem-send-mail/</link>
            <pubDate>Thu, 26 Nov 2020 01:14:18 +0200</pubDate>
            
            <guid>https://netautogr.github.io/posts/2020/11/eem-send-mail/</guid>
            <description>Generic EEM script to send emails
event manager environment _email_to router-notifications@mydomain.com event manager environment _email_server 192.168.1.1 (This is your SMTP Server) event manager environment _email_from 2951@Office1 event manager environment _router_name 2951@Office1 event manager directory user policy &amp;quot;flash:/&amp;quot; courtesy of Chris Partsenidis</description>
            <content type="html"><![CDATA[<p>Generic EEM script to send emails</p>
<pre><code>event manager environment _email_to router-notifications@mydomain.com
event manager environment _email_server 192.168.1.1 (This is your SMTP Server)
event manager environment _email_from 2951@Office1
event manager environment _router_name 2951@Office1
event manager directory user policy &quot;flash:/&quot; 
</code></pre><p><em>courtesy of Chris Partsenidis</em></p>
]]></content>
        </item>
        
        <item>
            <title>Ansible</title>
            <link>https://netautogr.github.io/posts/2020/11/ansible/</link>
            <pubDate>Mon, 16 Nov 2020 14:25:30 +0200</pubDate>
            
            <guid>https://netautogr.github.io/posts/2020/11/ansible/</guid>
            <description>Η Ansible είναι ένα εργαλείο για configuration management στην λογική των Chef, Puppet και Salt. Ο βασικός λόγος της δημιουργίας της ήταν η ανάγκη για ένα agent-less automation framework και αυτό ήταν που οδήγησε στην υιοθέτησή της από μεγάλη μερίδα μηχανικών δικτύου που ήθελαν να αυτοματοποιήσουν τις εργασίες τους χωρίς όμως να έχουν την δυνατότητα εγκατάστασης agents στον εξοπλισμό τους. Παρακάτω γίνεται μια απόπειρα αποδελτίωσης των θετικών και των αρνητικών του εργαλείου ούτως ώστε η καθεμία να αποφασίσει μόνη της αν αξίζει να ασχοληθεί.</description>
            <content type="html"><![CDATA[<p>Η Ansible είναι ένα εργαλείο για configuration management στην λογική των Chef, Puppet και Salt. Ο βασικός λόγος της δημιουργίας της ήταν η ανάγκη για ένα agent-less automation framework και αυτό ήταν που οδήγησε στην υιοθέτησή της από μεγάλη μερίδα μηχανικών δικτύου που ήθελαν να αυτοματοποιήσουν τις εργασίες τους χωρίς όμως να έχουν την δυνατότητα εγκατάστασης agents στον εξοπλισμό τους.
Παρακάτω γίνεται μια απόπειρα αποδελτίωσης των θετικών και των αρνητικών του εργαλείου ούτως ώστε η καθεμία να αποφασίσει μόνη της αν αξίζει να ασχοληθεί.
TL;DR, η Ansible είναι μια καλή επιλογή για σχετικά αρχάριους στον χώρο του αυτοματισμού δικτύων με σχετικά ήπια καμπύλη εκμάθησης. Είναι επαρκής για απλές επαναλαμβανόμενες δουλειές αλλά αργή και ανίκανη να φέρει εις πέρας πολύπλοκα tasks.</p>
<h2 id="θετικά">Θετικά:</h2>
<ul>
<li><strong>Agentless</strong>: δεν απαιτείται εγκατάσταση agent στον εξοπλισμό - η σύνδεση σε δικτυακά μηχανήματα συνήθως γίνεται μέσω SSH.</li>
<li><strong>Παραλληλισμός</strong>: το ίδιο task μπορεί να τρέχει παράλληλα σε πολλαπλά hosts.</li>
<li><strong>Inventory &amp; variable inheritance</strong>: ο μηχανισμός με τον οποίο η Ansible ομαδοποιεί hosts και μοιράζεται μεταβλητές μεταξύ τους είναι πολύ ισχυρός και επεκτάσιμος. Αυτό την κάνει καλή επιλογή για πολύπλοκα περιβάλλοντα με πολλαπλά sites, prod/dev/test segments, κτλ.</li>
<li>Ecosystem: υπάρχει μεγάλος πλούτος από libraries (modules, roles, collections στην «διάλεκτο» της Ansible) που κάνουν εύκολη την δουλειά του administrator.</li>
</ul>
<h2 id="ούτε-κρύο-ούτε-ζέστη">Ούτε κρύο, ούτε ζέστη:</h2>
<ul>
<li><strong>DSL</strong>: Η Ansible «μιλάει» μια δική της γλώσσα (Domain Specific Language) που πατάει πάνω στην YAML. Από την μία, αυτό την κάνει αρκετά πιο απλή στην κατανόηση από τους ανθρώπους που δεν έχουν έκθεση σε αρχές προγραμματισμού. Από την άλλη, αυτό την κάνει αρκετά πιο περιοριστική για τους ανθρώπους που σκαμπάζουν. Επιπλέον, ένα κοινό επιχείρημα κατά των διαφόρων DSLs (Ansible, Terraform, etc) είναι πως, αντί να μαθαίνεις να γράφεις μια proper γλώσσα προγραμματισμού, μαθαίνει μια proprietary γλώσσα με de-facto περιορισμένο scope. Έκαστος εφ’ ω ετάχθη…</li>
<li><strong>Break-out to Python</strong>: Στο σημείο που ζορίζει το πράγμα και η Ansible δεν μπορεί να κάνει τα μαγκαϊβεριλίκια που θέλεις, κάνεις break-out σε Python. Τα θετικά/αρνητικά του συγκεκριμένου fact είναι άσκηση για το σπίτι…</li>
<li><strong>Delivery mechanism</strong>: Το GUI add-on (AWX) είναι ένας good-enough μηχανισμός για delivery.</li>
</ul>
<h2 id="αρνητικά-της-ansible">Αρνητικά της Ansible:</h2>
<ul>
<li><strong>SLOWWW</strong>: Είναι αργή! Ακόμη και αν φτάσεις στο σημείο να κάνεις τα πιο advanced κόλπα (forks, strategies, async) η Ansible παραμένει πολύ αργή!!!</li>
<li><strong>No event-driven mechanism</strong>: Δεν έχει μηχανισμό για event-driven automation.</li>
<li><strong>Complex tasks</strong>: Είναι απαράδεκτη για complex tasks με πολύ περιορισμένες δυνατότητες για loops, conditionals και παρόμοια structures.</li>
</ul>
]]></content>
        </item>
        
    </channel>
</rss>
